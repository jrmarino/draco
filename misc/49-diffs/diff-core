--- gcc/DEV-PHASE.orig
+++ gcc/DEV-PHASE
@@ -0,0 +1 @@
+release
--- /dev/null
+++ gcc/config/dragonfly-stdint.h
@@ -0,0 +1,56 @@
+/* Definitions for <stdint.h> types for DragonFly systems.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   Contributed by Gerald Pfeifer <gerald@pfeifer.com>.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#define SIG_ATOMIC_TYPE   "int"
+
+#define INT8_TYPE         "signed char"
+#define INT16_TYPE        "short int"
+#define INT32_TYPE        "int"
+#define INT64_TYPE        (LONG_TYPE_SIZE == 64 ? "long int" : "long long int")
+#define UINT8_TYPE        "unsigned char"
+#define UINT16_TYPE       "short unsigned int"
+#define UINT32_TYPE       "unsigned int"
+#define UINT64_TYPE       (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "long long unsigned int")
+
+#define INT_LEAST8_TYPE   INT8_TYPE
+#define INT_LEAST16_TYPE  INT16_TYPE
+#define INT_LEAST32_TYPE  INT32_TYPE
+#define INT_LEAST64_TYPE  INT64_TYPE
+#define UINT_LEAST8_TYPE  UINT8_TYPE
+#define UINT_LEAST16_TYPE UINT16_TYPE
+#define UINT_LEAST32_TYPE UINT32_TYPE
+#define UINT_LEAST64_TYPE UINT64_TYPE
+
+#define INT_FAST8_TYPE    INT32_TYPE
+#define INT_FAST16_TYPE   INT32_TYPE
+#define INT_FAST32_TYPE   INT32_TYPE
+#define INT_FAST64_TYPE   INT64_TYPE
+#define UINT_FAST8_TYPE   UINT32_TYPE
+#define UINT_FAST16_TYPE  UINT32_TYPE
+#define UINT_FAST32_TYPE  UINT32_TYPE
+#define UINT_FAST64_TYPE  UINT64_TYPE
+
+#define INTPTR_TYPE       (LONG_TYPE_SIZE == 64 ?  INT64_TYPE :  INT32_TYPE)
+#define UINTPTR_TYPE      (LONG_TYPE_SIZE == 64 ? UINT64_TYPE : UINT32_TYPE)
--- /dev/null
+++ gcc/config/dragonfly.h
@@ -0,0 +1,136 @@
+/* Base configuration file for all DragonFly targets.
+   Copyright (C) 1999, 2000, 2001, 2007, 2008 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Common DragonFly configuration.
+   All DragonFly architectures should include this file, which will specify
+   their commonalities.
+   Adapted from gcc/config/i386/freebsd-elf.h by
+   David O'Brien <obrien@FreeBSD.org>.
+   Further work by David O'Brien <obrien@FreeBSD.org> and
+   Loren J. Rittle <ljrittle@acm.org>.  */
+
+#undef  TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()            \
+  do                                        \
+    {                                       \
+       builtin_define_std ("unix");         \
+       builtin_define ("__DragonFly__");    \
+       builtin_assert ("system=unix");      \
+       builtin_assert ("system=bsd");       \
+       builtin_assert ("system=DragonFly"); \
+    }                                       \
+  while (0)
+
+#undef  CPP_SPEC
+#define CPP_SPEC \
+ "%(cpp_cpu) %(cpp_arch) %{posix:-D_POSIX_SOURCE}"
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC	\
+  "%{!shared: \
+     %{pg:gcrt1.o%s} \
+     %{!pg: \
+       %{p:gcrt1.o%s} \
+       %{!p: \
+         %{profile: gcrt1.o%s} \
+         %{!profile: \
+           %{pie: Scrt1.o%s;:crt1.o%s}}}}} \
+   crti.o%s \
+   %{shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC \
+  "%{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
+
+#undef  LIB_SPEC
+#define LIB_SPEC \
+  "%{pthread:-lpthread} -lc"
+
+#if defined(HAVE_LD_EH_FRAME_HDR)
+#define LINK_EH_SPEC "--eh-frame-hdr"
+#endif
+
+/* Provide a LINK_SPEC appropriate for DragonFly.  Here we provide support
+   for the special GCC options -static and -shared, which allow us to
+   link things in one of these three modes by applying the appropriate
+   combinations of options at link-time.
+
+   When the -shared link option is used a final link is not being
+   done.  */
+
+#define DFBSD_LINK_SPEC \
+ "%{p:%nconsider using '-pg' instead of '-p' with gprof(1)} \
+  %{v:-V} \
+  %{assert*} %{R*} %{rpath*} %{defsym*} \
+  %{shared:-Bshareable %{h*} %{soname*}} \
+  %{!shared: \
+   %{!static: \
+    %{rdynamic:-export-dynamic} \
+    -dynamic-linker %(dfbsd_dynamic_linker) \
+   } \
+   %{static:-Bstatic} \
+  } \
+  %{!static:--hash-style=gnu -rpath @PREFIX@/gcc-aux/lib} \
+  %{symbolic:-Bsymbolic}"
+
+#undef  LINK_SPEC
+#define LINK_SPEC DFBSD_LINK_SPEC
+
+#define DFBSD_DYNAMIC_LINKER "/usr/libexec/ld-elf.so.2"
+
+
+/* Use --as-needed -lgcc_s for eh support.  */
+#ifdef HAVE_LD_AS_NEEDED
+#define USE_LD_AS_NEEDED 1
+#endif
+
+/************************[  Target stuff  ]***********************************/
+
+/* All DragonFly Architectures support the ELF object file format.  */
+#undef  OBJECT_FORMAT_ELF
+#define OBJECT_FORMAT_ELF
+
+/* Don't assume anything about the header files.  */
+#undef  NO_IMPLICIT_EXTERN_C
+#define NO_IMPLICIT_EXTERN_C	1
+
+/* Follow DragonFly's standard headers (<machine/stdint.h>, etc...).  */
+
+#undef  WCHAR_TYPE
+#define WCHAR_TYPE "int"
+
+#undef  WINT_TYPE
+#define WINT_TYPE "int"
+
+/* 
+ * Profile libraries are found at /usr/lib/profile with standard names
+ * #define MATH_LIBRARY_PROFILE    "m_p" 
+ */
+
+/* Code generation parameters.  */
+
+/* Use periods rather than dollar signs in special g++ assembler names.
+   This ensures the configuration knows our system correctly so we can link
+   with libraries compiled with the native cc.  */
+#undef NO_DOLLAR_IN_LABEL
+
+/* Used by libgcc2.c.  We support file locking with fcntl / F_SETLKW.
+   This enables the test coverage code to use file locking when exiting a
+   program, which avoids race conditions if the program has forked.  */
+#define TARGET_POSIX_IO
--- /dev/null
+++ gcc/config/dragonfly.opt
@@ -0,0 +1,65 @@
+; DragonFlyBSD options.
+
+; Copyright (C) 2010, 2011
+; Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+; See the GCC internals manual (options.texi) for a description of this file's format.
+
+; Please try to keep this file in ASCII collating order.
+
+assert
+Driver Separate
+
+assert=
+Driver JoinedOrMissing
+
+defsym
+Driver Separate
+
+defsym=
+Driver JoinedOrMissing
+
+posix
+Driver
+
+profile
+Driver
+
+pthread
+Driver
+
+rdynamic
+Driver
+
+rpath-link
+Driver Separate
+
+rpath-link=
+Driver JoinedOrMissing
+
+rpath=
+Driver JoinedOrMissing
+
+soname
+Driver Separate
+
+soname=
+Driver JoinedOrMissing
+
+; This comment is to ensure we retain the blank line above.
--- /dev/null
+++ gcc/config/netbsd-stdint.h
@@ -0,0 +1,56 @@
+/* Definitions for <stdint.h> types for NetBSD systems.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   Contributed by Gerald Pfeifer <gerald@pfeifer.com>.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#define SIG_ATOMIC_TYPE   "int"
+
+#define INT8_TYPE         "signed char"
+#define INT16_TYPE        "short int"
+#define INT32_TYPE        "int"
+#define INT64_TYPE        (LONG_TYPE_SIZE == 64 ? "long int" : "long long int")
+#define UINT8_TYPE        "unsigned char"
+#define UINT16_TYPE       "short unsigned int"
+#define UINT32_TYPE       "unsigned int"
+#define UINT64_TYPE       (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "long long unsigned int")
+
+#define INT_LEAST8_TYPE   "signed char"
+#define INT_LEAST16_TYPE  "short int"
+#define INT_LEAST32_TYPE  "int"
+#define INT_LEAST64_TYPE  (LONG_TYPE_SIZE == 64 ? "long int" : "long long int")
+#define UINT_LEAST8_TYPE  "unsigned char"
+#define UINT_LEAST16_TYPE "short unsigned int"
+#define UINT_LEAST32_TYPE "unsigned int"
+#define UINT_LEAST64_TYPE (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "long long unsigned int")
+
+#define INT_FAST8_TYPE    "int"
+#define INT_FAST16_TYPE   "int"
+#define INT_FAST32_TYPE   "int"
+#define INT_FAST64_TYPE   (LONG_TYPE_SIZE == 64 ? "long int" : "long long int")
+#define UINT_FAST8_TYPE   "unsigned int"
+#define UINT_FAST16_TYPE  "unsigned int"
+#define UINT_FAST32_TYPE  "unsigned int"
+#define UINT_FAST64_TYPE  (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "long long unsigned int")
+
+#define INTPTR_TYPE       (LONG_TYPE_SIZE == 64 ? "long int" : "int")
+#define UINTPTR_TYPE      (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "unsigned int")
--- gcc/config/openbsd-libpthread.h.orig
+++ gcc/config/openbsd-libpthread.h
@@ -18,5 +18,5 @@
    along with GCC; see the file COPYING3.  If not see
    <http://www.gnu.org/licenses/>.  */
 
-#define OBSD_LIB_SPEC "%{!shared:%{pthread:-lpthread} -lc}"
+#define OBSD_LIB_SPEC "%{pthread:-lpthread%{!shared:%{p|pg:_p}}} %{!shared:-lc%{p:_p}%{!p:%{pg:_p}}}"
 
--- gcc/config/openbsd.h.orig
+++ gcc/config/openbsd.h
@@ -108,9 +108,9 @@
    This two-stage defines makes it easy to pick that for targets that
    have subspecs.  */
 #ifdef CPP_CPU_SPEC
-#define OBSD_CPP_SPEC "%(cpp_cpu) %{posix:-D_POSIX_SOURCE} %{pthread:-D_POSIX_THREADS}"
+#define OBSD_CPP_SPEC "%(cpp_cpu) %{posix:-D_POSIX_SOURCE} %{pthread:-D_REENTRANT}"
 #else
-#define OBSD_CPP_SPEC "%{posix:-D_POSIX_SOURCE} %{pthread:-D_POSIX_THREADS}"
+#define OBSD_CPP_SPEC "%{posix:-D_POSIX_SOURCE} %{pthread:-D_REENTRANT}"
 #endif
 
 #undef LIB_SPEC
@@ -143,6 +143,9 @@
 #define LIB_SPEC OBSD_LIB_SPEC
 #endif
 
+#undef LINK_PIE_SPEC
+#define LINK_PIE_SPEC "%{pie:-pie} %{p|pg|nopie:-nopie} "
+
 #define TARGET_POSIX_IO
 
 /* All new versions of OpenBSD have C99 functions.  We redefine this hook
@@ -285,5 +288,12 @@
 
 /* Storage layout.  */
 
+/* Silence "unsafe GNU crap" messages */
+#define NO_UNSAFE_BUILTINS
+
+/* The system headers on OpenBSD are C++-aware.  */
+#undef NO_IMPLICIT_EXTERN_C
+#define NO_IMPLICIT_EXTERN_C
+
 
 #define HAVE_ENABLE_EXECUTE_STACK
--- gcc/config/openbsd.opt.orig
+++ gcc/config/openbsd.opt
@@ -32,4 +32,7 @@
 pthread
 Driver
 
+rdynamic
+Driver
+
 ; This comment is to ensure we retain the blank line above.
--- /dev/null
+++ gcc/config/i386/dragonfly.h
@@ -0,0 +1,105 @@
+/* Definitions for Intel 386 running DragonFly with ELF format
+   Copyright (C) 1996, 2000, 2002, 2004, 2007, 2010, 2011
+   Free Software Foundation, Inc.
+   Contributed by Eric Youngdale.
+   Modified for stabs-in-ELF by H.J. Lu.
+   Adapted from GNU/Linux version by John Polstra.
+   Continued development by David O'Brien <obrien@freebsd.org>
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+
+/* Override the default comment-starter of "/".  */
+#undef  ASM_COMMENT_START
+#define ASM_COMMENT_START "#"
+
+#undef  ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+#undef  ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+#undef  DBX_REGISTER_NUMBER
+#define DBX_REGISTER_NUMBER(n) \
+  (TARGET_64BIT ? dbx64_register_map[n] : svr4_dbx_register_map[n])
+
+#undef  NO_PROFILE_COUNTERS
+#define NO_PROFILE_COUNTERS	1
+
+/* Tell final.c that we don't need a label passed to mcount.  */
+
+#undef  MCOUNT_NAME
+#define MCOUNT_NAME ".mcount"
+
+/* Make gcc agree with <machine/ansi.h>.  */
+
+#undef  SIZE_TYPE
+#define SIZE_TYPE	(TARGET_64BIT ? "long unsigned int" : "unsigned int")
+
+#undef  PTRDIFF_TYPE
+#define PTRDIFF_TYPE	(TARGET_64BIT ? "long int" : "int")
+
+#undef  WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE	(TARGET_64BIT ? 32 : BITS_PER_WORD)
+
+#undef  SUBTARGET_EXTRA_SPECS	/* i386.h bogusly defines it.  */
+#define SUBTARGET_EXTRA_SPECS \
+  { "dfbsd_dynamic_linker", DFBSD_DYNAMIC_LINKER }
+
+
+/* A C statement to output to the stdio stream FILE an assembler
+   command to advance the location counter to a multiple of 1<<LOG
+   bytes if it is within MAX_SKIP bytes.
+
+   This is used to align code labels according to Intel recommendations.  */
+
+#ifdef HAVE_GAS_MAX_SKIP_P2ALIGN
+#undef  ASM_OUTPUT_MAX_SKIP_ALIGN
+#define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE, LOG, MAX_SKIP)					\
+  if ((LOG) != 0) {														\
+    if ((MAX_SKIP) == 0) fprintf ((FILE), "\t.p2align %d\n", (LOG));	\
+    else fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP));	\
+  }
+#endif
+
+/* Don't default to pcc-struct-return, we want to retain compatibility with
+   older gcc versions AND pcc-struct-return is nonreentrant.
+   (even though the SVR4 ABI for the i386 says that records and unions are
+   returned in memory).  */
+
+#undef  DEFAULT_PCC_STRUCT_RETURN
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* DragonFly sets the rounding precision of the FPU to 53 bits.  Let the
+   compiler get the contents of <float.h> and std::numeric_limits correct.  */
+#undef TARGET_96_ROUND_53_LONG_DOUBLE
+#define TARGET_96_ROUND_53_LONG_DOUBLE (!TARGET_64BIT)
+
+/* Put all *tf routines in libgcc.  */
+#undef LIBGCC2_HAS_TF_MODE
+#define LIBGCC2_HAS_TF_MODE 1
+#define LIBGCC2_TF_CEXT q
+#define TF_SIZE 113
+
+/* Static stack checking is supported by means of probes.  */
+#define STACK_CHECK_STATIC_BUILTIN 1
+
+/* Support for i386 has been removed from DragonFly for several releases  */
+#define SUBTARGET32_DEFAULT_CPU "i486"
+
+#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
+
--- gcc/config/i386/freebsd.h.orig
+++ gcc/config/i386/freebsd.h
@@ -90,6 +90,14 @@
    When the -shared link option is used a final link is not being
    done.  */
 
+#if FBSD_MAJOR < 9
+#define ELF_HASH_STYLE ""
+#elif FBSD_MAJOR < 10
+#define ELF_HASH_STYLE "--hash-style=both "
+#else
+#define ELF_HASH_STYLE "--hash-style=gnu "
+#endif
+
 #undef	LINK_SPEC
 #define LINK_SPEC "\
   %{p:%nconsider using '-pg' instead of '-p' with gprof(1)} \
@@ -101,6 +109,7 @@
         %{rdynamic:-export-dynamic} \
         -dynamic-linker %(fbsd_dynamic_linker) } \
     %{static:-Bstatic}} \
+  %{!static:" ELF_HASH_STYLE "-rpath @PREFIX@/gcc-aux/lib} \
   %{symbolic:-Bsymbolic}"
 
 /* A C statement to output to the stdio stream FILE an assembler
@@ -147,3 +156,5 @@
 
 #define TARGET_ASM_FILE_END file_end_indicate_exec_stack
 
+/* Compile in __enable_execute_stack (void *) (see config.host) */
+#define HAVE_ENABLE_EXECUTE_STACK
--- gcc/config/i386/freebsd64.h.orig
+++ gcc/config/i386/freebsd64.h
@@ -41,4 +41,5 @@
         %{rdynamic:-export-dynamic} \
 	-dynamic-linker %(fbsd_dynamic_linker) } \
     %{static:-Bstatic}} \
+  %{!static:" ELF_HASH_STYLE "-rpath @PREFIX@/gcc-aux/lib} \
   %{symbolic:-Bsymbolic}"
--- gcc/config/i386/netbsd-elf.h.orig
+++ gcc/config/i386/netbsd-elf.h
@@ -38,7 +38,8 @@
 /* Provide a LINK_SPEC appropriate for a NetBSD/i386 ELF target.  */
 
 #undef LINK_SPEC
-#define LINK_SPEC NETBSD_LINK_SPEC_ELF
+#define LINK_SPEC NETBSD_LINK_SPEC_ELF \
+"%{!static:-rpath @PREFIX@/gcc-aux/lib}"
 
 #define NETBSD_ENTRY_POINT "__start"
 
@@ -119,3 +120,9 @@
 #define DEFAULT_PCC_STRUCT_RETURN 1
 
 #define HAVE_ENABLE_EXECUTE_STACK
+/* Define this to be nonzero if static stack checking is supported. */
+#define STACK_CHECK_STATIC_BUILTIN 1
+
+#if defined(HAVE_LD_EH_FRAME_HDR)
+#define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
+#endif
--- gcc/config/i386/netbsd64.h.orig
+++ gcc/config/i386/netbsd64.h
@@ -67,3 +67,10 @@
 }
 
 #define HAVE_ENABLE_EXECUTE_STACK
+
+/* Define this to be nonzero if static stack checking is supported. */
+#define STACK_CHECK_STATIC_BUILTIN 1
+
+#if defined(HAVE_LD_EH_FRAME_HDR)
+#define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
+#endif
--- gcc/config/i386/openbsd.h.orig
+++ gcc/config/i386/openbsd.h
@@ -38,10 +38,10 @@
 
 /* This must agree with <machine/ansi.h> */
 #undef SIZE_TYPE
-#define SIZE_TYPE "unsigned int"
+#define SIZE_TYPE "long unsigned int"
 
 #undef PTRDIFF_TYPE
-#define PTRDIFF_TYPE "int"
+#define PTRDIFF_TYPE "long int"
 
 #undef WCHAR_TYPE
 #define WCHAR_TYPE "int"
@@ -49,6 +49,9 @@
 #undef WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE 32
 
+#undef WINT_TYPE
+#define WINT_TYPE "int"
+
 /* Assembler format: overall framework.  */
 
 #undef ASM_APP_ON
--- gcc/config/i386/openbsdelf.h.orig
+++ gcc/config/i386/openbsdelf.h
@@ -97,9 +97,12 @@
    %{shared:-shared} %{R*} \
    %{static:-Bstatic} \
    %{!static:-Bdynamic} \
+   %{rdynamic:-export-dynamic} \
    %{assert*} \
    -dynamic-linker /usr/libexec/ld.so"
 
+#define SUBTARGET32_DEFAULT_CPU "i486"
+
 #undef STARTFILE_SPEC
 #define STARTFILE_SPEC "\
 	%{!shared: %{pg:gcrt0%O%s} %{!pg:%{p:gcrt0%O%s} %{!p:crt0%O%s}} \
--- gcc/ginclude/stddef.h.orig
+++ gcc/ginclude/stddef.h
@@ -50,6 +50,11 @@
    one less case to deal with in the following.  */
 #if defined (__BSD_NET2__) || defined (____386BSD____) || (defined (__FreeBSD__) && (__FreeBSD__ < 5)) || defined(__NetBSD__)
 #include <machine/ansi.h>
+#if !defined(_MACHINE_ANSI_H_)
+#if defined(_I386_ANSI_H_) || defined(_X86_64_ANSI_H_)
+#define _MACHINE_ANSI_H_
+#endif
+#endif
 #endif
 /* On FreeBSD 5, machine/ansi.h does not exist anymore... */
 #if defined (__FreeBSD__) && (__FreeBSD__ >= 5)
@@ -133,6 +138,7 @@
 #ifndef _BSD_PTRDIFF_T_
 #ifndef ___int_ptrdiff_t_h
 #ifndef _GCC_PTRDIFF_T
+#ifndef _PTRDIFF_T_DECLARED /* DragonFly */
 #define _PTRDIFF_T
 #define _T_PTRDIFF_
 #define _T_PTRDIFF
@@ -141,10 +147,12 @@
 #define _BSD_PTRDIFF_T_
 #define ___int_ptrdiff_t_h
 #define _GCC_PTRDIFF_T
+#define _PTRDIFF_T_DECLARED
 #ifndef __PTRDIFF_TYPE__
 #define __PTRDIFF_TYPE__ long int
 #endif
 typedef __PTRDIFF_TYPE__ ptrdiff_t;
+#endif /* _PTRDIFF_T_DECLARED */
 #endif /* _GCC_PTRDIFF_T */
 #endif /* ___int_ptrdiff_t_h */
 #endif /* _BSD_PTRDIFF_T_ */
@@ -198,6 +206,7 @@
 #define _GCC_SIZE_T
 #define _SIZET_
 #if (defined (__FreeBSD__) && (__FreeBSD__ >= 5)) \
+  || defined(__DragonFly__) \
   || defined(__FreeBSD_kernel__)
 /* __size_t is a typedef on FreeBSD 5, must not trash it. */
 #elif defined (__VMS__)
--- include/libiberty.h.orig
+++ include/libiberty.h
@@ -106,7 +106,16 @@
    to find the declaration so provide a fully prototyped one.  If it
    is 1, we found it so don't provide any declaration at all.  */
 #if !HAVE_DECL_BASENAME
-#if defined (__GNU_LIBRARY__ ) || defined (__linux__) || defined (__FreeBSD__) || defined (__OpenBSD__) || defined(__NetBSD__) || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (__MINGW32__) || defined (HAVE_DECL_BASENAME)
+#if defined (__GNU_LIBRARY__ ) \
+ || defined (__linux__) \
+ || defined (__DragonFly__) \
+ || defined (__FreeBSD__) \
+ || defined (__OpenBSD__) \
+ || defined (__NetBSD__) \
+ || defined (__CYGWIN__) \
+ || defined (__CYGWIN32__) \
+ || defined (__MINGW32__) \
+ || defined (HAVE_DECL_BASENAME)
 extern char *basename (const char *) ATTRIBUTE_RETURNS_NONNULL ATTRIBUTE_NONNULL(1);
 #else
 /* Do not allow basename to be used if there is no prototype seen.  We
--- libgcc/crtstuff.c.orig
+++ libgcc/crtstuff.c
@@ -79,11 +79,19 @@
 }
 #endif
 
+#if defined(TARGET_DL_ITERATE_PHDR) && \
+   ( defined(__FreeBSD__)              \
+  || defined(__OpenBSD__)              \
+  || defined(__NetBSD__)               \
+  || defined(__DragonFly__))
+#define BSD_DL_ITERATE_PHDR_AVAILABLE
+#endif
+
 #if defined(OBJECT_FORMAT_ELF) \
     && !defined(OBJECT_FORMAT_FLAT) \
     && defined(HAVE_LD_EH_FRAME_HDR) \
     && !defined(inhibit_libc) && !defined(CRTSTUFFT_O) \
-    && defined(__FreeBSD__) && __FreeBSD__ >= 7
+    && defined(BSD_DL_ITERATE_PHDR_AVAILABLE)
 #include <link.h>
 # define USE_PT_GNU_EH_FRAME
 #endif
--- /dev/null
+++ libgcc/enable-execute-stack-freebsd.c
@@ -0,0 +1,58 @@
+/* Implement __enable_execute_stack using mprotect(2).
+   Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3, or (at your option) any later
+   version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sys/mman.h>
+#include <unistd.h>
+#include <stdlib.h>
+
+#define STACK_PROT_RWX (PROT_READ | PROT_WRITE | PROT_EXEC)
+
+extern void __enable_execute_stack (void *);
+
+void
+__enable_execute_stack (void *addr)
+{
+  static int size;
+  static long mask;
+  char *page, *ends;
+  long page_addr, ends_addr;
+
+  if (size == 0)
+  {
+    size = getpagesize ();
+    mask = ~((long) size - 1);
+  }
+  page_addr = (long) addr;
+  ends_addr = (long) (addr + __LIBGCC_TRAMPOLINE_SIZE__);
+
+  page = (char *) (page_addr & mask);
+  ends = (char *) ((ends_addr & mask) + size);
+
+  /*
+   * Note that no errors should be emitted by mprotect; it is considered
+   * dangerous for library calls to send messages to stdout/stderr.
+   */
+  if (mprotect (page, ends - page, STACK_PROT_RWX) < 0)
+    abort ();
+}
--- libgcc/unwind-dw2-fde-dip.c.orig
+++ libgcc/unwind-dw2-fde-dip.c
@@ -58,11 +58,19 @@
 #endif
 
 #if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
-    && defined(__FreeBSD__) && __FreeBSD__ >= 7
+    && defined(TARGET_DL_ITERATE_PHDR) \
+    && (defined(__FreeBSD__) || defined(__DragonFly__))
 # define ElfW __ElfN
 # define USE_PT_GNU_EH_FRAME
 #endif
 
+#if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
+    && defined(TARGET_DL_ITERATE_PHDR) \
+    && (defined(__OpenBSD__) || defined(__NetBSD__))
+# define ElfW(n) Elf_##n
+# define USE_PT_GNU_EH_FRAME
+#endif
+
 #if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
     && defined(__OpenBSD__)
 # define ElfW(type) Elf_##type
--- /dev/null
+++ libgcc/config/i386/dragonfly-unwind.h
@@ -0,0 +1,158 @@
+/* DWARF2 EH unwinding support for DragonFly BSD: AMD x86-64 and x86.
+   Copyright (C) 2010 John Marino <draco@marino.st> */
+
+/* Do code reading to identify a signal frame, and set the frame
+   state data appropriately.  See unwind-dw2.c for the structs. */
+
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <signal.h>
+#include <sys/ucontext.h>
+#include <machine/sigframe.h>
+
+
+#define REG_NAME(reg)	sf_uc.uc_mcontext.mc_## reg
+
+#ifdef __x86_64__
+#define MD_FALLBACK_FRAME_STATE_FOR x86_64_dragonfly_fallback_frame_state
+
+
+static void
+x86_64_sigtramp_range (unsigned char **start, unsigned char **end)
+{
+  unsigned long ps_strings;
+  int mib[2];
+  size_t len;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PS_STRINGS;
+  len = sizeof (ps_strings);
+  sysctl (mib, 2, &ps_strings, &len, NULL, 0);
+
+  *start = (unsigned char *)ps_strings - 32;
+  *end   = (unsigned char *)ps_strings;
+}
+
+
+static _Unwind_Reason_Code
+x86_64_dragonfly_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  unsigned char *pc = context->ra;
+  unsigned char *sigtramp_start, *sigtramp_end;
+  struct sigframe *sf;
+  long new_cfa;
+
+  x86_64_sigtramp_range(&sigtramp_start, &sigtramp_end);
+  if (pc >= sigtramp_end || pc < sigtramp_start)
+    return _URC_END_OF_STACK;
+
+  sf = (struct sigframe *) context->cfa;
+  new_cfa = sf->REG_NAME(rsp);
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  /* Register 7 is rsp  */
+  fs->regs.cfa_reg = 7;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(rax) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(rdx) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(rcx) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(rbx) - new_cfa;
+  fs->regs.reg[4].how = REG_SAVED_OFFSET;
+  fs->regs.reg[4].loc.offset = (long)&sf->REG_NAME(rsi) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(rdi) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(rbp) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(r8) - new_cfa;
+  fs->regs.reg[9].how = REG_SAVED_OFFSET;
+  fs->regs.reg[9].loc.offset = (long)&sf->REG_NAME(r9) - new_cfa;
+  fs->regs.reg[10].how = REG_SAVED_OFFSET;
+  fs->regs.reg[10].loc.offset = (long)&sf->REG_NAME(r10) - new_cfa;
+  fs->regs.reg[11].how = REG_SAVED_OFFSET;
+  fs->regs.reg[11].loc.offset = (long)&sf->REG_NAME(r11) - new_cfa;
+  fs->regs.reg[12].how = REG_SAVED_OFFSET;
+  fs->regs.reg[12].loc.offset = (long)&sf->REG_NAME(r12) - new_cfa;
+  fs->regs.reg[13].how = REG_SAVED_OFFSET;
+  fs->regs.reg[13].loc.offset = (long)&sf->REG_NAME(r13) - new_cfa;
+  fs->regs.reg[14].how = REG_SAVED_OFFSET;
+  fs->regs.reg[14].loc.offset = (long)&sf->REG_NAME(r14) - new_cfa;
+  fs->regs.reg[15].how = REG_SAVED_OFFSET;
+  fs->regs.reg[15].loc.offset = (long)&sf->REG_NAME(r15) - new_cfa;
+  fs->regs.reg[16].how = REG_SAVED_OFFSET;
+  fs->regs.reg[16].loc.offset = (long)&sf->REG_NAME(rip) - new_cfa;
+  fs->retaddr_column = 16;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+
+#else /* Next section is for i386  */
+
+#define MD_FALLBACK_FRAME_STATE_FOR x86_dragonfly_fallback_frame_state
+
+
+static void
+x86_sigtramp_range (unsigned char **start, unsigned char **end)
+{
+  unsigned long ps_strings;
+  int mib[2];
+  size_t len;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PS_STRINGS;
+  len = sizeof (ps_strings);
+  sysctl (mib, 2, &ps_strings, &len, NULL, 0);
+
+  *start = (unsigned char *)ps_strings - 128;
+  *end   = (unsigned char *)ps_strings;
+}
+
+
+static _Unwind_Reason_Code
+x86_dragonfly_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  unsigned char *pc = context->ra;
+  unsigned char *sigtramp_start, *sigtramp_end;
+  struct sigframe *sf;
+  long new_cfa;
+
+  x86_sigtramp_range(&sigtramp_start, &sigtramp_end);
+
+  if (pc >= sigtramp_end || pc < sigtramp_start)
+    return _URC_END_OF_STACK;
+
+  sf = (struct sigframe *) context->cfa;
+  new_cfa = sf->REG_NAME(esp);
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  fs->regs.cfa_reg = 4;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(eax) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(ebx) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(ecx) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(edx) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(esi) - new_cfa;
+  fs->regs.reg[7].how = REG_SAVED_OFFSET;
+  fs->regs.reg[7].loc.offset = (long)&sf->REG_NAME(edi) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(ebp) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(eip) - new_cfa;
+  fs->retaddr_column = 8;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+#endif /* ifdef __x86_64__  */
--- /dev/null
+++ libgcc/config/i386/freebsd-unwind.h
@@ -0,0 +1,198 @@
+/* DWARF2 EH unwinding support for FreeBSD: AMD x86-64 and x86.
+ *  Copyright (C) 2010, 2012, 2014 John Marino <draco@marino.st>
+ *
+ *  Do code reading to identify a signal frame, and set the frame
+ *  state data appropriately.  See unwind-dw2.c for the structs.
+ */
+
+#include <sys/types.h>
+#include <signal.h>
+#include <sys/ucontext.h>
+#include <machine/sigframe.h>
+
+#define REG_NAME(reg)	sf_uc.uc_mcontext.mc_## reg
+
+#ifdef __x86_64__
+#define MD_FALLBACK_FRAME_STATE_FOR x86_64_freebsd_fallback_frame_state
+
+#if (__FreeBSD__ < 9)
+#include <sys/sysctl.h>
+static void
+x86_64_sigtramp_range (unsigned char **start, unsigned char **end)
+{
+  unsigned long ps_strings;
+  int mib[2];
+  size_t len;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PS_STRINGS;
+  len = sizeof (ps_strings);
+  sysctl (mib, 2, &ps_strings, &len, NULL, 0);
+
+  *start = (unsigned char *)ps_strings - 32;
+  *end   = (unsigned char *)ps_strings;
+}
+#endif
+
+
+static _Unwind_Reason_Code
+x86_64_freebsd_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  struct sigframe *sf;
+  long new_cfa;
+
+#if (__FreeBSD__ < 9)
+  unsigned char *pc = context->ra;
+  unsigned char *sigtramp_start, *sigtramp_end;
+
+  x86_64_sigtramp_range(&sigtramp_start, &sigtramp_end);
+  if (pc >= sigtramp_end || pc < sigtramp_start)
+    return _URC_END_OF_STACK;
+#else
+  /* Prior to FreeBSD 9, the signal trampoline was located immediately
+     before the ps_strings.  To support non-executable stacks on AMD64,
+     the sigtramp was moved to a shared page for FreeBSD 9.  We are
+     stuck looking for frame patterns again (sys/amd64/amd64/sigtramp.S):
+
+     <pc + 00>:  lea     0x10(%rsp),%rdi
+     <pc + 05>:  pushq   $0x0
+     <pc + 17>:  mov     $0x1a1,%rax
+     <pc + 14>:  syscall
+
+     If we can't find this pattern, we're at the end of the stack.
+  */
+
+  if (!(   *(unsigned int *)(context->ra)      == 0x247c8d48
+        && *(unsigned int *)(context->ra +  4) == 0x48006a10
+        && *(unsigned int *)(context->ra +  8) == 0x01a1c0c7
+        && *(unsigned int *)(context->ra + 12) == 0x050f0000 ))
+    return _URC_END_OF_STACK;
+#endif
+
+  sf = (struct sigframe *) context->cfa;
+  new_cfa = sf->REG_NAME(rsp);
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  /* Register 7 is rsp  */
+  fs->regs.cfa_reg = 7;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(rax) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(rdx) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(rcx) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(rbx) - new_cfa;
+  fs->regs.reg[4].how = REG_SAVED_OFFSET;
+  fs->regs.reg[4].loc.offset = (long)&sf->REG_NAME(rsi) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(rdi) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(rbp) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(r8) - new_cfa;
+  fs->regs.reg[9].how = REG_SAVED_OFFSET;
+  fs->regs.reg[9].loc.offset = (long)&sf->REG_NAME(r9) - new_cfa;
+  fs->regs.reg[10].how = REG_SAVED_OFFSET;
+  fs->regs.reg[10].loc.offset = (long)&sf->REG_NAME(r10) - new_cfa;
+  fs->regs.reg[11].how = REG_SAVED_OFFSET;
+  fs->regs.reg[11].loc.offset = (long)&sf->REG_NAME(r11) - new_cfa;
+  fs->regs.reg[12].how = REG_SAVED_OFFSET;
+  fs->regs.reg[12].loc.offset = (long)&sf->REG_NAME(r12) - new_cfa;
+  fs->regs.reg[13].how = REG_SAVED_OFFSET;
+  fs->regs.reg[13].loc.offset = (long)&sf->REG_NAME(r13) - new_cfa;
+  fs->regs.reg[14].how = REG_SAVED_OFFSET;
+  fs->regs.reg[14].loc.offset = (long)&sf->REG_NAME(r14) - new_cfa;
+  fs->regs.reg[15].how = REG_SAVED_OFFSET;
+  fs->regs.reg[15].loc.offset = (long)&sf->REG_NAME(r15) - new_cfa;
+  fs->regs.reg[16].how = REG_SAVED_OFFSET;
+  fs->regs.reg[16].loc.offset = (long)&sf->REG_NAME(rip) - new_cfa;
+  fs->retaddr_column = 16;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+
+#else /* Next section is for i386  */
+
+#define MD_FALLBACK_FRAME_STATE_FOR x86_freebsd_fallback_frame_state
+
+/*
+ * We can't use KERN_PS_STRINGS anymore if we want to support FreeBSD32
+ * compat on AMD64.  The sigtramp is in a shared page in that case so the
+ * x86_sigtramp_range only works on a true i386 system.  We have to
+ * search for the sigtramp frame if we want it working everywhere.
+
+#include <sys/sysctl.h>
+static void
+x86_sigtramp_range (unsigned char **start, unsigned char **end)
+{
+  unsigned long ps_strings;
+  int mib[2];
+  size_t len;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PS_STRINGS;
+  len = sizeof (ps_strings);
+  sysctl (mib, 2, &ps_strings, &len, NULL, 0);
+
+  *start = (unsigned char *)ps_strings - 128;
+  *end   = (unsigned char *)ps_strings;
+}
+*/
+
+
+static _Unwind_Reason_Code
+x86_freebsd_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  struct sigframe *sf;
+  long new_cfa;
+
+/*
+ * i386 sigtramp frame we are looking for follows.
+ * Apparently PSL_VM is variable, so we can't look past context->ra + 4
+ * <sigcode>:
+ *   0:	ff 54 24 10          	call   *0x10(%esp)          *SIGF_HANDLER
+ *   4:	8d 44 24 20          	lea    0x20(%esp),%eax       SIGF_UC
+ *   8:	50                   	push   %eax
+ *   9:	f7 40 54 00 00 02 00 	testl  $0x20000,0x54(%eax)  $PSL_VM
+ *  10:	75 03                	jne    15 <sigcode+0x15>
+ *  12:	8e 68 14             	mov    0x14(%eax),%gs        UC_GS
+ *  15:	b8 a1 01 00 00       	mov    0x1a1,%eax           $SYS_sigreturn
+ */
+
+  if (!(   *(unsigned int *)(context->ra - 4) == 0x102454ff
+        && *(unsigned int *)(context->ra)     == 0x2024448d ))
+    return _URC_END_OF_STACK;
+
+  sf = (struct sigframe *) context->cfa;
+  new_cfa = sf->REG_NAME(esp);
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  fs->regs.cfa_reg = 4;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(eax) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(ebx) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(ecx) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(edx) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(esi) - new_cfa;
+  fs->regs.reg[7].how = REG_SAVED_OFFSET;
+  fs->regs.reg[7].loc.offset = (long)&sf->REG_NAME(edi) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(ebp) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(eip) - new_cfa;
+  fs->retaddr_column = 8;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+#endif /* ifdef __x86_64__  */
--- /dev/null
+++ libgcc/config/i386/netbsd-unwind.h
@@ -0,0 +1,169 @@
+/* DWARF2 EH unwinding support for x86 NetBSD
+   Copyright (C) 2010 John Marino (www.dragonlace.net) */
+
+/* Do code reading to identify a signal frame, and set the frame
+   state data appropriately.  See unwind-dw2.c for the structs. */
+
+#include <sys/ucontext.h>
+#include <machine/frame.h>
+
+#define REG_NAME(reg)   sf_uc.uc_mcontext.__gregs[_REG_## reg]
+
+#ifdef __x86_64__
+
+
+
+
+#define MD_FALLBACK_FRAME_STATE_FOR x86_64_netbsd_fallback_frame_state
+
+static _Unwind_Reason_Code
+x86_64_netbsd_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  /* signal_frame is sigframe_siginfo minus sf_ra handler return address */
+  struct signal_frame {
+         siginfo_t    sf_si;   /* actual saved siginfo  */
+         ucontext_t   sf_uc;   /* actual saved ucontext */
+  };
+  struct signal_frame *sf;
+  long new_cfa;
+
+  /*  We are looking for the following signal trampoline pattern. If we don't
+      find it, we are at the end of the stack and can't unwind.
+
+      <__sigtramp_siginfo_2+12>:  mov     $0xffffffffffffffff,%rdi
+      <__sigtramp_siginfo_2+19>:  mov     $0x1,%rax
+      <__sigtramp_siginfo_2+26>:  syscall
+  */
+
+  if (   *(unsigned int   *) (context->ra + 12) == 0xffc7c748
+      && *(unsigned int   *) (context->ra + 16) == 0x48ffffff
+      && *(unsigned int   *) (context->ra + 20) == 0x0001c0c7
+      && *(unsigned int   *) (context->ra + 24) == 0x050f0000 )
+  {
+    sf = (struct signal_frame *) context->cfa;
+    new_cfa = sf->REG_NAME(RSP);
+    fs->regs.cfa_how = CFA_REG_OFFSET;
+    fs->regs.cfa_reg = 7;
+    fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+  }
+  else
+  {
+    return _URC_END_OF_STACK;
+  }
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[ 0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 0].loc.offset = (long)&sf->REG_NAME(RAX) - new_cfa;
+  fs->regs.reg[ 1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 1].loc.offset = (long)&sf->REG_NAME(RDX) - new_cfa;
+  fs->regs.reg[ 2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 2].loc.offset = (long)&sf->REG_NAME(RCX) - new_cfa;
+  fs->regs.reg[ 3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 3].loc.offset = (long)&sf->REG_NAME(RBX) - new_cfa;
+  fs->regs.reg[ 4].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 4].loc.offset = (long)&sf->REG_NAME(RSI) - new_cfa;
+  fs->regs.reg[ 5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 5].loc.offset = (long)&sf->REG_NAME(RDI) - new_cfa;
+  fs->regs.reg[ 6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 6].loc.offset = (long)&sf->REG_NAME(RBP) - new_cfa;
+  fs->regs.reg[ 8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 8].loc.offset = (long)&sf->REG_NAME(R8)  - new_cfa;
+  fs->regs.reg[ 9].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 9].loc.offset = (long)&sf->REG_NAME(R9)  - new_cfa;
+  fs->regs.reg[10].how = REG_SAVED_OFFSET;
+  fs->regs.reg[10].loc.offset = (long)&sf->REG_NAME(R10) - new_cfa;
+  fs->regs.reg[11].how = REG_SAVED_OFFSET;
+  fs->regs.reg[11].loc.offset = (long)&sf->REG_NAME(R11) - new_cfa;
+  fs->regs.reg[12].how = REG_SAVED_OFFSET;
+  fs->regs.reg[12].loc.offset = (long)&sf->REG_NAME(R12) - new_cfa;
+  fs->regs.reg[13].how = REG_SAVED_OFFSET;
+  fs->regs.reg[13].loc.offset = (long)&sf->REG_NAME(R13) - new_cfa;
+  fs->regs.reg[14].how = REG_SAVED_OFFSET;
+  fs->regs.reg[14].loc.offset = (long)&sf->REG_NAME(R14) - new_cfa;
+  fs->regs.reg[15].how = REG_SAVED_OFFSET;
+  fs->regs.reg[15].loc.offset = (long)&sf->REG_NAME(R15) - new_cfa;
+  fs->regs.reg[16].how = REG_SAVED_OFFSET;
+  fs->regs.reg[16].loc.offset = (long)&sf->REG_NAME(RIP) - new_cfa;
+  fs->retaddr_column = 16;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+
+
+
+
+#else /* Next section is for i386  */
+
+
+
+
+#define MD_FALLBACK_FRAME_STATE_FOR x86_netbsd_fallback_frame_state
+
+static _Unwind_Reason_Code
+x86_netbsd_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  /* signal_frame is sigframe_siginfo minus sf_ra handler return address */
+  struct signal_frame {
+         int          sf_signum;  /* "signum" argument for handler" */
+         siginfo_t   *sf_sip;     /* "sip"    argument for handler" */
+         ucontext_t  *sf_ucp;     /* "ucp"    argument for handler" */
+         siginfo_t    sf_si;      /* actual saved siginfo  */
+         ucontext_t   sf_uc;      /* actual saved ucontext */
+  };
+  struct signal_frame *sf;
+  long new_cfa;
+
+  /*  We are looking for the following signal trampoline pattern. If we don't
+      find it, we are at the end of the stack and can't unwind.
+
+      <__sigtramp_siginfo_2+18>:  movl   $0xffffffff,0x4(%esp)
+      <__sigtramp_siginfo_2+26>:  mov    $0x1,%eax
+      <__sigtramp_siginfo_2+31>:  int    $0x80
+  */
+
+  if (   *(unsigned int   *) (context->ra + 18) == 0x042444c7
+      && *(unsigned int   *) (context->ra + 22) == 0xffffffff
+      && *(unsigned char  *) (context->ra + 26) == 0xb8
+      && *(unsigned int   *) (context->ra + 27) == 0x00000001
+      && *(unsigned short *) (context->ra + 31) == 0x80cd     )
+  {
+    sf = (struct signal_frame *) context->cfa;
+    new_cfa = sf->REG_NAME(ESP);
+    fs->regs.cfa_how = CFA_REG_OFFSET;
+    fs->regs.cfa_reg = 4;
+    fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+  }
+  else
+  {
+    return _URC_END_OF_STACK;
+  }
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(EAX) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(EBX) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(ECX) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(EDX) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(ESI) - new_cfa;
+  fs->regs.reg[7].how = REG_SAVED_OFFSET;
+  fs->regs.reg[7].loc.offset = (long)&sf->REG_NAME(EDI) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(EBP) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(EIP) - new_cfa;
+  fs->retaddr_column = 8;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+
+
+
+
+#endif /* ifdef __x86_64__  */
+
--- libiberty/getpagesize.c.orig
+++ libiberty/getpagesize.c
@@ -20,6 +20,7 @@
 
 */
 
+#ifndef __ANDROID__
 #ifndef VMS
 
 #include "config.h"
@@ -88,3 +89,4 @@
 }
 
 #endif /* VMS */
+#endif /* __ANDROID__ */
--- libiberty/setproctitle.c.orig
+++ libiberty/setproctitle.c
@@ -40,9 +40,11 @@
 void
 setproctitle (const char *name ATTRIBUTE_UNUSED, ...)
 {
+#ifndef __ANDROID__
 #ifdef PR_SET_NAME
   /* On GNU/Linux this sets the top visible "comm", but not
      necessarily the name visible in ps. */
   prctl (PR_SET_NAME, name);
 #endif
+#endif
 }
--- gcc/builtins.c.orig
+++ gcc/builtins.c
@@ -125,9 +125,11 @@
 static rtx expand_builtin_mempcpy (tree, rtx, enum machine_mode);
 static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx,
 					enum machine_mode, int);
+#ifndef NO_UNSAFE_BUILTINS
 static rtx expand_builtin_strcpy (tree, rtx);
 static rtx expand_builtin_strcpy_args (tree, tree, rtx);
 static rtx expand_builtin_stpcpy (tree, rtx, enum machine_mode);
+#endif
 static rtx expand_builtin_strncpy (tree, rtx);
 static rtx builtin_memset_gen_str (void *, HOST_WIDE_INT, enum machine_mode);
 static rtx expand_builtin_memset (tree, rtx, enum machine_mode);
@@ -3370,6 +3372,7 @@
 # define CODE_FOR_movstr CODE_FOR_nothing
 #endif
 
+#ifndef NO_UNSAFE_BUILTINS
 /* Expand into a movstr instruction, if one is available.  Return NULL_RTX if
    we failed, the caller should emit a normal call, otherwise try to
    get the result in TARGET, if convenient.  If ENDP is 0 return the
@@ -3521,6 +3524,7 @@
       return expand_movstr (dst, src, target, /*endp=*/2);
     }
 }
+#endif
 
 /* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)
    bytes from constant string DATA + OFFSET and return it as target
@@ -6140,9 +6144,11 @@
       break;
 
     case BUILT_IN_STRCPY:
+#ifndef NO_UNSAFE_BUILTINS
       target = expand_builtin_strcpy (exp, target);
       if (target)
 	return target;
+#endif
       break;
 
     case BUILT_IN_STRNCPY:
@@ -6152,9 +6158,11 @@
       break;
 
     case BUILT_IN_STPCPY:
+#ifndef NO_UNSAFE_BUILTINS
       target = expand_builtin_stpcpy (exp, target, mode);
       if (target)
 	return target;
+#endif
       break;
 
     case BUILT_IN_MEMCPY:
--- gcc/config.gcc.orig
+++ gcc/config.gcc
@@ -687,6 +687,26 @@
   # need_64bit_hwint=yes # system compiler has this for all arch!
   use_gcc_stdint=wrap
   ;;
+*-*-dragonfly*)
+  gas=yes
+  gnu_ld=yes
+  tmake_file="t-slibgcc"
+  case ${enable_threads} in
+    "" | yes | posix)
+      thread_file='posix'
+      ;;
+    no | gnat | single)
+      # Let these non-posix thread selections fall through if requested
+      ;;
+    *)
+      echo 'Unknown thread configuration for DragonFly BSD'
+      exit 1
+      ;;
+  esac
+  extra_options="$extra_options rpath.opt dragonfly.opt"
+  default_use_cxa_atexit=yes
+  use_gcc_stdint=wrap
+  ;;
 *-*-linux* | frv-*-*linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu | *-*-gnu* | *-*-kopensolaris*-gnu)
   extra_options="$extra_options gnu-user.opt"
   gas=yes
@@ -743,6 +763,7 @@
   target_has_targetcm=yes
   ;;
 *-*-netbsd*)
+  use_gcc_stdint=wrap
   tmake_file="t-slibgcc"
   gas=yes
   gnu_ld=yes
@@ -1352,6 +1373,14 @@
     tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h i386/x86-64.h i386/rdos.h i386/rdos64.h"
     tmake_file="i386/t-i386elf t-svr4"
     ;;
+i[34567]86-*-dragonfly*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h dragonfly.h dragonfly-stdint.h i386/dragonfly.h"
+	tmake_file="${tmake_file} i386/t-crtstuff"
+	;;
+x86_64-*-dragonfly*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h dragonfly.h dragonfly-stdint.h i386/x86-64.h i386/dragonfly.h"
+	tmake_file="${tmake_file} i386/t-crtstuff"
+	;;
 i[34567]86-*-freebsd*)
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h ${fbsd_tm_file} i386/freebsd.h"
 	;;
@@ -1359,12 +1388,14 @@
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h ${fbsd_tm_file} i386/x86-64.h i386/freebsd.h i386/freebsd64.h"
 	;;
 i[34567]86-*-netbsdelf*)
-	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/netbsd-elf.h"
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/netbsd-elf.h netbsd-stdint.h"
 	extra_options="${extra_options} netbsd.opt netbsd-elf.opt"
+	tmake_file="${tmake_file} i386/t-crtstuff"
 	;;
 x86_64-*-netbsd*)
-	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/x86-64.h i386/netbsd64.h"
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/x86-64.h i386/netbsd64.h netbsd-stdint.h"
 	extra_options="${extra_options} netbsd.opt netbsd-elf.opt"
+	tmake_file="${tmake_file} i386/t-crtstuff"
 	;;
 i[34567]86-*-openbsd2.*|i[34567]86-*openbsd3.[0123])
 	tm_file="i386/i386.h i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h openbsd-oldgas.h openbsd.h i386/openbsd.h"
@@ -1375,6 +1406,7 @@
 	use_collect2=yes
 	;;
 i[34567]86-*-openbsd*)
+	tm_defines="${tm_defines} PIE_DEFAULT=1"
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h"
 	tm_file="${tm_file} openbsd.h openbsd-stdint.h openbsd-libpthread.h i386/openbsdelf.h"
 	extra_options="${extra_options} openbsd.opt"
@@ -1382,6 +1414,7 @@
 	gnu_ld=yes
 	;;
 x86_64-*-openbsd*)
+	tm_defines="${tm_defines} PIE_DEFAULT=1"
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h"
 	tm_file="${tm_file} openbsd.h openbsd-stdint.h openbsd-libpthread.h i386/x86-64.h i386/openbsdelf.h"
 	extra_options="${extra_options} openbsd.opt"
@@ -2927,6 +2960,12 @@
     arch_without_sse2=yes
     arch_without_64bit=yes
     ;;
+  i386-*-openbsd*)
+    arch=i486
+    cpu=generic
+    arch_without_sse2=yes
+    arch_without_64bit=yes
+    ;;
   i386-*-*)
     arch=i386
     cpu=i386
@@ -4109,6 +4148,8 @@
 		;;
 	i[34567]86-*-mingw* | x86_64-*-mingw*)
 		;;
+	i[34567]86-*-dragonfly* | x86_64-*-dragonfly*)
+		;;
 	i[34567]86-*-freebsd* | x86_64-*-freebsd*)
 		;;
 	ia64*-*-linux*)
--- gcc/configure.orig
+++ gcc/configure
@@ -27421,6 +27421,20 @@
       gcc_cv_target_dl_iterate_phdr=no
     fi
     ;;
+  *-*-dragonfly* | *-*-freebsd*)
+  if grep dl_iterate_phdr $target_header_dir/sys/link_elf.h > /dev/null 2>&1; then
+      gcc_cv_target_dl_iterate_phdr=yes
+    else
+      gcc_cv_target_dl_iterate_phdr=no
+    fi
+  ;;
+ *-*-netbsd*)
+ if grep dl_iterate_phdr $target_header_dir/link_elf.h > /dev/null 2>&1; then
+     gcc_cv_target_dl_iterate_phdr=yes
+   else
+     gcc_cv_target_dl_iterate_phdr=no
+   fi
+ ;;
 esac
 
 if test x$gcc_cv_target_dl_iterate_phdr = xyes; then
--- gcc/Makefile.in.orig
+++ gcc/Makefile.in
@@ -1152,7 +1152,6 @@
 	insn-emit.o \
 	insn-extract.o \
 	insn-latencytab.o \
-	insn-modes.o \
 	insn-opinit.o \
 	insn-output.o \
 	insn-peep.o \
@@ -1487,13 +1486,18 @@
 ALL_HOST_BACKEND_OBJS = $(GCC_OBJS) $(OBJS) $(OBJS-libcommon) \
   $(OBJS-libcommon-target) @TREEBROWSER@ main.o c-family/cppspec.o \
   $(COLLECT2_OBJS) $(EXTRA_GCC_OBJS) $(GCOV_OBJS) $(GCOV_DUMP_OBJS) \
-  lto-wrapper.o
+  insn-modes.o insn-modes-ada.o lto-wrapper.o
 
 # This lists all host object files, whether they are included in this
 # compilation or not.
 ALL_HOST_OBJS = $(ALL_HOST_FRONTEND_OBJS) $(ALL_HOST_BACKEND_OBJS)
 
 BACKEND = libbackend.a main.o @TREEBROWSER@ libcommon-target.a libcommon.a \
+	insn-modes.o \
+	$(CPPLIB) $(LIBDECNUMBER)
+
+BACKEND2 = libbackend.a main.o @TREEBROWSER@ libcommon-target.a libcommon.a \
+	insn-modes-ada.o \
 	$(CPPLIB) $(LIBDECNUMBER)
 
 # This is defined to "yes" if Tree checking is enabled, which roughly means
@@ -2124,6 +2128,7 @@
 
 insn-modes.c: s-modes; @true
 insn-modes.h: s-modes-h; @true
+insn-modes-ada.c: s-modes-ada; @true
 min-insn-modes.c: s-modes-m; @true
 
 s-modes: build/genmodes$(build_exeext)
@@ -2141,6 +2146,12 @@
 	$(SHELL) $(srcdir)/../move-if-change tmp-min-modes.c min-insn-modes.c
 	$(STAMP) s-modes-m
 
+s-modes-ada: s-modes
+	$(shell sed -e 's/: TARGET_96_ROUND_53_LONG_DOUBLE \? &ieee_extended_intel_96_round_53_format //'  \
+		< insn-modes.c > tmp-modes-ada.c)
+	$(SHELL) $(srcdir)/../move-if-change tmp-modes-ada.c insn-modes-ada.c
+	$(STAMP) s-modes-ada
+
 insn-preds.c: s-preds; @true
 tm-preds.h: s-preds-h; @true
 tm-constrs.h: s-constrs-h; @true
@@ -3217,6 +3228,9 @@
 	  ( cd $(DESTDIR)$(bindir) && \
 	    $(LN) $(GCC_INSTALL_NAME)$(exeext) $(target_noncanonical)-gcc-$(version)$(exeext) ); \
 	fi
+	-if [ -f gnat1$(exeext) ] ; then \
+	  ( cd $(DESTDIR)$(bindir) && $(LN) $(GCC_INSTALL_NAME)$(exeext) ada$(exeext) ) \
+	fi
 	-if [ ! -f gcc-cross$(exeext) ] \
 	    && [ "$(GCC_INSTALL_NAME)" != "$(GCC_TARGET_INSTALL_NAME)" ]; then \
 	  rm -f $(DESTDIR)$(bindir)/$(target_noncanonical)-gcc-tmp$(exeext); \
--- libgcc/config.host.orig
+++ libgcc/config.host
@@ -207,6 +207,11 @@
   tmake_file="$tmake_file t-darwin ${cpu_type}/t-darwin t-libgcc-pic t-slibgcc-darwin"
   extra_parts="crt3.o crttms.o crttme.o"
   ;;
+*-*-dragonfly*)
+  tmake_file="$tmake_file t-crtstuff-pic t-libgcc-pic t-eh-dw2-dip"
+  tmake_file="$tmake_file t-slibgcc t-slibgcc-gld t-slibgcc-elf-ver"
+  extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o"
+  ;;
 *-*-freebsd*)
   # This is the generic ELF configuration of FreeBSD.  Later
   # machine-specific sections may refine and add to this
@@ -238,7 +243,8 @@
   extra_parts="crtbegin.o crtbeginS.o crtend.o crtendS.o"
   ;;
 *-*-netbsd*)
-  tmake_file="$tmake_file t-crtstuff-pic t-libgcc-pic t-slibgcc t-slibgcc-gld t-slibgcc-elf-ver"
+  tmake_file="$tmake_file t-crtstuff-pic t-libgcc-pic t-eh-dw2-dip"
+  tmake_file="$tmake_file t-slibgcc t-slibgcc-gld t-slibgcc-elf-ver"
   # NetBSD 1.7 and later are set up to use GCC's crtstuff for
   # ELF configurations.  We will clear extra_parts in the
   # a.out configurations.
@@ -302,7 +308,10 @@
 esac
 
 case ${host} in
-*-*-darwin* | *-*-freebsd* | *-*-netbsd* | *-*-openbsd* | *-*-solaris2*)
+*-*-dragonfly* | *-*-freebsd* | *-*-netbsd* | *-*-openbsd*)
+  enable_execute_stack=enable-execute-stack-freebsd.c
+  ;;
+*-*-darwin* | *-*-solaris2*)
   enable_execute_stack=enable-execute-stack-mprotect.c
   ;;
 i[34567]86-*-mingw* | x86_64-*-mingw*)
@@ -545,16 +554,29 @@
 x86_64-*-elf*)
 	tmake_file="$tmake_file i386/t-crtstuff t-crtstuff-pic t-libgcc-pic"
 	;;
+i[34567]86-*-dragonfly*)
+	tmake_file="${tmake_file} i386/t-dragonfly i386/t-crtstuff"
+	md_unwind_header=i386/dragonfly-unwind.h
+	;;
+x86_64-*-dragonfly*)
+	tmake_file="${tmake_file} i386/t-dragonfly i386/t-crtstuff"
+	md_unwind_header=i386/dragonfly-unwind.h
+	;;
 i[34567]86-*-freebsd*)
 	tmake_file="${tmake_file} i386/t-freebsd i386/t-crtstuff"
+	md_unwind_header=i386/freebsd-unwind.h
 	;;
 x86_64-*-freebsd*)
 	tmake_file="${tmake_file} i386/t-freebsd i386/t-crtstuff"
+	md_unwind_header=i386/freebsd-unwind.h
 	;;
 i[34567]86-*-netbsdelf*)
+	tmake_file="${tmake_file} i386/t-crtstuff"
+	md_unwind_header=i386/netbsd-unwind.h
 	;;
 x86_64-*-netbsd*)
 	tmake_file="${tmake_file} i386/t-crtstuff"
+	md_unwind_header=i386/netbsd-unwind.h
 	;;
 i[34567]86-*-openbsd2.*|i[34567]86-*openbsd3.[0123])
 	;;
@@ -1262,6 +1284,7 @@
   i[34567]86-*-solaris2* | x86_64-*-solaris2.1[0-9]* | \
   i[34567]86-*-cygwin* | x86_64-*-cygwin* | \
   i[34567]86-*-mingw* | x86_64-*-mingw* | \
+  i[34567]86-*-dragonfly* | x86_64-*-dragonfly* | \
   i[34567]86-*-freebsd* | x86_64-*-freebsd* | \
   i[34567]86-*-openbsd* | x86_64-*-openbsd*)
   	tmake_file="${tmake_file} t-softfp-tf"
--- libcilkrts/runtime/os-unix.c.orig
+++ libcilkrts/runtime/os-unix.c
@@ -56,6 +56,12 @@
     // Uses sysconf(_SC_NPROCESSORS_ONLN) in verbose output
 #elif defined  __FreeBSD__
 // No additional include files
+#elif defined __DragonFly__
+// No additional include files
+#elif defined __NetBSD__
+// No additional include files
+#elif defined __OpenBSD__
+// No additional include files
 #elif defined __CYGWIN__
 // Cygwin on Windows - no additional include files
 #elif defined  __VXWORKS__
@@ -374,7 +380,8 @@
     assert((unsigned)count == count);
 
     return count;
-#elif defined  __FreeBSD__ || defined __CYGWIN__
+#elif defined __FreeBSD__ || defined __CYGWIN__ || defined __DragonFly__ \
+   || defined __NetBSD__ || defined __OpenBSD__
     int ncores = sysconf(_SC_NPROCESSORS_ONLN);
 
     return ncores;
@@ -402,6 +409,12 @@
     // On MacOS, call sched_yield to yield quantum.  I'm not sure why we
     // don't do this on Linux also.
     sched_yield();
+#elif defined(__DragonFly__)
+    sched_yield();
+#elif defined(__NetBSD__)
+    sched_yield();
+#elif defined(__OpenBSD__)
+    sched_yield();
 #elif defined(__MIC__)
     // On MIC, pthread_yield() really trashes things.  Arch's measurements
     // showed that calling _mm_delay_32() (or doing nothing) was a better
--- libitm/configure.tgt.orig
+++ libitm/configure.tgt
@@ -138,6 +138,7 @@
 	;;
 
   *-*-gnu* | *-*-k*bsd*-gnu \
+  | *-*-dragonfly* \
   | *-*-netbsd* | *-*-freebsd* | *-*-openbsd* \
   | *-*-solaris2* | *-*-sysv4* | *-*-hpux11* \
   | *-*-darwin* | *-*-aix*)
