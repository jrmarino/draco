--- gcc/config.gcc.orig
+++ gcc/config.gcc
@@ -529,7 +529,7 @@
   extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o"
   fbsd_major=`echo ${target} | sed -e 's/.*freebsd//g' | sed -e 's/\..*//g'`
   tm_defines="${tm_defines} FBSD_MAJOR=${fbsd_major}"
-  tmake_file="t-slibgcc-elf-ver t-freebsd"
+  tmake_file="t-slibgcc-elf-ver t-libc-ok t-libgcc-pic t-exceptions"
   case ${enable_threads} in
     no)
       fbsd_tm_file="${fbsd_tm_file} freebsd-nthr.h"
@@ -545,6 +545,9 @@
           ;;
       esac
       ;;
+    gnat | single)
+      # Let these non-posix thread selections fall through if requested
+      ;;
     *)
       echo 'Unknown thread configuration for FreeBSD'
       exit 1
@@ -561,6 +564,39 @@
   # need_64bit_hwint=yes # system compiler has this for all arch!
   use_gcc_stdint=wrap
   ;;
+*-*-dragonfly*)
+  gas=yes
+  gnu_ld=yes
+  extra_parts="crtbegin.o crtend.o crtbeginS.o crtendS.o"
+  tmake_file="t-slibgcc-elf-ver t-libc-ok t-libgcc-pic t-exceptions"
+  case ${enable_threads} in
+    "" | yes | posix)
+      thread_file='posix'
+      ;;
+    no | gnat | single)
+      # Let these non-posix thread selections fall through if requested
+      ;;
+    *)
+      echo 'Unknown thread configuration for DragonFly BSD'
+      exit 1
+      ;;
+  esac
+  extra_options="$extra_options rpath.opt dragonfly.opt"
+  default_use_cxa_atexit=yes
+  ;;
+*-android-eabi*)
+  extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
+  gas=yes
+  gnu_ld=yes
+  case ${enable_threads} in
+    "" | yes | posix) thread_file='posix' ;;
+  esac
+  tm_defines="$tm_defines DEFAULT_LIBC=LIBC_BIONIC ANDROID_DEFAULT=1"
+  extra_options="$extra_options linux.opt linux-android.opt"
+  default_use_cxa_atexit=yes
+  use_gcc_tgmath=no
+  use_gcc_stdint=wrap
+  ;;
 *-*-linux* | frv-*-*linux* | *-*-kfreebsd*-gnu | *-*-knetbsd*-gnu | *-*-gnu* | *-*-kopensolaris*-gnu)
   extra_options="$extra_options gnu-user.opt"
   extra_parts="crtbegin.o crtbeginS.o crtbeginT.o crtend.o crtendS.o"
@@ -618,9 +654,11 @@
   esac
   ;;
 *-*-netbsd*)
-  tmake_file="t-slibgcc-elf-ver t-libc-ok t-netbsd t-libgcc-pic"
+  tmake_file="t-slibgcc-elf-ver t-libc-ok t-libgcc-pic t-exceptions"
   gas=yes
   gnu_ld=yes
+  nbsd_major=`echo ${target} | sed -e 's/.*netbsd\(elf\)\{0,1\}//g' | sed -e 's/\..*//g'`
+  tm_defines="${tm_defines} NBSD_MAJOR=${nbsd_major}"
 
   # NetBSD 2.0 and later get POSIX threads enabled by default.
   # Allow them to be explicitly enabled on any other version.
@@ -657,12 +695,22 @@
   esac
   ;;
 *-*-openbsd*)
+  gas=yes
+  gnu_ld=yes
+  # Do NOT add crt*.o extra parts!
   tmake_file="t-libc-ok t-openbsd t-libgcc-pic"
   case ${enable_threads} in
-    yes)
+    "" | yes | posix)
       thread_file='posix'
       tmake_file="${tmake_file} t-openbsd-thread"
       ;;
+    no | gnat | single)
+      # Let these non-posix thread selections fall through
+      ;;
+    *)
+      echo 'Unknown thread configuration for OpenBSD'
+      exit 1
+      ;;
   esac
   case ${target} in
     *-*-openbsd2.*|*-*-openbsd3.[012])
@@ -793,6 +841,24 @@
 	tm_file="dbxelf.h elfos.h newlib-stdint.h ${tm_file}"
 	extra_parts="crtinit.o crtfini.o"
 	;;
+arm*-android-eabi*)
+	case $target in
+	arm*b-*)
+		tm_defines="${tm_defines} TARGET_BIG_ENDIAN_DEFAULT=1"
+		;;
+	esac
+	tm_file="dbxelf.h elfos.h gnu-user.h linux.h linux-android.h glibc-stdint.h"
+	tm_file="$tm_file arm/elf.h arm/linux-gas.h arm/linux-elf.h arm/bpabi.h arm/linux-eabi.h"
+	tm_file="$tm_file ../../libgcc/config/arm/bpabi-lib.h arm/aout.h arm/arm.h"
+
+	tmake_file="t-slibgcc-elf-ver t-linux arm/t-arm"
+	tmake_file="$tmake_file arm/t-arm-elf arm/t-bpabi arm/t-linux-eabi t-slibgcc-libgcc"
+	tmake_file="$tmake_file arm/t-linux-androideabi arm/t-arm-softfp soft-fp/t-softfp"
+
+	# The BPABI long long divmod functions return a 128-bit value in registers r0-r3.
+	# Correctly modeling that requires the use of TImode.
+	need_64bit_hwint=yes
+	;;
 arm-wrs-vxworks)
 	tm_file="elfos.h arm/elf.h arm/aout.h ${tm_file} vx-common.h vxworks.h arm/vxworks.h"
 	extra_options="${extra_options} arm/vxworks.opt"
@@ -1219,9 +1285,18 @@
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h ${fbsd_tm_file} i386/x86-64.h i386/freebsd.h i386/freebsd64.h"
 	tmake_file="${tmake_file} i386/t-crtstuff"
 	;;
+i[34567]86-*-dragonfly*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h dragonfly.h dragonfly-stdint.h i386/dragonfly.h"
+	tmake_file="${tmake_file} i386/t-crtstuff"
+	;;
+x86_64-*-dragonfly*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h dragonfly.h dragonfly-stdint.h i386/x86-64.h i386/dragonfly.h i386/dragonfly64.h"
+	tmake_file="${tmake_file} i386/t-crtstuff"
+	;;
 i[34567]86-*-netbsdelf*)
-	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/netbsd-elf.h"
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/netbsd-elf.h netbsd-stdint.h"
 	extra_options="${extra_options} netbsd.opt netbsd-elf.opt"
+	tmake_file="${tmake_file} i386/t-crtstuff"
 	;;
 i[34567]86-*-netbsd*)
 	tm_file="${tm_file} i386/unix.h i386/bsd.h i386/gas.h i386/gstabs.h netbsd.h netbsd-aout.h i386/netbsd.h"
@@ -1231,7 +1306,7 @@
 	use_collect2=yes
 	;;
 x86_64-*-netbsd*)
-	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/x86-64.h i386/netbsd64.h"
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h netbsd.h netbsd-elf.h i386/x86-64.h i386/netbsd64.h netbsd-stdint.h"
 	extra_options="${extra_options} netbsd.opt netbsd-elf.opt"
 	tmake_file="${tmake_file} i386/t-crtstuff"
 	;;
@@ -1247,8 +1322,12 @@
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h"
 	tm_file="${tm_file} openbsd.h openbsd-stdint.h openbsd-libpthread.h i386/openbsdelf.h"
 	extra_options="${extra_options} openbsd.opt"
-	gas=yes
-	gnu_ld=yes
+	;;
+x86_64-*-openbsd*)
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h"
+	tm_file="${tm_file} openbsd.h openbsd-libpthread.h i386/x86-64.h i386/openbsd64.h exec-stack.h"
+	extra_options="${extra_options} openbsd.opt"
+	tmake_file="${tmake_file} i386/t-crtstuff"
 	;;
 i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | i[34567]86-*-gnu* | i[34567]86-*-kopensolaris*-gnu)
 			# Intel 80386's running GNU/*
@@ -3673,6 +3752,11 @@
 	i[34567]86-*-freebsd* | x86_64-*-freebsd*)
 		tmake_file="${tmake_file} i386/t-fprules-softfp soft-fp/t-softfp"
 		;;
+	i[34567]86-*-dragonfly* | x86_64-*-dragonfly*)
+		tmake_file="${tmake_file} i386/t-fprules-softfp soft-fp/t-softfp"
+		;;
+	i[34567]86-*-openbsd* | x86_64-*-openbsd*)
+		;;
 	ia64*-*-linux*)
 		tmake_file="${tmake_file} ia64/t-fprules-softfp soft-fp/t-softfp"
 		;;
--- gcc/crtstuff.c.orig
+++ gcc/crtstuff.c
@@ -79,11 +79,19 @@
 }
 #endif
 
+#if defined(TARGET_DL_ITERATE_PHDR) && \
+   ( defined(__FreeBSD__)              \
+  || defined(__OpenBSD__)              \
+  || defined(__NetBSD__)               \
+  || defined(__DragonFly__))
+#define BSD_DL_ITERATE_PHDR_AVAILABLE
+#endif
+
 #if defined(OBJECT_FORMAT_ELF) \
     && !defined(OBJECT_FORMAT_FLAT) \
     && defined(HAVE_LD_EH_FRAME_HDR) \
     && !defined(inhibit_libc) && !defined(CRTSTUFFT_O) \
-    && defined(__FreeBSD__) && __FreeBSD__ >= 7
+    && defined(BSD_DL_ITERATE_PHDR_AVAILABLE)
 #include <link.h>
 # define USE_PT_GNU_EH_FRAME
 #endif
--- gcc/DEV-PHASE.orig
+++ gcc/DEV-PHASE
@@ -0,0 +1 @@
+release
--- gcc/unwind-dw2-fde-glibc.c.orig
+++ gcc/unwind-dw2-fde-glibc.c
@@ -53,13 +53,21 @@
 #endif
 
 #if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
-    && defined(__FreeBSD__) && __FreeBSD__ >= 7
+    && defined(TARGET_DL_ITERATE_PHDR) \
+    && (defined(__FreeBSD__) || defined(__DragonFly__))
 # define ElfW __ElfN
 # define USE_PT_GNU_EH_FRAME
 #endif
 
 #if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
     && defined(TARGET_DL_ITERATE_PHDR) \
+    && (defined(__OpenBSD__) || defined(__NetBSD__))
+# define ElfW(n) Elf_##n
+# define USE_PT_GNU_EH_FRAME
+#endif
+
+#if !defined(inhibit_libc) && defined(HAVE_LD_EH_FRAME_HDR) \
+    && defined(TARGET_DL_ITERATE_PHDR) \
     && defined(__sun__) && defined(__svr4__)
 # define USE_PT_GNU_EH_FRAME
 #endif
--- /dev/null
+++ gcc/config/dragonfly-stdint.h
@@ -0,0 +1,56 @@
+/* Definitions for <stdint.h> types for DragonFly systems.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   Contributed by Gerald Pfeifer <gerald@pfeifer.com>.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#define SIG_ATOMIC_TYPE   "int"
+
+#define INT8_TYPE         "signed char"
+#define INT16_TYPE        "short int"
+#define INT32_TYPE        "int"
+#define INT64_TYPE        (LONG_TYPE_SIZE == 64 ? "long int" : "long long int")
+#define UINT8_TYPE        "unsigned char"
+#define UINT16_TYPE       "short unsigned int"
+#define UINT32_TYPE       "unsigned int"
+#define UINT64_TYPE       (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "long long unsigned int")
+
+#define INT_LEAST8_TYPE   INT8_TYPE
+#define INT_LEAST16_TYPE  INT16_TYPE
+#define INT_LEAST32_TYPE  INT32_TYPE
+#define INT_LEAST64_TYPE  INT64_TYPE
+#define UINT_LEAST8_TYPE  UINT8_TYPE
+#define UINT_LEAST16_TYPE UINT16_TYPE
+#define UINT_LEAST32_TYPE UINT32_TYPE
+#define UINT_LEAST64_TYPE UINT64_TYPE
+
+#define INT_FAST8_TYPE    INT32_TYPE
+#define INT_FAST16_TYPE   INT32_TYPE
+#define INT_FAST32_TYPE   INT32_TYPE
+#define INT_FAST64_TYPE   INT64_TYPE
+#define UINT_FAST8_TYPE   UINT32_TYPE
+#define UINT_FAST16_TYPE  UINT32_TYPE
+#define UINT_FAST32_TYPE  UINT32_TYPE
+#define UINT_FAST64_TYPE  UINT64_TYPE
+
+#define INTPTR_TYPE       (LONG_TYPE_SIZE == 64 ?  INT64_TYPE :  INT32_TYPE)
+#define UINTPTR_TYPE      (LONG_TYPE_SIZE == 64 ? UINT64_TYPE : UINT32_TYPE)
--- /dev/null
+++ gcc/config/dragonfly.h
@@ -0,0 +1,139 @@
+/* Base configuration file for all DragonFly targets.
+   Copyright (C) 1999, 2000, 2001, 2007, 2008 Free Software Foundation, Inc.
+   Copyright (C) 2010-2012 John R. Marino <www.dragonlace.net>
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* Common DragonFly configuration.
+   All DragonFly architectures should include this file, which will specify
+   their commonalities.
+
+   Adapted from gcc/config/freebsd.h by
+   Joerg Sonnenberger <joerg@bec.de>
+
+   Adapted from gcc/config/i386/freebsd-elf.h by
+   David O'Brien <obrien@FreeBSD.org>.
+   Further work by David O'Brien <obrien@FreeBSD.org> and
+   Loren J. Rittle <ljrittle@acm.org>.  */
+
+/* JRM: 15 Nov 2010
+   SWITCH_TAKES_ARG & WORD_SWITCH_TAKES_ARG removed due to poisoning.
+   http://gcc.gnu.org/ml/gcc-patches/2010-10/msg02102.html
+   http://gcc.gnu.org/ml/gcc-patches/2010-10/msg02373.html */
+   
+#undef  TARGET_OS_CPP_BUILTINS
+#define TARGET_OS_CPP_BUILTINS()            \
+  do                                        \
+    {                                       \
+       builtin_define_std ("unix");         \
+       builtin_define ("__DragonFly__");    \
+       builtin_assert ("system=unix");      \
+       builtin_assert ("system=bsd");       \
+       builtin_assert ("system=DragonFly"); \
+    }                                       \
+  while (0)
+
+#undef  CPP_SPEC
+#define CPP_SPEC \
+ "%(cpp_cpu) %(cpp_arch) %{posix:-D_POSIX_SOURCE}"
+
+#undef  STARTFILE_SPEC
+#define STARTFILE_SPEC	\
+  "%{!shared: \
+     %{pg:gcrt1.o%s} \
+     %{!pg: \
+       %{p:gcrt1.o%s} \
+       %{!p: \
+         %{profile: gcrt1.o%s} \
+         %{!profile: \
+           %{pie: Scrt1.o%s;:crt1.o%s}}}}} \
+   crti.o%s \
+   %{shared|pie:crtbeginS.o%s;:crtbegin.o%s}"
+
+#undef  ENDFILE_SPEC
+#define ENDFILE_SPEC \
+  "%{shared|pie:crtendS.o%s;:crtend.o%s} crtn.o%s"
+
+#undef  LIB_SPEC
+#define LIB_SPEC \
+  "%{pthread:-lpthread} -lc"
+
+/* Provide a LINK_SPEC appropriate for DragonFly.  Here we provide support
+   for the special GCC options -static and -shared, which allow us to
+   link things in one of these three modes by applying the appropriate
+   combinations of options at link-time.
+
+   When the -shared link option is used a final link is not being
+   done.  */
+
+#define DFBSD_LINK_SPEC \
+ "%{p:%nconsider using '-pg' instead of '-p' with gprof(1)} \
+  %{v:-V} \
+  %{assert*} %{R*} %{rpath*} %{defsym*} \
+  %{shared:-Bshareable %{h*} %{soname*}} \
+    %{!shared: \
+      %{!static: \
+        %{rdynamic:-export-dynamic} \
+        -dynamic-linker %(dfbsd_dynamic_linker) } \
+    %{static:-Bstatic}} \
+  %{symbolic:-Bsymbolic}"
+
+#undef  LINK_SPEC
+#define LINK_SPEC DFBSD_LINK_SPEC
+
+#define	DFBSD_DYNAMIC_LINKER "/usr/libexec/ld-elf.so.2"
+
+#if defined(HAVE_LD_EH_FRAME_HDR)
+#define LINK_EH_SPEC "--eh-frame-hdr"
+#endif
+
+/* Use --as-needed -lgcc_s for eh support.  */
+#ifdef HAVE_LD_AS_NEEDED
+#define USE_LD_AS_NEEDED 1
+#endif
+
+/************************[  Target stuff  ]***********************************/
+
+/* All DragonFly Architectures support the ELF object file format.  */
+#undef  OBJECT_FORMAT_ELF
+#define OBJECT_FORMAT_ELF
+
+/* Don't assume anything about the header files.  */
+#undef  NO_IMPLICIT_EXTERN_C
+#define NO_IMPLICIT_EXTERN_C	1
+
+/* Follow DragonFly's standard headers (<machine/stdint.h>, etc...).  */
+
+#undef  WCHAR_TYPE
+#define WCHAR_TYPE "int"
+
+#undef  WINT_TYPE
+#define WINT_TYPE "int"
+
+#define MATH_LIBRARY_PROFILE    "m_p"
+
+/* Code generation parameters.  */
+
+/* Use periods rather than dollar signs in special g++ assembler names.
+   This ensures the configuration knows our system correctly so we can link
+   with libraries compiled with the native cc.  */
+#undef NO_DOLLAR_IN_LABEL
+
+/* Used by libgcc2.c.  We support file locking with fcntl / F_SETLKW.
+   This enables the test coverage code to use file locking when exiting a
+   program, which avoids race conditions if the program has forked.  */
+#define TARGET_POSIX_IO
--- /dev/null
+++ gcc/config/dragonfly.opt
@@ -0,0 +1,59 @@
+; DragonFlyBSD options.
+
+; Copyright (C) 2010
+; Free Software Foundation, Inc.
+;
+; This file is part of GCC.
+;
+; GCC is free software; you can redistribute it and/or modify it under
+; the terms of the GNU General Public License as published by the Free
+; Software Foundation; either version 3, or (at your option) any later
+; version.
+;
+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+; WARRANTY; without even the implied warranty of MERCHANTABILITY or
+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+; for more details.
+;
+; You should have received a copy of the GNU General Public License
+; along with GCC; see the file COPYING3.  If not see
+; <http://www.gnu.org/licenses/>.
+
+; See the GCC internals manual (options.texi) for a description of this file's format.
+
+; Please try to keep this file in ASCII collating order.
+
+assert
+Driver Separate
+
+assert=
+Driver JoinedOrMissing
+
+defsym
+Driver Separate
+
+defsym=
+Driver JoinedOrMissing
+
+profile
+Driver
+
+pthread
+Driver
+
+rpath-link
+Driver Separate
+
+rpath-link=
+Driver JoinedOrMissing
+
+rpath=
+Driver JoinedOrMissing
+
+soname
+Driver Separate
+
+soname=
+Driver JoinedOrMissing
+
+; This comment is to ensure we retain the blank line above.
--- /dev/null
+++ gcc/config/exec-stack.h
@@ -0,0 +1,41 @@
+/* Enable stack execute around trampoline address.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+
+This file is part of GNU CC.
+
+GNU CC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU CC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU CC; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+#undef FINALIZE_TRAMPOLINE
+#define FINALIZE_TRAMPOLINE(TRAMP) \
+  emit_library_call(gen_rtx_SYMBOL_REF (Pmode, "__enable_execute_stack"), \
+		    0, VOIDmode, 1, memory_address (SImode, (TRAMP)), Pmode)
+
+#undef TRANSFER_FROM_TRAMPOLINE
+#define TRANSFER_FROM_TRAMPOLINE					\
+extern void __enable_execute_stack (void *);				\
+void									\
+__enable_execute_stack (addr)						\
+     void *addr;							\
+{									\
+  long size = getpagesize ();						\
+  long mask = ~(size-1);						\
+  char *page = (char *) (((long) addr) & mask); 			\
+  char *end  = (char *) ((((long) (addr + TRAMPOLINE_SIZE)) & mask) + size); \
+								      \
+  if (mprotect (page, end - page, PROT_READ | PROT_WRITE | PROT_EXEC) < 0) \
+    perror ("mprotect of trampoline code");				\
+}
+
--- /dev/null
+++ gcc/config/netbsd-stdint.h
@@ -0,0 +1,56 @@
+/* Definitions for <stdint.h> types for NetBSD systems.
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   Contributed by Gerald Pfeifer <gerald@pfeifer.com>.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#define SIG_ATOMIC_TYPE   "int"
+
+#define INT8_TYPE         "signed char"
+#define INT16_TYPE        "short int"
+#define INT32_TYPE        "int"
+#define INT64_TYPE        (LONG_TYPE_SIZE == 64 ? "long int" : "long long int")
+#define UINT8_TYPE        "unsigned char"
+#define UINT16_TYPE       "short unsigned int"
+#define UINT32_TYPE       "unsigned int"
+#define UINT64_TYPE       (LONG_TYPE_SIZE == 64 ? "long unsigned int" : "long long unsigned int")
+
+#define INT_LEAST8_TYPE   INT8_TYPE
+#define INT_LEAST16_TYPE  INT16_TYPE
+#define INT_LEAST32_TYPE  INT32_TYPE
+#define INT_LEAST64_TYPE  INT64_TYPE
+#define UINT_LEAST8_TYPE  UINT8_TYPE
+#define UINT_LEAST16_TYPE UINT16_TYPE
+#define UINT_LEAST32_TYPE UINT32_TYPE
+#define UINT_LEAST64_TYPE UINT64_TYPE
+
+#define INT_FAST8_TYPE    INT32_TYPE
+#define INT_FAST16_TYPE   INT32_TYPE
+#define INT_FAST32_TYPE   INT32_TYPE
+#define INT_FAST64_TYPE   INT64_TYPE
+#define UINT_FAST8_TYPE   UINT32_TYPE
+#define UINT_FAST16_TYPE  UINT32_TYPE
+#define UINT_FAST32_TYPE  UINT32_TYPE
+#define UINT_FAST64_TYPE  UINT64_TYPE
+
+#define INTPTR_TYPE       (LONG_TYPE_SIZE == 64 ?  INT64_TYPE :  INT32_TYPE)
+#define UINTPTR_TYPE      (LONG_TYPE_SIZE == 64 ? UINT64_TYPE : UINT32_TYPE)
--- gcc/config/netbsd.h.orig
+++ gcc/config/netbsd.h
@@ -22,7 +22,7 @@
 #define NETBSD_OS_CPP_BUILTINS_COMMON()		\
   do						\
     {						\
-      builtin_define ("__NetBSD__");		\
+      builtin_define_with_int_value ("__NetBSD__", NBSD_MAJOR);	\
       builtin_define ("__unix__");		\
       builtin_assert ("system=bsd");		\
       builtin_assert ("system=unix");		\
--- /dev/null
+++ gcc/config/t-exceptions
@@ -0,0 +1,7 @@
+# Use unwind-dw2-fde-glibc
+# Required to utilize dl_iterate_phdr functionality
+
+LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde-glibc.c \
+  $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c
+LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h unwind-dw2-fde.c
+
--- gcc/config/t-openbsd-thread.orig
+++ gcc/config/t-openbsd-thread
@@ -1,3 +1,3 @@
 # This is currently needed to compile libgcc2 for threads support
-TARGET_LIBGCC2_CFLAGS=-pthread
+TARGET_LIBGCC2_CFLAGS += -pthread
 
--- /dev/null
+++ gcc/config/i386/dragonfly-unwind.h
@@ -0,0 +1,158 @@
+/* DWARF2 EH unwinding support for DragonFly BSD: AMD x86-64 and x86.
+   Copyright (C) 2010 John Marino <draco@marino.st> */
+
+/* Do code reading to identify a signal frame, and set the frame
+   state data appropriately.  See unwind-dw2.c for the structs. */
+
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <signal.h>
+#include <sys/ucontext.h>
+#include <machine/sigframe.h>
+
+
+#define REG_NAME(reg)	sf_uc.uc_mcontext.mc_## reg
+
+#ifdef __x86_64__
+#define MD_FALLBACK_FRAME_STATE_FOR x86_64_dragonfly_fallback_frame_state
+
+
+static void
+x86_64_sigtramp_range (unsigned char **start, unsigned char **end)
+{
+  unsigned long ps_strings;
+  int mib[2];
+  size_t len;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PS_STRINGS;
+  len = sizeof (ps_strings);
+  sysctl (mib, 2, &ps_strings, &len, NULL, 0);
+
+  *start = (unsigned char *)ps_strings - 32;
+  *end   = (unsigned char *)ps_strings;
+}
+
+
+static _Unwind_Reason_Code
+x86_64_dragonfly_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  unsigned char *pc = context->ra;
+  unsigned char *sigtramp_start, *sigtramp_end;
+  struct sigframe *sf;
+  long new_cfa;
+
+  x86_64_sigtramp_range(&sigtramp_start, &sigtramp_end);
+  if (pc >= sigtramp_end || pc < sigtramp_start)
+    return _URC_END_OF_STACK;
+
+  sf = (struct sigframe *) context->cfa;
+  new_cfa = sf->REG_NAME(rsp);
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  /* Register 7 is rsp  */
+  fs->regs.cfa_reg = 7;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(rax) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(rdx) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(rcx) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(rbx) - new_cfa;
+  fs->regs.reg[4].how = REG_SAVED_OFFSET;
+  fs->regs.reg[4].loc.offset = (long)&sf->REG_NAME(rsi) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(rdi) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(rbp) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(r8) - new_cfa;
+  fs->regs.reg[9].how = REG_SAVED_OFFSET;
+  fs->regs.reg[9].loc.offset = (long)&sf->REG_NAME(r9) - new_cfa;
+  fs->regs.reg[10].how = REG_SAVED_OFFSET;
+  fs->regs.reg[10].loc.offset = (long)&sf->REG_NAME(r10) - new_cfa;
+  fs->regs.reg[11].how = REG_SAVED_OFFSET;
+  fs->regs.reg[11].loc.offset = (long)&sf->REG_NAME(r11) - new_cfa;
+  fs->regs.reg[12].how = REG_SAVED_OFFSET;
+  fs->regs.reg[12].loc.offset = (long)&sf->REG_NAME(r12) - new_cfa;
+  fs->regs.reg[13].how = REG_SAVED_OFFSET;
+  fs->regs.reg[13].loc.offset = (long)&sf->REG_NAME(r13) - new_cfa;
+  fs->regs.reg[14].how = REG_SAVED_OFFSET;
+  fs->regs.reg[14].loc.offset = (long)&sf->REG_NAME(r14) - new_cfa;
+  fs->regs.reg[15].how = REG_SAVED_OFFSET;
+  fs->regs.reg[15].loc.offset = (long)&sf->REG_NAME(r15) - new_cfa;
+  fs->regs.reg[16].how = REG_SAVED_OFFSET;
+  fs->regs.reg[16].loc.offset = (long)&sf->REG_NAME(rip) - new_cfa;
+  fs->retaddr_column = 16;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+
+#else /* Next section is for i386  */
+
+#define MD_FALLBACK_FRAME_STATE_FOR x86_dragonfly_fallback_frame_state
+
+
+static void
+x86_sigtramp_range (unsigned char **start, unsigned char **end)
+{
+  unsigned long ps_strings;
+  int mib[2];
+  size_t len;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PS_STRINGS;
+  len = sizeof (ps_strings);
+  sysctl (mib, 2, &ps_strings, &len, NULL, 0);
+
+  *start = (unsigned char *)ps_strings - 128;
+  *end   = (unsigned char *)ps_strings;
+}
+
+
+static _Unwind_Reason_Code
+x86_dragonfly_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  unsigned char *pc = context->ra;
+  unsigned char *sigtramp_start, *sigtramp_end;
+  struct sigframe *sf;
+  long new_cfa;
+
+  x86_sigtramp_range(&sigtramp_start, &sigtramp_end);
+
+  if (pc >= sigtramp_end || pc < sigtramp_start)
+    return _URC_END_OF_STACK;
+
+  sf = (struct sigframe *) context->cfa;
+  new_cfa = sf->REG_NAME(esp);
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  fs->regs.cfa_reg = 4;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(eax) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(ebx) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(ecx) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(edx) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(esi) - new_cfa;
+  fs->regs.reg[7].how = REG_SAVED_OFFSET;
+  fs->regs.reg[7].loc.offset = (long)&sf->REG_NAME(edi) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(ebp) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(eip) - new_cfa;
+  fs->retaddr_column = 8;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+#endif /* ifdef __x86_64__  */
--- /dev/null
+++ gcc/config/i386/dragonfly.h
@@ -0,0 +1,107 @@
+/* Definitions for Intel 386 running DragonFly with ELF format
+   Copyright (C) 1996, 2000, 2002, 2004, 2007 Free Software Foundation, Inc.
+   Contributed by Eric Youngdale.
+   Modified for stabs-in-ELF by H.J. Lu.
+   Adapted from GNU/Linux version by John Polstra.
+   Continued development by David O'Brien <obrien@freebsd.org>
+   Copyright (C) 2010, 2011 John Marino <www.dragonlace.net>
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3, or (at your option)
+any later version.
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+
+#define TARGET_VERSION fprintf (stderr, " (i386 DragonFly/ELF)");
+
+/* Override the default comment-starter of "/".  */
+#undef  ASM_COMMENT_START
+#define ASM_COMMENT_START "#"
+
+#undef  ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+#undef  ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+#undef  DBX_REGISTER_NUMBER
+#define DBX_REGISTER_NUMBER(n) \
+  (TARGET_64BIT ? dbx64_register_map[n] : svr4_dbx_register_map[n])
+
+#undef  NO_PROFILE_COUNTERS
+#define NO_PROFILE_COUNTERS	1
+
+/* Tell final.c that we don't need a label passed to mcount.  */
+
+#undef  MCOUNT_NAME
+#define MCOUNT_NAME ".mcount"
+
+/* Make gcc agree with <machine/ansi.h>.  */
+
+#undef  SIZE_TYPE
+#define SIZE_TYPE	(TARGET_64BIT ? "long unsigned int" : "unsigned int")
+
+#undef  PTRDIFF_TYPE
+#define PTRDIFF_TYPE	(TARGET_64BIT ? "long int" : "int")
+
+#undef  WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE	(TARGET_64BIT ? 32 : BITS_PER_WORD)
+
+#undef  SUBTARGET_EXTRA_SPECS	/* i386.h bogusly defines it.  */
+#define SUBTARGET_EXTRA_SPECS \
+  { "dfbsd_dynamic_linker", DFBSD_DYNAMIC_LINKER }
+
+
+/* A C statement to output to the stdio stream FILE an assembler
+   command to advance the location counter to a multiple of 1<<LOG
+   bytes if it is within MAX_SKIP bytes.
+
+   This is used to align code labels according to Intel recommendations.  */
+
+#ifdef HAVE_GAS_MAX_SKIP_P2ALIGN
+#undef  ASM_OUTPUT_MAX_SKIP_ALIGN
+#define ASM_OUTPUT_MAX_SKIP_ALIGN(FILE, LOG, MAX_SKIP)					\
+  if ((LOG) != 0) {														\
+    if ((MAX_SKIP) == 0) fprintf ((FILE), "\t.p2align %d\n", (LOG));	\
+    else fprintf ((FILE), "\t.p2align %d,,%d\n", (LOG), (MAX_SKIP));	\
+  }
+#endif
+
+/* Don't default to pcc-struct-return, we want to retain compatibility with
+   older gcc versions AND pcc-struct-return is nonreentrant.
+   (even though the SVR4 ABI for the i386 says that records and unions are
+   returned in memory).  */
+
+#undef  DEFAULT_PCC_STRUCT_RETURN
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* DragonFly sets the rounding precision of the FPU to 53 bits, but GNAT
+   resets it to full precision.  */
+#undef TARGET_96_ROUND_53_LONG_DOUBLE
+#define TARGET_96_ROUND_53_LONG_DOUBLE 0
+
+/* Put all *tf routines in libgcc.  */
+#undef LIBGCC2_HAS_TF_MODE
+#define LIBGCC2_HAS_TF_MODE 1
+#define LIBGCC2_TF_CEXT q
+#define TF_SIZE 113
+
+/* Define this to be nonzero if static stack checking is supported. */
+#define STACK_CHECK_STATIC_BUILTIN 1
+
+/* Support for i386 has been removed from DragonFly for several releases  */
+#define SUBTARGET32_DEFAULT_CPU "i486"
+
+/* Define location of OS-specific unwind support configuration. */
+#define MD_UNWIND_SUPPORT "config/i386/dragonfly-unwind.h"
--- /dev/null
+++ gcc/config/i386/dragonfly64.h
@@ -0,0 +1,5 @@
+/* Definitions for AMD x86_64 running DragonFly BSD with ELF Format */
+
+#undef  TARGET_VERSION
+#define TARGET_VERSION fprintf (stderr, " (x86-64 DragonFly/ELF)");
+
--- /dev/null
+++ gcc/config/i386/freebsd-unwind.h
@@ -0,0 +1,184 @@
+/* DWARF2 EH unwinding support for FreeBSD: AMD x86-64 and x86.
+   Copyright (C) 2004, 2005, 2006 Free Software Foundation, Inc.
+   Copyright (C) 2010 John Marino <draco@marino.st>
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file with other programs, and to distribute
+those programs without any restriction coming from the use of this
+file.  (The General Public License restrictions do apply in other
+respects; for example, they cover modification of the file, and
+distribution when not linked into another program.)
+
+GCC is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING.  If not, write to
+the Free Software Foundation, 51 Franklin Street, Fifth Floor,
+Boston, MA 02110-1301, USA.  */
+
+/* Do code reading to identify a signal frame, and set the frame
+   state data appropriately.  See unwind-dw2.c for the structs. */
+
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <signal.h>
+#include <sys/ucontext.h>
+#include <machine/sigframe.h>
+
+
+#define REG_NAME(reg)	sf_uc.uc_mcontext.mc_## reg
+
+#ifdef __x86_64__
+#define MD_FALLBACK_FRAME_STATE_FOR x86_64_freebsd_fallback_frame_state
+
+
+static void
+x86_64_sigtramp_range (unsigned char **start, unsigned char **end)
+{
+  unsigned long ps_strings;
+  int mib[2];
+  size_t len;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PS_STRINGS;
+  len = sizeof (ps_strings);
+  sysctl (mib, 2, &ps_strings, &len, NULL, 0);
+
+  *start = (unsigned char *)ps_strings - 32;
+  *end   = (unsigned char *)ps_strings;
+}
+
+
+static _Unwind_Reason_Code
+x86_64_freebsd_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  unsigned char *pc = context->ra;
+  unsigned char *sigtramp_start, *sigtramp_end;
+  struct sigframe *sf;
+  long new_cfa;
+
+  x86_64_sigtramp_range(&sigtramp_start, &sigtramp_end);
+  if (pc >= sigtramp_end || pc < sigtramp_start)
+    return _URC_END_OF_STACK;
+
+  sf = (struct sigframe *) context->cfa;
+  new_cfa = sf->REG_NAME(rsp);
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  /* Register 7 is rsp  */
+  fs->regs.cfa_reg = 7;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(rax) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(rdx) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(rcx) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(rbx) - new_cfa;
+  fs->regs.reg[4].how = REG_SAVED_OFFSET;
+  fs->regs.reg[4].loc.offset = (long)&sf->REG_NAME(rsi) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(rdi) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(rbp) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(r8) - new_cfa;
+  fs->regs.reg[9].how = REG_SAVED_OFFSET;
+  fs->regs.reg[9].loc.offset = (long)&sf->REG_NAME(r9) - new_cfa;
+  fs->regs.reg[10].how = REG_SAVED_OFFSET;
+  fs->regs.reg[10].loc.offset = (long)&sf->REG_NAME(r10) - new_cfa;
+  fs->regs.reg[11].how = REG_SAVED_OFFSET;
+  fs->regs.reg[11].loc.offset = (long)&sf->REG_NAME(r11) - new_cfa;
+  fs->regs.reg[12].how = REG_SAVED_OFFSET;
+  fs->regs.reg[12].loc.offset = (long)&sf->REG_NAME(r12) - new_cfa;
+  fs->regs.reg[13].how = REG_SAVED_OFFSET;
+  fs->regs.reg[13].loc.offset = (long)&sf->REG_NAME(r13) - new_cfa;
+  fs->regs.reg[14].how = REG_SAVED_OFFSET;
+  fs->regs.reg[14].loc.offset = (long)&sf->REG_NAME(r14) - new_cfa;
+  fs->regs.reg[15].how = REG_SAVED_OFFSET;
+  fs->regs.reg[15].loc.offset = (long)&sf->REG_NAME(r15) - new_cfa;
+  fs->regs.reg[16].how = REG_SAVED_OFFSET;
+  fs->regs.reg[16].loc.offset = (long)&sf->REG_NAME(rip) - new_cfa;
+  fs->retaddr_column = 16;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+
+#else /* Next section is for i386  */
+
+#define MD_FALLBACK_FRAME_STATE_FOR x86_freebsd_fallback_frame_state
+
+
+static void
+x86_sigtramp_range (unsigned char **start, unsigned char **end)
+{
+  unsigned long ps_strings;
+  int mib[2];
+  size_t len;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PS_STRINGS;
+  len = sizeof (ps_strings);
+  sysctl (mib, 2, &ps_strings, &len, NULL, 0);
+
+  *start = (unsigned char *)ps_strings - 128;
+  *end   = (unsigned char *)ps_strings;
+}
+
+
+static _Unwind_Reason_Code
+x86_freebsd_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  unsigned char *pc = context->ra;
+  unsigned char *sigtramp_start, *sigtramp_end;
+  struct sigframe *sf;
+  long new_cfa;
+
+  x86_sigtramp_range(&sigtramp_start, &sigtramp_end);
+
+  if (pc >= sigtramp_end || pc < sigtramp_start)
+    return _URC_END_OF_STACK;
+
+  sf = (struct sigframe *) context->cfa;
+  new_cfa = sf->REG_NAME(esp);
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  fs->regs.cfa_reg = 4;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(eax) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(ebx) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(ecx) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(edx) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(esi) - new_cfa;
+  fs->regs.reg[7].how = REG_SAVED_OFFSET;
+  fs->regs.reg[7].loc.offset = (long)&sf->REG_NAME(edi) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(ebp) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(eip) - new_cfa;
+  fs->retaddr_column = 8;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+#endif /* ifdef __x86_64__  */
--- gcc/config/i386/freebsd.h.orig
+++ gcc/config/i386/freebsd.h
@@ -5,6 +5,7 @@
    Modified for stabs-in-ELF by H.J. Lu.
    Adapted from GNU/Linux version by John Polstra.
    Continued development by David O'Brien <obrien@freebsd.org>
+   Copyright (C) 2010, 2011 John Marino <www.dragonlace.net>
 
 This file is part of GCC.
 
@@ -51,22 +52,22 @@
 
 #undef  SIZE_TYPE
 #define SIZE_TYPE	(TARGET_64BIT ? "long unsigned int" : "unsigned int")
- 
+
 #undef  PTRDIFF_TYPE
 #define PTRDIFF_TYPE	(TARGET_64BIT ? "long int" : "int")
-  
+
 #undef  WCHAR_TYPE_SIZE
 #define WCHAR_TYPE_SIZE	(TARGET_64BIT ? 32 : BITS_PER_WORD)
 
 #undef  SUBTARGET_EXTRA_SPECS	/* i386.h bogusly defines it.  */
 #define SUBTARGET_EXTRA_SPECS \
   { "fbsd_dynamic_linker", FBSD_DYNAMIC_LINKER }
-    
+
 /* Provide a STARTFILE_SPEC appropriate for FreeBSD.  Here we add
-   the magical crtbegin.o file (see crtstuff.c) which provides part 
-	of the support for getting C++ file-scope static object constructed 
+   the magical crtbegin.o file (see crtstuff.c) which provides part
+	of the support for getting C++ file-scope static object constructed
 	before entering `main'.  */
-   
+
 #undef	STARTFILE_SPEC
 #define STARTFILE_SPEC \
   "%{!shared: \
@@ -76,9 +77,9 @@
    crti.o%s %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}"
 
 /* Provide a ENDFILE_SPEC appropriate for FreeBSD.  Here we tack on
-   the magical crtend.o file (see crtstuff.c) which provides part of 
-	the support for getting C++ file-scope static object constructed 
-	before entering `main', followed by a normal "finalizer" file, 
+   the magical crtend.o file (see crtstuff.c) which provides part of
+	the support for getting C++ file-scope static object constructed
+	before entering `main', followed by a normal "finalizer" file,
 	`crtn.o'.  */
 
 #undef	ENDFILE_SPEC
@@ -129,10 +130,10 @@
 #undef  DEFAULT_PCC_STRUCT_RETURN
 #define DEFAULT_PCC_STRUCT_RETURN 0
 
-/* FreeBSD sets the rounding precision of the FPU to 53 bits.  Let the
-   compiler get the contents of <float.h> and std::numeric_limits correct.  */
+/* FreeBSD sets the rounding precision of the FPU to 53 bits, but GNAT
+   resets it to full precision.  */
 #undef TARGET_96_ROUND_53_LONG_DOUBLE
-#define TARGET_96_ROUND_53_LONG_DOUBLE (!TARGET_64BIT)
+#define TARGET_96_ROUND_53_LONG_DOUBLE 0
 
 /* Put all *tf routines in libgcc.  */
 #undef LIBGCC2_HAS_TF_MODE
@@ -148,5 +149,38 @@
 #define SUBTARGET32_DEFAULT_CPU "i486"
 #endif
 
-#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
+/* Define location of OS-specific unwind support configuration. */
+#define MD_UNWIND_SUPPORT "config/i386/freebsd-unwind.h"
+
+/* Through FreeBSD 8.2 at least, stack is denied execution rights by libthr
+   This only affects AMD64 since i386 ignores the nx bit (non-PAE)
+   However, it's still included in i386 because it's possible an AMD64
+   machine will be required to run a binary generated by i386 GNAT.
+   perms = PROT_READ | PROT_WRITE | PROT_EXEC;
+*/
+#define ENABLE_EXECUTE_STACK                             \
+extern void __enable_execute_stack (void *);             \
+void                                                     \
+__enable_execute_stack (void *addr)                      \
+{                                                        \
+  extern int getpagesize (void);                         \
+  extern int mprotect (void *, size_t, int);             \
+                                                         \
+  static int size;                                       \
+  long mask;                                             \
+  char *page, *ends;                                     \
+  long page_addr = (long) addr;                          \
+  long ends_addr = (long) (addr + TRAMPOLINE_SIZE);      \
+  int  perms     = 7;                                    \
+                                                         \
+  if (size == 0)                                         \
+  {                                                      \
+    size = getpagesize();                                \
+  }                                                      \
+  mask = ~((long) size - 1);                             \
+  page = (char *)  (page_addr & mask);                   \
+  ends = (char *) ((ends_addr & mask) + size);           \
+  (void) mprotect (page, ends - page, perms);            \
+}
+
 
--- gcc/config/i386/netbsd-elf.h.orig
+++ gcc/config/i386/netbsd-elf.h
@@ -2,6 +2,7 @@
    for i386/ELF NetBSD systems.
    Copyright (C) 2001, 2002, 2004, 2007 Free Software Foundation, Inc.
    Contributed by matthew green <mrg@eterna.com.au>
+   Copyright (C) 2010, 2011 John Marino <www.dragonlace.net>
 
 This file is part of GCC.
 
@@ -39,6 +40,7 @@
 
 #undef LINK_SPEC
 #define LINK_SPEC NETBSD_LINK_SPEC_ELF
+#define LINK_LIBGCC_SPEC "%D -R @EXEC_PREFIX@/lib"
 
 #define NETBSD_ENTRY_POINT "__start"
 
@@ -122,3 +124,14 @@
 #define ENABLE_EXECUTE_STACK NETBSD_ENABLE_EXECUTE_STACK
 
 #define TARGET_VERSION fprintf (stderr, " (NetBSD/i386 ELF)");
+
+/* ADDED FOR GNAT AUX SUPPORT */
+/* Define this to be nonzero if static stack checking is supported. */
+#define STACK_CHECK_STATIC_BUILTIN 1
+
+/* Define location of OS-specific unwind support configuration. */
+#define MD_UNWIND_SUPPORT "config/i386/netbsd-unwind.h"
+
+#if defined(HAVE_LD_EH_FRAME_HDR)
+#define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
+#endif
--- /dev/null
+++ gcc/config/i386/netbsd-unwind.h
@@ -0,0 +1,169 @@
+/* DWARF2 EH unwinding support for x86 NetBSD
+   Copyright (C) 2010 John Marino (www.dragonlace.net) */
+
+/* Do code reading to identify a signal frame, and set the frame
+   state data appropriately.  See unwind-dw2.c for the structs. */
+
+#include <sys/ucontext.h>
+#include <machine/frame.h>
+
+#define REG_NAME(reg)   sf_uc.uc_mcontext.__gregs[_REG_## reg]
+
+#ifdef __x86_64__
+
+
+
+
+#define MD_FALLBACK_FRAME_STATE_FOR x86_64_netbsd_fallback_frame_state
+
+static _Unwind_Reason_Code
+x86_64_netbsd_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  /* signal_frame is sigframe_siginfo minus sf_ra handler return address */
+  struct signal_frame {
+         siginfo_t    sf_si;   /* actual saved siginfo  */
+         ucontext_t   sf_uc;   /* actual saved ucontext */
+  };
+  struct signal_frame *sf;
+  long new_cfa;
+
+  /*  We are looking for the following signal trampoline pattern. If we don't
+      find it, we are at the end of the stack and can't unwind.
+
+      <__sigtramp_siginfo_2+12>:  mov     $0xffffffffffffffff,%rdi
+      <__sigtramp_siginfo_2+19>:  mov     $0x1,%rax
+      <__sigtramp_siginfo_2+26>:  syscall
+  */
+
+  if (   *(unsigned int   *) (context->ra + 12) == 0xffc7c748
+      && *(unsigned int   *) (context->ra + 16) == 0x48ffffff
+      && *(unsigned int   *) (context->ra + 20) == 0x0001c0c7
+      && *(unsigned int   *) (context->ra + 24) == 0x050f0000 )
+  {
+    sf = (struct signal_frame *) context->cfa;
+    new_cfa = sf->REG_NAME(RSP);
+    fs->regs.cfa_how = CFA_REG_OFFSET;
+    fs->regs.cfa_reg = 7;
+    fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+  }
+  else
+  {
+    return _URC_END_OF_STACK;
+  }
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[ 0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 0].loc.offset = (long)&sf->REG_NAME(RAX) - new_cfa;
+  fs->regs.reg[ 1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 1].loc.offset = (long)&sf->REG_NAME(RDX) - new_cfa;
+  fs->regs.reg[ 2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 2].loc.offset = (long)&sf->REG_NAME(RCX) - new_cfa;
+  fs->regs.reg[ 3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 3].loc.offset = (long)&sf->REG_NAME(RBX) - new_cfa;
+  fs->regs.reg[ 4].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 4].loc.offset = (long)&sf->REG_NAME(RSI) - new_cfa;
+  fs->regs.reg[ 5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 5].loc.offset = (long)&sf->REG_NAME(RDI) - new_cfa;
+  fs->regs.reg[ 6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 6].loc.offset = (long)&sf->REG_NAME(RBP) - new_cfa;
+  fs->regs.reg[ 8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 8].loc.offset = (long)&sf->REG_NAME(R8)  - new_cfa;
+  fs->regs.reg[ 9].how = REG_SAVED_OFFSET;
+  fs->regs.reg[ 9].loc.offset = (long)&sf->REG_NAME(R9)  - new_cfa;
+  fs->regs.reg[10].how = REG_SAVED_OFFSET;
+  fs->regs.reg[10].loc.offset = (long)&sf->REG_NAME(R10) - new_cfa;
+  fs->regs.reg[11].how = REG_SAVED_OFFSET;
+  fs->regs.reg[11].loc.offset = (long)&sf->REG_NAME(R11) - new_cfa;
+  fs->regs.reg[12].how = REG_SAVED_OFFSET;
+  fs->regs.reg[12].loc.offset = (long)&sf->REG_NAME(R12) - new_cfa;
+  fs->regs.reg[13].how = REG_SAVED_OFFSET;
+  fs->regs.reg[13].loc.offset = (long)&sf->REG_NAME(R13) - new_cfa;
+  fs->regs.reg[14].how = REG_SAVED_OFFSET;
+  fs->regs.reg[14].loc.offset = (long)&sf->REG_NAME(R14) - new_cfa;
+  fs->regs.reg[15].how = REG_SAVED_OFFSET;
+  fs->regs.reg[15].loc.offset = (long)&sf->REG_NAME(R15) - new_cfa;
+  fs->regs.reg[16].how = REG_SAVED_OFFSET;
+  fs->regs.reg[16].loc.offset = (long)&sf->REG_NAME(RIP) - new_cfa;
+  fs->retaddr_column = 16;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+
+
+
+
+#else /* Next section is for i386  */
+
+
+
+
+#define MD_FALLBACK_FRAME_STATE_FOR x86_netbsd_fallback_frame_state
+
+static _Unwind_Reason_Code
+x86_netbsd_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  /* signal_frame is sigframe_siginfo minus sf_ra handler return address */
+  struct signal_frame {
+         int          sf_signum;  /* "signum" argument for handler" */
+         siginfo_t   *sf_sip;     /* "sip"    argument for handler" */
+         ucontext_t  *sf_ucp;     /* "ucp"    argument for handler" */
+         siginfo_t    sf_si;      /* actual saved siginfo  */
+         ucontext_t   sf_uc;      /* actual saved ucontext */
+  };
+  struct signal_frame *sf;
+  long new_cfa;
+
+  /*  We are looking for the following signal trampoline pattern. If we don't
+      find it, we are at the end of the stack and can't unwind.
+
+      <__sigtramp_siginfo_2+18>:  movl   $0xffffffff,0x4(%esp)
+      <__sigtramp_siginfo_2+26>:  mov    $0x1,%eax
+      <__sigtramp_siginfo_2+31>:  int    $0x80
+  */
+
+  if (   *(unsigned int   *) (context->ra + 18) == 0x042444c7
+      && *(unsigned int   *) (context->ra + 22) == 0xffffffff
+      && *(unsigned char  *) (context->ra + 26) == 0xb8
+      && *(unsigned int   *) (context->ra + 27) == 0x00000001
+      && *(unsigned short *) (context->ra + 31) == 0x80cd     )
+  {
+    sf = (struct signal_frame *) context->cfa;
+    new_cfa = sf->REG_NAME(ESP);
+    fs->regs.cfa_how = CFA_REG_OFFSET;
+    fs->regs.cfa_reg = 4;
+    fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+  }
+  else
+  {
+    return _URC_END_OF_STACK;
+  }
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(EAX) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(EBX) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(ECX) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(EDX) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(ESI) - new_cfa;
+  fs->regs.reg[7].how = REG_SAVED_OFFSET;
+  fs->regs.reg[7].loc.offset = (long)&sf->REG_NAME(EDI) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(EBP) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(EIP) - new_cfa;
+  fs->retaddr_column = 8;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
+
+
+
+
+#endif /* ifdef __x86_64__  */
+
--- gcc/config/i386/netbsd64.h.orig
+++ gcc/config/i386/netbsd64.h
@@ -2,6 +2,7 @@
    for x86-64/ELF NetBSD systems.
    Copyright (C) 2002, 2004, 2007 Free Software Foundation, Inc.
    Contributed by Wasabi Systems, Inc.
+   Copyright (C) 2010, 2011 John Marino <www.dragonlace.net>
 
 This file is part of GCC.
 
@@ -70,3 +71,13 @@
 #define ENABLE_EXECUTE_STACK NETBSD_ENABLE_EXECUTE_STACK
 
 #define TARGET_VERSION fprintf (stderr, " (NetBSD/x86_64 ELF)");
+
+/* ADDED FOR GNAT AUX SUPPORT */
+/* Define this to be nonzero if static stack checking is supported. */
+#define STACK_CHECK_STATIC_BUILTIN 1
+
+#define MD_UNWIND_SUPPORT "config/i386/netbsd-unwind.h"
+
+#if defined(HAVE_LD_EH_FRAME_HDR)
+#define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
+#endif
--- /dev/null
+++ gcc/config/i386/openbsd-unwind32.h
@@ -0,0 +1,77 @@
+/* DWARF2 EH unwinding support for x86 OpenBSD
+   Copyright (C) 2010 John Marino (www.dragonlace.net) */
+
+/* Do code reading to identify a signal frame, and set the frame
+   state data appropriately.  See unwind-dw2.c for the structs. */
+
+#include <sys/param.h>
+#include <sys/sysctl.h>
+#include <machine/frame.h>
+/* machine/frame.h brings in sys/signal.h
+   sys/signal.h    brings in machine/signal.h  (sigcontext)
+                   brings in sys/siginfo.h     (siginfo_t) */
+
+
+#define REG_NAME(reg)                 sf_sc.sc_## reg
+#define MD_FALLBACK_FRAME_STATE_FOR   x86_openbsd_fallback_frame_state
+
+
+static void
+x86_sigtramp_range (unsigned char **start, unsigned char **end)
+{
+  struct _ps_strings ps_strings;
+  int mib[2];
+  size_t len;
+
+  mib[0] = CTL_VM;
+  mib[1] = VM_PSSTRINGS;
+  len = sizeof (ps_strings);
+  sysctl (mib, 2, &ps_strings, &len, NULL, 0);
+
+  *start = (unsigned char *)ps_strings.val - 128;
+  *end   = (unsigned char *)ps_strings.val;
+}
+
+
+static _Unwind_Reason_Code
+x86_openbsd_fallback_frame_state
+(struct _Unwind_Context *context, _Unwind_FrameState *fs)
+{
+  unsigned char *pc = context->ra;
+  unsigned char *sigtramp_start, *sigtramp_end;
+  struct sigframe *sf;
+  long new_cfa;
+
+  x86_sigtramp_range(&sigtramp_start, &sigtramp_end);
+
+  if (pc >= sigtramp_end || pc < sigtramp_start)
+    return _URC_END_OF_STACK;
+
+  sf = (struct sigframe *) context->cfa;
+  new_cfa = sf->REG_NAME(esp);
+
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  fs->regs.cfa_reg = 4;
+  fs->regs.cfa_offset = new_cfa - (long) context->cfa;
+
+  /* The SVR4 register numbering macros aren't usable in libgcc.  */
+  fs->regs.reg[0].how = REG_SAVED_OFFSET;
+  fs->regs.reg[0].loc.offset = (long)&sf->REG_NAME(eax) - new_cfa;
+  fs->regs.reg[3].how = REG_SAVED_OFFSET;
+  fs->regs.reg[3].loc.offset = (long)&sf->REG_NAME(ebx) - new_cfa;
+  fs->regs.reg[1].how = REG_SAVED_OFFSET;
+  fs->regs.reg[1].loc.offset = (long)&sf->REG_NAME(ecx) - new_cfa;
+  fs->regs.reg[2].how = REG_SAVED_OFFSET;
+  fs->regs.reg[2].loc.offset = (long)&sf->REG_NAME(edx) - new_cfa;
+  fs->regs.reg[6].how = REG_SAVED_OFFSET;
+  fs->regs.reg[6].loc.offset = (long)&sf->REG_NAME(esi) - new_cfa;
+  fs->regs.reg[7].how = REG_SAVED_OFFSET;
+  fs->regs.reg[7].loc.offset = (long)&sf->REG_NAME(edi) - new_cfa;
+  fs->regs.reg[5].how = REG_SAVED_OFFSET;
+  fs->regs.reg[5].loc.offset = (long)&sf->REG_NAME(ebp) - new_cfa;
+  fs->regs.reg[8].how = REG_SAVED_OFFSET;
+  fs->regs.reg[8].loc.offset = (long)&sf->REG_NAME(eip) - new_cfa;
+  fs->retaddr_column = 8;
+  fs->signal_frame = 1;
+  return _URC_NO_REASON;
+}
--- /dev/null
+++ gcc/config/i386/openbsd64.h
@@ -0,0 +1,112 @@
+/* Definitions for AMD x86_64 running OpenBSD BSD with ELF Format */
+
+#undef TARGET_VERSION
+#define TARGET_VERSION fprintf (stderr, " (OpenBSD/x86-64 ELF)")
+
+/* This gets defined in tm.h->linux.h->svr4.h, and keeps us from using
+   libraries compiled with the native cc, so undef it. */
+#undef NO_DOLLAR_IN_LABEL
+
+/* Override the default comment-starter of "/".  */
+#undef ASM_COMMENT_START
+#define ASM_COMMENT_START "#"
+
+/* Run-time target specifications */
+
+#define TARGET_OS_CPP_BUILTINS()		\
+  do						\
+    {						\
+    	OPENBSD_OS_CPP_BUILTINS_ELF();		\
+	if (TARGET_64BIT)			\
+		OPENBSD_OS_CPP_BUILTINS_LP64();	\
+    }						\
+  while (0)
+
+/* As an elf system, we need crtbegin/crtend stuff.  */
+#undef STARTFILE_SPEC
+#define STARTFILE_SPEC "\
+	%{!shared: %{pg:gcrt0%O%s} %{!pg:%{p:gcrt0%O%s} %{!p:crt0%O%s}} \
+	crtbegin%O%s} %{shared:crtbeginS%O%s}"
+#undef ENDFILE_SPEC
+#define ENDFILE_SPEC "%{!shared:crtend%O%s} %{shared:crtendS%O%s}"
+
+/* Layout of source language data types.  */
+
+/* This must agree with <machine/_types.h> */
+#undef SIZE_TYPE
+#define SIZE_TYPE "long unsigned int"
+
+#undef PTRDIFF_TYPE
+#define PTRDIFF_TYPE "long int"
+
+#undef WCHAR_TYPE
+#define WCHAR_TYPE "int"
+
+#undef WCHAR_TYPE_SIZE
+#define WCHAR_TYPE_SIZE 32
+
+/* Assembler format: overall framework.  */
+
+#undef ASM_APP_ON
+#define ASM_APP_ON "#APP\n"
+
+#undef ASM_APP_OFF
+#define ASM_APP_OFF "#NO_APP\n"
+
+#undef SET_ASM_OP
+#define SET_ASM_OP	"\t.set\t"
+
+/* The following macros were originally stolen from i386v4.h.
+   These have to be defined to get PIC code correct.  */
+
+/* Assembler format: dispatch tables.  */
+
+/* Assembler format: sections.  */
+
+/* Stack & calling: aggregate returns.  */
+
+/* Don't default to pcc-struct-return, because gcc is the only compiler, and
+   we want to retain compatibility with older gcc versions.  */
+#define DEFAULT_PCC_STRUCT_RETURN 0
+
+/* Assembler format: alignment output.  */
+
+/* Stack & calling: profiling.  */
+
+/* OpenBSD's profiler recovers all information from the stack pointer.
+   The icky part is not here, but in machine/profile.h.  */
+#undef FUNCTION_PROFILER
+#define FUNCTION_PROFILER(FILE, LABELNO)  \
+  fputs (flag_pic ? "\tcall __mcount@PLT\n": "\tcall __mcount\n", FILE);
+
+/* Assembler format: exception region output.  */
+
+/* Assembler format: alignment output.  */
+
+/* Note that we pick up ASM_OUTPUT_MAX_SKIP_ALIGN from i386/gas.h */
+
+/* Note that we pick up ASM_OUTPUT_MI_THUNK from unix.h.  */
+
+#undef LINK_SPEC
+#define LINK_SPEC \
+  "%{!shared:%{!nostdlib:%{!r*:%{!e*:-e __start}}}} \
+   %{shared:-shared} %{R*} \
+   %{static:-Bstatic} \
+   %{!static:-Bdynamic} \
+   %{assert*} \
+   %{!dynamic-linker:-dynamic-linker /usr/libexec/ld.so}"
+
+#define OBSD_HAS_CORRECT_SPECS
+
+#undef JUMP_TABLES_IN_TEXT_SECTION
+#define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)
+
+/* ADDED FOR GNAT AUX SUPPORT */
+/* Define this to be nonzero if static stack checking is supported */
+#undef  STACK_CHECK_STATIC_BUILTIN
+#define STACK_CHECK_STATIC_BUILTIN 1
+
+/* Ensure rounding is left to GNAT (Not required for AMD64) */
+#undef  TARGET_96_ROUND_53_LONG_DOUBLE
+#define TARGET_96_ROUND_53_LONG_DOUBLE 1
+
--- gcc/config/i386/openbsdelf.h.orig
+++ gcc/config/i386/openbsdelf.h
@@ -1,6 +1,7 @@
 /* Configuration for an OpenBSD i386 target.
-   
+
    Copyright (C) 2005, 2007, 2009, 2010 Free Software Foundation, Inc.
+   Copyright (C) 2010, 2011 John Marino <www.dragonlace.net>
 
 This file is part of GCC.
 
@@ -82,7 +83,7 @@
 
 /* The following macros were originally stolen from i386v4.h.
    These have to be defined to get PIC code correct.  */
-
+   
 /* Assembler format: dispatch tables.  */
 
 /* Assembler format: sections.  */
@@ -132,3 +133,18 @@
    -dynamic-linker /usr/libexec/ld.so"
 
 #define OBSD_HAS_CORRECT_SPECS
+
+
+/* ADDED FOR GNAT AUX SUPPORT */
+/* Define this to be nonzero if static stack checking is supported */
+#undef  STACK_CHECK_STATIC_BUILTIN
+#define STACK_CHECK_STATIC_BUILTIN 1
+
+/* Ensure rounding is left to GNAT (i386 only) */
+#undef  TARGET_96_ROUND_53_LONG_DOUBLE
+#define TARGET_96_ROUND_53_LONG_DOUBLE 0
+
+/* Define location of OS-specific unwind support configuration. 
+   Not required until OpenBSD changes from SJLJ to ZCX exceptions 
+   When that happens, remove comments from first line and delete second line. */
+/*#define MD_UNWIND_SUPPORT "config/i386/openbsd-unwind32.h" */
--- gcc/ginclude/stddef.h.orig
+++ gcc/ginclude/stddef.h
@@ -1,5 +1,6 @@
 /* Copyright (C) 1989, 1997, 1998, 1999, 2000, 2002, 2004, 2009
    Free Software Foundation, Inc.
+   Copyright (C) 2010 John Marino <draco@marino.st>
 
 This file is part of GCC.
 
@@ -59,6 +60,10 @@
 #include <sys/_types.h>
 #endif
 
+#if defined (__DragonFly__)
+#include <sys/types.h>
+#endif
+
 /* In 4.3bsd-net2, machine/ansi.h defines these symbols, which are
    defined if the corresponding type is *not* defined.
    FreeBSD-2.1 defines _MACHINE_ANSI_H_ instead of _ANSI_H_.
@@ -136,6 +141,7 @@
 #ifndef _BSD_PTRDIFF_T_
 #ifndef ___int_ptrdiff_t_h
 #ifndef _GCC_PTRDIFF_T
+#ifndef _PTRDIFF_T_DECLARED /* DragonFly BSD */
 #define _PTRDIFF_T
 #define _T_PTRDIFF_
 #define _T_PTRDIFF
@@ -144,10 +150,12 @@
 #define _BSD_PTRDIFF_T_
 #define ___int_ptrdiff_t_h
 #define _GCC_PTRDIFF_T
+#define _PTRDIFF_T_DECLARED
 #ifndef __PTRDIFF_TYPE__
 #define __PTRDIFF_TYPE__ long int
 #endif
 typedef __PTRDIFF_TYPE__ ptrdiff_t;
+#endif /* _PTRDFF_T_DECLARED */
 #endif /* _GCC_PTRDIFF_T */
 #endif /* ___int_ptrdiff_t_h */
 #endif /* _BSD_PTRDIFF_T_ */
@@ -179,7 +187,7 @@
 #ifndef _SIZE_T_DEFINED_
 #ifndef _SIZE_T_DEFINED
 #ifndef _BSD_SIZE_T_DEFINED_	/* Darwin */
-#ifndef _SIZE_T_DECLARED	/* FreeBSD 5 */
+#ifndef _SIZE_T_DECLARED	/* FreeBSD 5, also DragonFly */
 #ifndef ___int_size_t_h
 #ifndef _GCC_SIZE_T
 #ifndef _SIZET_
@@ -196,12 +204,13 @@
 #define _SIZE_T_DEFINED_
 #define _SIZE_T_DEFINED
 #define _BSD_SIZE_T_DEFINED_	/* Darwin */
-#define _SIZE_T_DECLARED	/* FreeBSD 5 */
+#define _SIZE_T_DECLARED	/* FreeBSD 5, DragonFly */
 #define ___int_size_t_h
 #define _GCC_SIZE_T
 #define _SIZET_
-#if defined (__FreeBSD__) && (__FreeBSD__ >= 5)
-/* __size_t is a typedef on FreeBSD 5!, must not trash it. */
+#if defined (__DragonFly__) || (defined (__FreeBSD__) && (__FreeBSD__ >= 5))
+/* __size_t is a typedef on FreeBSD 5!, must not trash it. 
+   __size_t is also defined in <machine/stdint.h> on DragonFly BSD */
 #else
 #define __size_t
 #endif
@@ -253,7 +262,7 @@
 #ifndef _BSD_WCHAR_T_
 #ifndef _BSD_WCHAR_T_DEFINED_    /* Darwin */
 #ifndef _BSD_RUNE_T_DEFINED_	/* Darwin */
-#ifndef _WCHAR_T_DECLARED /* FreeBSD 5 */
+#ifndef _WCHAR_T_DECLARED /* FreeBSD 5, also DragonFly */
 #ifndef _WCHAR_T_DEFINED_
 #ifndef _WCHAR_T_DEFINED
 #ifndef _WCHAR_T_H
@@ -305,8 +314,10 @@
 #endif
 /* FreeBSD 5 can't be handled well using "traditional" logic above
    since it no longer defines _BSD_RUNE_T_ yet still desires to export
-   rune_t in some cases... */
-#if defined (__FreeBSD__) && (__FreeBSD__ >= 5)
+   rune_t in some cases... 
+   DragonFly BSD inherited this quirk from FreeBSD 4.8.
+*/
+#if defined (__DragonFly__) || (defined (__FreeBSD__) && (__FreeBSD__ >= 5))
 #if !defined (_ANSI_SOURCE) && !defined (_POSIX_SOURCE)
 #if __BSD_VISIBLE
 #ifndef _RUNE_T_DECLARED
--- include/libiberty.h.orig
+++ include/libiberty.h
@@ -2,6 +2,7 @@
 
    Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
    2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
+   Copyright 2010, 2011 John Marino <http://www.dragonlace.net>
    
    Note - certain prototypes declared in this header file are for
    functions whoes implementation copyright does not belong to the
@@ -102,7 +103,16 @@
    to find the declaration so provide a fully prototyped one.  If it
    is 1, we found it so don't provide any declaration at all.  */
 #if !HAVE_DECL_BASENAME
-#if defined (__GNU_LIBRARY__ ) || defined (__linux__) || defined (__FreeBSD__) || defined (__OpenBSD__) || defined(__NetBSD__) || defined (__CYGWIN__) || defined (__CYGWIN32__) || defined (__MINGW32__) || defined (HAVE_DECL_BASENAME)
+#if defined (__GNU_LIBRARY__)	\
+ || defined (__linux__) 	\
+ || defined (__FreeBSD__)	\
+ || defined (__OpenBSD__)	\
+ || defined (__NetBSD__)	\
+ || defined (__DragonFly__)	\
+ || defined (__CYGWIN__)	\
+ || defined (__CYGWIN32__)	\
+ || defined (__MINGW32__)	\
+ || defined (HAVE_DECL_BASENAME)
 extern char *basename (const char *);
 #else
 /* Do not allow basename to be used if there is no prototype seen.  We
--- libgcc/config.host.orig
+++ libgcc/config.host
@@ -1,6 +1,7 @@
 # libgcc host-specific configuration file.
 # Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
 # 2008, 2009, 2010 Free Software Foundation, Inc.
+# Copyright 2010-2012 John Marino <http://www.dragonlace.net>
 
 #This file is part of GCC.
 
@@ -157,6 +158,8 @@
   ;;
 *-*-openbsd*)
   ;;
+*-*-dragonfly*)
+  ;;
 *-*-rtems*)
   ;;
 *-*-vxworks*)
@@ -278,6 +281,14 @@
 x86_64-*-freebsd*)
 	tmake_file="${tmake_file} i386/t-freebsd"
 	;;
+i[34567]86-*-dragonfly*)
+	# define symbol versions (same as FreeBSD)
+	tmake_file="${tmake_file} i386/t-dragonfly"
+	;;
+x86_64-*-dragonfly*)
+	# define symbol versions (same as FreeBSD)
+	tmake_file="${tmake_file} i386/t-dragonfly"
+	;;
 i[34567]86-*-netbsdelf*)
 	;;
 i[34567]86-*-netbsd*)
@@ -288,6 +299,8 @@
 	;;
 i[34567]86-*-openbsd*)
 	;;
+x86_64-*-openbsd*)
+	;;
 i[34567]86-*-linux* | i[34567]86-*-kfreebsd*-gnu | i[34567]86-*-knetbsd*-gnu | i[34567]86-*-gnu*)
 	extra_parts="$extra_parts crtprec32.o crtprec64.o crtprec80.o crtfastmath.o"
 	tmake_file="${tmake_file} i386/t-crtpc i386/t-crtfm"
@@ -619,6 +632,9 @@
 		tmake_file="${tmake_file} t-softfp i386/${host_address}/t-fprules-softfp"
 	fi
 	;;
+i[34567]86-*-dragonfly* | i[34567]86-*-netbsdelf*)
+	tmake_file="${tmake_file} t-softfp i386/32/t-fprules-softfp"
+	;;
 esac
 
 case ${host} in
--- /dev/null
+++ libgcc/config/i386/t-dragonfly
@@ -0,0 +1,2 @@
+# Add support for the introduction of 128-bit long double.
+SHLIB_MAPFILES += $(srcdir)/config/i386/libgcc-bsd.ver
--- gcc/configure.orig
+++ gcc/configure
@@ -25833,6 +25833,20 @@
       gcc_cv_target_dl_iterate_phdr=no
     fi
     ;;
+  *-*-dragonfly* | *-*-freebsd*)
+  if grep dl_iterate_phdr $target_header_dir/sys/link_elf.h > /dev/null 2>&1; then
+      gcc_cv_target_dl_iterate_phdr=yes
+    else
+      gcc_cv_target_dl_iterate_phdr=no
+    fi
+  ;;
+# *-*-netbsd* | *-*-openbsd*)
+# if grep dl_iterate_phdr $target_header_dir/link_elf.h > /dev/null 2>&1; then
+#     gcc_cv_target_dl_iterate_phdr=yes
+#   else
+#     gcc_cv_target_dl_iterate_phdr=no
+#   fi
+# ;;
 esac
 
 if test x$gcc_cv_target_dl_iterate_phdr = xyes; then
--- gcc/Makefile.in.orig
+++ gcc/Makefile.in
@@ -4322,7 +4322,7 @@
 	DESTDIR=$(@D) \
 	$(SHELL) $(srcdir)/doc/install.texi2html
 
-MANFILES = doc/gcov.1 doc/cpp.1 doc/gcc.1 doc/gfdl.7 doc/gpl.7 doc/fsf-funding.7
+MANFILES = doc/gcov.1 doc/cpp.1 doc/gcc.1
 
 generated-manpages: man
 
@@ -4474,7 +4474,7 @@
 # Install the driver last so that the window when things are
 # broken is small.
 install: install-common $(INSTALL_HEADERS) \
-    install-cpp install-man install-info install-@POSUB@ \
+    install-cpp install-man install-@POSUB@ \
     install-driver install-lto-wrapper
 
 ifeq ($(enable_plugin),yes)
@@ -4665,10 +4665,7 @@
 install-man: lang.install-man \
 	$(DESTDIR)$(man1dir)/$(GCC_INSTALL_NAME)$(man1ext) \
 	$(DESTDIR)$(man1dir)/$(CPP_INSTALL_NAME)$(man1ext) \
-	$(DESTDIR)$(man1dir)/$(GCOV_INSTALL_NAME)$(man1ext) \
-	$(DESTDIR)$(man7dir)/fsf-funding$(man7ext) \
-	$(DESTDIR)$(man7dir)/gfdl$(man7ext) \
-	$(DESTDIR)$(man7dir)/gpl$(man7ext)
+	$(DESTDIR)$(man1dir)/$(GCOV_INSTALL_NAME)$(man1ext)
 
 $(DESTDIR)$(man7dir)/%$(man7ext): doc/%.7 installdirs
 	-rm -f $@
--- libiberty/getpagesize.c.orig
+++ libiberty/getpagesize.c
@@ -20,6 +20,7 @@
 
 */
 
+#ifndef __ANDROID__
 #ifndef VMS
 
 #include "config.h"
@@ -88,3 +89,4 @@
 }
 
 #endif /* VMS */
+#endif /* __ANDROID__ */
--- libiberty/setproctitle.c.orig
+++ libiberty/setproctitle.c
@@ -40,9 +40,11 @@
 void
 setproctitle (const char *name ATTRIBUTE_UNUSED, ...)
 {
+#ifndef __ANDROID__
 #ifdef PR_SET_NAME
   /* On Linux this sets the top visible "comm", but not necessarily
      the name visible in ps. */
   prctl (PR_SET_NAME, name);
 #endif
+#endif
 }
--- configure.orig
+++ configure
@@ -14196,7 +14196,7 @@
 _ACEOF
 if ac_fn_c_try_compile "$LINENO"; then :
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }; stage1_cflags="$stage1_cflags -fkeep-inline-functions"
+$as_echo "yes" >&6; };
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
