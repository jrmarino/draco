--- gcc/ada/a-exetim-posix.adb.orig
+++ gcc/ada/a-exetim-posix.adb
@@ -106,11 +106,11 @@
       --  Time is equal to Duration (although it is a private type) and
       --  CPU_Time is equal to Time.
 
-      function clock_gettime
+      function clock_gettime_int
         (clock_id : Interfaces.C.int;
          tp       : access timespec)
          return int;
-      pragma Import (C, clock_gettime, "clock_gettime");
+      pragma Import (C, clock_gettime_int, "clock_gettime");
       --  Function from the POSIX.1b Realtime Extensions library
 
    begin
@@ -118,7 +118,7 @@
          raise Program_Error;
       end if;
 
-      Result := clock_gettime
+      Result := clock_gettime_int
         (clock_id => CLOCK_THREAD_CPUTIME_ID, tp => TS'Unchecked_Access);
       pragma Assert (Result = 0);
 
--- /dev/null
+++ gcc/ada/a-intnam-dragonfly.ads
@@ -0,0 +1,136 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --
+--                                                                          --
+--                   A D A . I N T E R R U P T S . N A M E S                --
+--                                                                          --
+--                                  S p e c                                 --
+--                                                                          --
+--          Copyright (C) 1991-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the DragonFly BSD THREADS version of this package
+
+with System.OS_Interface;
+
+package Ada.Interrupts.Names is
+
+   --  All identifiers in this unit are implementation defined
+
+   pragma Implementation_Defined;
+
+   --  Beware that the mapping of names to signals may be many-to-one. There
+   --  may be aliases. Also, for all signal names that are not supported on
+   --  the current system the value of the corresponding constant will be zero.
+
+   SIGHUP : constant Interrupt_ID :=
+     System.OS_Interface.SIGHUP;      --  hangup
+
+   SIGINT : constant Interrupt_ID :=
+     System.OS_Interface.SIGINT;      --  interrupt (rubout)
+
+   SIGQUIT : constant Interrupt_ID :=
+     System.OS_Interface.SIGQUIT;     --  quit (ASCD FS)
+
+   SIGILL : constant Interrupt_ID :=
+     System.OS_Interface.SIGILL;      --  illegal instruction (not reset)
+
+   SIGTRAP : constant Interrupt_ID :=
+     System.OS_Interface.SIGTRAP;     --  trace trap (not reset)
+
+   SIGIOT : constant Interrupt_ID :=
+     System.OS_Interface.SIGIOT;      --  IOT instruction
+
+   SIGABRT : constant Interrupt_ID := --  used by abort,
+     System.OS_Interface.SIGABRT;     --  replace SIGIOT in the  future
+
+   SIGFPE : constant Interrupt_ID :=
+     System.OS_Interface.SIGFPE;      --  floating point exception
+
+   SIGKILL : constant Interrupt_ID :=
+     System.OS_Interface.SIGKILL;     --  kill (cannot be caught or ignored)
+
+   SIGBUS : constant Interrupt_ID :=
+     System.OS_Interface.SIGBUS;      --  bus error
+
+   SIGSEGV : constant Interrupt_ID :=
+     System.OS_Interface.SIGSEGV;     --  segmentation violation
+
+   SIGPIPE : constant Interrupt_ID := --  write on a pipe with
+     System.OS_Interface.SIGPIPE;     --  no one to read it
+
+   SIGALRM : constant Interrupt_ID :=
+     System.OS_Interface.SIGALRM;     --  alarm clock
+
+   SIGTERM : constant Interrupt_ID :=
+     System.OS_Interface.SIGTERM;     --  software termination signal from kill
+
+   SIGURG : constant Interrupt_ID :=
+     System.OS_Interface.SIGURG;      --  urgent condition on IO channel
+
+   SIGSTOP : constant Interrupt_ID :=
+     System.OS_Interface.SIGSTOP;     --  stop (cannot be caught or ignored)
+
+   SIGTSTP : constant Interrupt_ID :=
+     System.OS_Interface.SIGTSTP;     --  user stop requested from tty
+
+   SIGCONT : constant Interrupt_ID :=
+     System.OS_Interface.SIGCONT;     --  stopped process has been continued
+
+   SIGCHLD : constant Interrupt_ID :=
+     System.OS_Interface.SIGCHLD;     --  4.3BSD's/POSIX name for SIGCLD
+
+   SIGCLD : constant Interrupt_ID :=
+     System.OS_Interface.SIGCLD;      --  child status change
+
+   SIGTTIN : constant Interrupt_ID :=
+     System.OS_Interface.SIGTTIN;     --  background tty read attempted
+
+   SIGTTOU : constant Interrupt_ID :=
+     System.OS_Interface.SIGTTOU;     --  background tty write attempted
+
+   SIGIO : constant Interrupt_ID :=   --  input/output possible,
+     System.OS_Interface.SIGIO;       --  SIGPOLL alias (Solaris)
+
+   SIGXCPU : constant Interrupt_ID :=
+     System.OS_Interface.SIGXCPU;     --  CPU time limit exceeded
+
+   SIGXFSZ : constant Interrupt_ID :=
+     System.OS_Interface.SIGXFSZ;     --  filesize limit exceeded
+
+   SIGVTALRM : constant Interrupt_ID :=
+     System.OS_Interface.SIGVTALRM;   --  virtual timer expired
+
+   SIGPROF : constant Interrupt_ID :=
+     System.OS_Interface.SIGPROF;     --  profiling timer expired
+
+   SIGWINCH : constant Interrupt_ID :=
+     System.OS_Interface.SIGWINCH;    --  window size change
+
+   SIGUSR1 : constant Interrupt_ID :=
+     System.OS_Interface.SIGUSR1;     --  user defined signal 1
+
+   SIGUSR2 : constant Interrupt_ID :=
+     System.OS_Interface.SIGUSR2;     --  user defined signal 2
+
+end Ada.Interrupts.Names;
--- /dev/null
+++ gcc/ada/a-intnam-netbsd.ads
@@ -0,0 +1,139 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --
+--                                                                          --
+--                   A D A . I N T E R R U P T S . N A M E S                --
+--                                                                          --
+--                                  S p e c                                 --
+--                                                                          --
+--          Copyright (C) 1991-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the NetBSD THREADS version of this package
+
+with System.OS_Interface;
+
+package Ada.Interrupts.Names is
+
+   --  All identifiers in this unit are implementation defined
+
+   pragma Implementation_Defined;
+
+   --  Beware that the mapping of names to signals may be many-to-one. There
+   --  may be aliases. Also, for all signal names that are not supported on
+   --  the current system the value of the corresponding constant will be zero.
+
+   SIGHUP : constant Interrupt_ID :=
+     System.OS_Interface.SIGHUP;      --  hangup
+
+   SIGINT : constant Interrupt_ID :=
+     System.OS_Interface.SIGINT;      --  interrupt (rubout)
+
+   SIGQUIT : constant Interrupt_ID :=
+     System.OS_Interface.SIGQUIT;     --  quit (ASCD FS)
+
+   SIGILL : constant Interrupt_ID :=
+     System.OS_Interface.SIGILL;      --  illegal instruction (not reset)
+
+   SIGTRAP : constant Interrupt_ID :=
+     System.OS_Interface.SIGTRAP;     --  trace trap (not reset)
+
+   SIGIOT : constant Interrupt_ID :=
+     System.OS_Interface.SIGIOT;      --  IOT instruction
+
+   SIGABRT : constant Interrupt_ID := --  used by abort,
+     System.OS_Interface.SIGABRT;     --  replace SIGIOT in the  future
+
+   SIGFPE : constant Interrupt_ID :=
+     System.OS_Interface.SIGFPE;      --  floating point exception
+
+   SIGKILL : constant Interrupt_ID :=
+     System.OS_Interface.SIGKILL;     --  kill (cannot be caught or ignored)
+
+   SIGBUS : constant Interrupt_ID :=
+     System.OS_Interface.SIGBUS;      --  bus error
+
+   SIGSEGV : constant Interrupt_ID :=
+     System.OS_Interface.SIGSEGV;     --  segmentation violation
+
+   SIGPIPE : constant Interrupt_ID := --  write on a pipe with
+     System.OS_Interface.SIGPIPE;     --  no one to read it
+
+   SIGALRM : constant Interrupt_ID :=
+     System.OS_Interface.SIGALRM;     --  alarm clock
+
+   SIGTERM : constant Interrupt_ID :=
+     System.OS_Interface.SIGTERM;     --  software termination signal from kill
+
+   SIGURG : constant Interrupt_ID :=
+     System.OS_Interface.SIGURG;      --  urgent condition on IO channel
+
+   SIGSTOP : constant Interrupt_ID :=
+     System.OS_Interface.SIGSTOP;     --  stop (cannot be caught or ignored)
+
+   SIGTSTP : constant Interrupt_ID :=
+     System.OS_Interface.SIGTSTP;     --  user stop requested from tty
+
+   SIGCONT : constant Interrupt_ID :=
+     System.OS_Interface.SIGCONT;     --  stopped process has been continued
+
+   SIGCHLD : constant Interrupt_ID :=
+     System.OS_Interface.SIGCHLD;     --  4.3BSD's/POSIX name for SIGCLD
+
+   SIGCLD : constant Interrupt_ID :=
+     System.OS_Interface.SIGCLD;      --  child status change
+
+   SIGTTIN : constant Interrupt_ID :=
+     System.OS_Interface.SIGTTIN;     --  background tty read attempted
+
+   SIGTTOU : constant Interrupt_ID :=
+     System.OS_Interface.SIGTTOU;     --  background tty write attempted
+
+   SIGIO : constant Interrupt_ID :=   --  input/output possible,
+     System.OS_Interface.SIGIO;       --  SIGPOLL alias (Solaris)
+
+   SIGXCPU : constant Interrupt_ID :=
+     System.OS_Interface.SIGXCPU;     --  CPU time limit exceeded
+
+   SIGXFSZ : constant Interrupt_ID :=
+     System.OS_Interface.SIGXFSZ;     --  filesize limit exceeded
+
+   SIGVTALRM : constant Interrupt_ID :=
+     System.OS_Interface.SIGVTALRM;   --  virtual timer expired
+
+   SIGPROF : constant Interrupt_ID :=
+     System.OS_Interface.SIGPROF;     --  profiling timer expired
+
+   SIGWINCH : constant Interrupt_ID :=
+     System.OS_Interface.SIGWINCH;    --  window size change
+
+   SIGUSR1 : constant Interrupt_ID :=
+     System.OS_Interface.SIGUSR1;     --  user defined signal 1
+
+   SIGUSR2 : constant Interrupt_ID :=
+     System.OS_Interface.SIGUSR2;     --  user defined signal 2
+
+   SIGPWR : constant Interrupt_ID :=
+     System.OS_Interface.SIGPWR;      --  power fail/restart
+
+end Ada.Interrupts.Names;
--- /dev/null
+++ gcc/ada/a-intnam-openbsd.ads
@@ -0,0 +1,136 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --
+--                                                                          --
+--                   A D A . I N T E R R U P T S . N A M E S                --
+--                                                                          --
+--                                  S p e c                                 --
+--                                                                          --
+--          Copyright (C) 1991-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the OpenBSD THREADS version of this package
+
+with System.OS_Interface;
+
+package Ada.Interrupts.Names is
+
+   --  All identifiers in this unit are implementation defined
+
+   pragma Implementation_Defined;
+
+   --  Beware that the mapping of names to signals may be many-to-one. There
+   --  may be aliases. Also, for all signal names that are not supported on
+   --  the current system the value of the corresponding constant will be zero.
+
+   SIGHUP : constant Interrupt_ID :=
+     System.OS_Interface.SIGHUP;      --  hangup
+
+   SIGINT : constant Interrupt_ID :=
+     System.OS_Interface.SIGINT;      --  interrupt (rubout)
+
+   SIGQUIT : constant Interrupt_ID :=
+     System.OS_Interface.SIGQUIT;     --  quit (ASCD FS)
+
+   SIGILL : constant Interrupt_ID :=
+     System.OS_Interface.SIGILL;      --  illegal instruction (not reset)
+
+   SIGTRAP : constant Interrupt_ID :=
+     System.OS_Interface.SIGTRAP;     --  trace trap (not reset)
+
+   SIGIOT : constant Interrupt_ID :=
+     System.OS_Interface.SIGIOT;      --  IOT instruction
+
+   SIGABRT : constant Interrupt_ID := --  used by abort,
+     System.OS_Interface.SIGABRT;     --  replace SIGIOT in the  future
+
+   SIGFPE : constant Interrupt_ID :=
+     System.OS_Interface.SIGFPE;      --  floating point exception
+
+   SIGKILL : constant Interrupt_ID :=
+     System.OS_Interface.SIGKILL;     --  kill (cannot be caught or ignored)
+
+   SIGBUS : constant Interrupt_ID :=
+     System.OS_Interface.SIGBUS;      --  bus error
+
+   SIGSEGV : constant Interrupt_ID :=
+     System.OS_Interface.SIGSEGV;     --  segmentation violation
+
+   SIGPIPE : constant Interrupt_ID := --  write on a pipe with
+     System.OS_Interface.SIGPIPE;     --  no one to read it
+
+   SIGALRM : constant Interrupt_ID :=
+     System.OS_Interface.SIGALRM;     --  alarm clock
+
+   SIGTERM : constant Interrupt_ID :=
+     System.OS_Interface.SIGTERM;     --  software termination signal from kill
+
+   SIGURG : constant Interrupt_ID :=
+     System.OS_Interface.SIGURG;      --  urgent condition on IO channel
+
+   SIGSTOP : constant Interrupt_ID :=
+     System.OS_Interface.SIGSTOP;     --  stop (cannot be caught or ignored)
+
+   SIGTSTP : constant Interrupt_ID :=
+     System.OS_Interface.SIGTSTP;     --  user stop requested from tty
+
+   SIGCONT : constant Interrupt_ID :=
+     System.OS_Interface.SIGCONT;     --  stopped process has been continued
+
+   SIGCHLD : constant Interrupt_ID :=
+     System.OS_Interface.SIGCHLD;     --  4.3BSD's/POSIX name for SIGCLD
+
+   SIGCLD : constant Interrupt_ID :=
+     System.OS_Interface.SIGCLD;      --  child status change
+
+   SIGTTIN : constant Interrupt_ID :=
+     System.OS_Interface.SIGTTIN;     --  background tty read attempted
+
+   SIGTTOU : constant Interrupt_ID :=
+     System.OS_Interface.SIGTTOU;     --  background tty write attempted
+
+   SIGIO : constant Interrupt_ID :=   --  input/output possible,
+     System.OS_Interface.SIGIO;       --  SIGPOLL alias (Solaris)
+
+   SIGXCPU : constant Interrupt_ID :=
+     System.OS_Interface.SIGXCPU;     --  CPU time limit exceeded
+
+   SIGXFSZ : constant Interrupt_ID :=
+     System.OS_Interface.SIGXFSZ;     --  filesize limit exceeded
+
+   SIGVTALRM : constant Interrupt_ID :=
+     System.OS_Interface.SIGVTALRM;   --  virtual timer expired
+
+   SIGPROF : constant Interrupt_ID :=
+     System.OS_Interface.SIGPROF;     --  profiling timer expired
+
+   SIGWINCH : constant Interrupt_ID :=
+     System.OS_Interface.SIGWINCH;    --  window size change
+
+   SIGUSR1 : constant Interrupt_ID :=
+     System.OS_Interface.SIGUSR1;     --  user defined signal 1
+
+   SIGUSR2 : constant Interrupt_ID :=
+     System.OS_Interface.SIGUSR2;     --  user defined signal 2
+
+end Ada.Interrupts.Names;
--- gcc/ada/adaint.c.orig
+++ gcc/ada/adaint.c
@@ -1077,6 +1077,7 @@
   strcpy (path, "GNAT-XXXXXX");
 
 #if (defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) \
+  || defined (DragonFly) \
   || defined (linux) || defined(__GLIBC__)) && !defined (__vxworks)
   return mkstemp (path);
 #elif defined (__Lynx__)
@@ -1227,7 +1228,49 @@
     free (pname);
   }
 
+#elif defined (__ANDROID__)
+
+  /*
+   * ext2 /ext3/ext4/fat16/fat32 have no path limits
+   * /data/local/tmp normally requires rooted devices, if it even exists
+   * /sdcard is the standard location for external storage.  Nativeactivity
+   * manifest needs to authorize its use, otherwise it might not have the
+   * proper permissions.
+   */
+
+  int testfd;
+  char *datadir = getenv ("ANDROID_DATA");
+
+  if (datadir == NULL)
+    strcpy (tmp_filename, "/data/local/tmp/gnat-XXXXXX");
+  else
+    sprintf (tmp_filename, "%s/local/tmp/gnat-XXXXXX", datadir);
+
+  testfd = mkstemp (tmp_filename);
+  if (testfd != -1)
+    {
+      close (testfd);
+      return;
+    }
+
+  char *sdcard = getenv ("EXTERNAL_STORAGE");
+
+  if (sdcard == NULL)
+    strcpy (tmp_filename, "/sdcard/gnat-XXXXXX");
+  else
+    sprintf (tmp_filename, "%s/gnat-XXXXXX", sdcard);
+
+  testfd = mkstemp (tmp_filename);
+  if (testfd != -1)
+    {
+      close (testfd);
+      return;
+    }
+
+  tmpnam (tmp_filename);
+
 #elif defined (linux) || defined (__FreeBSD__) || defined (__NetBSD__) \
+  || defined (__DragonFly__) \
   || defined (__OpenBSD__) || defined(__GLIBC__)
 #define MAX_SAFE_PATH 1000
   char *tmpdir = getenv ("TMPDIR");
@@ -2468,6 +2511,8 @@
   int cores = 1;
 
 #if defined (linux) || defined (sun) || defined (AIX) \
+    || defined (__FreeBSD__) || defined (__DragonFly__) \
+    || defined (__OpenBSD__) || defined (__NetBSD__) \
     || (defined (__alpha__)  && defined (_osf_)) || defined (__APPLE__)
   cores = (int) sysconf (_SC_NPROCESSORS_ONLN);
 
@@ -3530,26 +3575,214 @@
 }
 #endif
 
-#if defined (IS_CROSS)  \
-  || (! ((defined (sparc) || defined (i386)) && defined (sun) \
-      && defined (__SVR4)) \
-      && ! (defined (linux) && (defined (i386) || defined (__x86_64__))) \
-      && ! (defined (linux) && defined (__ia64__)) \
-      && ! (defined (linux) && defined (powerpc)) \
-      && ! defined (__FreeBSD__) \
-      && ! defined (__Lynx__) \
-      && ! defined (__hpux__) \
-      && ! defined (__APPLE__) \
-      && ! defined (_AIX) \
-      && ! (defined (__alpha__)  && defined (__osf__)) \
-      && ! defined (VMS) \
-      && ! defined (__MINGW32__) \
-      && ! (defined (__mips) && defined (__sgi)))
-
-/* Dummy function to satisfy g-trasym.o. See the preprocessor conditional
-   just above for a list of native platforms that provide a non-dummy
-   version of this procedure in libaddr2line.a.  */
+/* run-time symbolic traceback support */
+#if defined (__DragonFly__) \
+ || defined (__FreeBSD__) \
+ || defined (__OpenBSD__) \
+ || defined (__NetBSD__) \
+ || (defined (__sun__) && defined (__i386__) && defined (__SVR4))
+
+/* The above platforms use the external program /usr/bin/addr2line */
+#define EXTERNAL_SYMTRACE
+
+#elif defined (VMS) \
+   || defined (_AIX) \
+   || defined (__Lynx__) \
+   || defined (__hpux__)  \
+   || defined (__APPLE__) \
+   || defined (__MINGW32__) \
+   || (defined (__mips)    && defined (__sgi)) \
+   || (defined (__alpha__) && defined (__osf__)) \
+   || (defined (linux)     && defined (i386)) \
+   || (defined (linux)     && defined (powerpc)) \
+   || (defined (linux)     && defined (__ia64__)) \
+   || (defined (linux)     && defined (__x86_64__)) \
+   || (defined (__SVR4)    && defined (__sun__) && defined (sparc))
+
+/* The above platforms use the system library libaddr2line.a */
+#define NATIVE_SYMTRACE
+#endif
+
+#if defined (EXTERNAL_SYMTRACE) && !defined (IS_CROSS)
+
+/*
+  Copyright (C) 1999 by Juergen Pfeifer <juergen.pfeifer@gmx.net>
+  Ada for Linux Team (ALT)
+  Heavily modified by John Marino <http://www.dragonlace.net>
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the
+  "Software"), to deal in the Software without restriction, including
+  without limitation the rights to use, copy, modify, merge, publish,
+  distribute, distribute with modifications, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+  IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+  OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+  THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+  Except as contained in this notice, the name(s) of the above copyright
+  holders shall not be used in advertising or otherwise to promote the
+  sale, use or other dealings in this Software without prior written
+  authorization.
+*/
+
+#include <sys/types.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <signal.h>
+
+#define CLOSE_SENDPIPE close(sendpipe[0]); close(sendpipe[1])
+#define CLOSE_READPIPE close(readpipe[0]); close(readpipe[1])
+#define DUP2CLOSE(oldfd, newfd) dup2(oldfd, newfd); close(oldfd);
+#define RESTSIG sigaction(SIGPIPE,&oact,NULL)
+
+#define MAX_LINE     1024
+#define PARENT_READ  readpipe[0]
+#define CHILD_WRITE  readpipe[1]
+#define CHILD_READ   sendpipe[0]
+#define PARENT_WRITE sendpipe[1]
+
+#if defined (__sun__)
+#define ADDR2LINE_PROG	"/usr/gnu/bin/addr2line"
+#else
+#define ADDR2LINE_PROG	"/usr/bin/addr2line"
+#endif
+
+void
+convert_addresses (const char *file_name,
+		   void *addrs,
+		   int   n_addr,
+		   void *buf,
+		   int  *len)
+{
+  int max_len = *len;
+  pid_t childpid;
+
+  struct sigaction act, oact;
+
+  int sendpipe[2] = {-1,-1},	/* parent -> child */
+      readpipe[2] = {-1,-1};	/* parent <- child */
+
+  *len = 0;
+  act.sa_handler = SIG_IGN;
+  sigemptyset(&act.sa_mask);
+  act.sa_flags = 0;
+  if (sigaction(SIGPIPE,&act,&oact) < 0)
+    return;
+
+  if (pipe(sendpipe) < 0) { RESTSIG; return; }
+  if (pipe(readpipe) < 0) { CLOSE_SENDPIPE; RESTSIG; return; }
+  if ((childpid = fork()) < 0) {
+    CLOSE_READPIPE;
+    CLOSE_SENDPIPE;
+    RESTSIG;
+    return;
+  }
+
+  if (childpid == 0) {    /* child process */
+    close(PARENT_WRITE);
+    close(PARENT_READ);
+    if ((CHILD_READ != STDIN_FILENO) && (CHILD_WRITE != STDOUT_FILENO)) {
+      if ((CHILD_READ == STDOUT_FILENO) && (CHILD_WRITE == STDIN_FILENO)) {
+        const int temp_fd = dup(CHILD_WRITE);
+        close (CHILD_WRITE);
+        DUP2CLOSE (CHILD_READ, STDIN_FILENO);
+        DUP2CLOSE (temp_fd,    STDOUT_FILENO);
+      }
+      else if ((CHILD_READ == STDIN_FILENO) && (CHILD_WRITE > 1)) {
+        DUP2CLOSE (CHILD_WRITE, STDOUT_FILENO);
+      }
+      else if ((CHILD_READ > 1) && (CHILD_WRITE == STDOUT_FILENO)) {
+        DUP2CLOSE (CHILD_READ, STDIN_FILENO);
+      }
+      else if ((CHILD_READ > 1) && (CHILD_WRITE == STDIN_FILENO)) {
+        DUP2CLOSE (CHILD_WRITE, STDOUT_FILENO);
+        DUP2CLOSE (CHILD_READ,  STDIN_FILENO);
+      }
+      else {
+        /* CHILD_READ >= 1 and CHILD_WRITE > 1 */
+        DUP2CLOSE (CHILD_READ,  STDIN_FILENO);
+        DUP2CLOSE (CHILD_WRITE, STDOUT_FILENO);
+      }
+    }
+    /* As pointed out by Florian Weimer to JP, it is a security threat to call
+       the script with a user defined environment and using the path. That
+       would be Trojans pleasure.  Therefore the absolute path to addr2line
+       and an empty environment is used. That should be safe.
+    */
+    char *const argv[] = { "addr2line",
+                           "-e", file_name,
+                           "--demangle=gnat",
+                           "--functions",
+                           "--basenames",
+                           NULL };
+    char *const envp[] = { NULL };
+    if (execve(ADDR2LINE_PROG, argv, envp) < 0) {
+      close (CHILD_WRITE);
+      close (CHILD_READ);
+      RESTSIG;
+      exit (1);
+    }
+  }
+
+  /* Below this line is parent process */
+  int i, n;
+  char hex[16];
+  char line[MAX_LINE + 1];
+  char *p;
+  char *s = buf;
+  long *trace_address = addrs;
+
+  close(CHILD_WRITE);
+  close(CHILD_READ);
+
+  for(i=0; i < n_addr; i++) {
+    snprintf(hex,sizeof(hex),"%#lx\n",*trace_address);
+    write(PARENT_WRITE,hex,strlen(hex));
+    n = read(PARENT_READ,line,MAX_LINE);
+    if (n<=0)
+      break;
+
+    line[n]=0;
+    /* We have approx. 16 additional chars for "%#lx in " clause.
+       We use this info to prevent a buffer overrun. */
+    if (n + 16 + (*len) > max_len)
+      break;
+
+    p = strchr(line,'\n');
+    if (p) {
+      if (*(p+1)) {
+        *p = 0;
+        *len += snprintf(s, (max_len - (*len)), "%#lx in %s at %s",
+                         *trace_address, line, p+1);
+      }
+      else {
+        *len += snprintf(s, (max_len - (*len)), "%#lx at %s",
+                         *trace_address, line);
+      }
+      s = buf + (*len);
+    }
+    trace_address += 1;
+  }
+  close (PARENT_WRITE);
+  close (PARENT_READ);
+  RESTSIG;
+}
+
+#elif defined (IS_CROSS) || !defined (NATIVE_SYMTRACE)
 
+/* run-time symbolic traceback support
+   Dummy function to satisfy g-trasym.o. */
 void
 convert_addresses (const char *file_name ATTRIBUTE_UNUSED,
 		   void *addrs ATTRIBUTE_UNUSED,
--- gcc/ada/cio.c.orig
+++ gcc/ada/cio.c
@@ -46,7 +46,8 @@
 
 /* Don't use macros on GNU/Linux since they cause incompatible changes between
    glibc 2.0 and 2.1 */
-#ifdef linux
+/* Android is The exception because it uses the BIONIC library */
+#if defined(linux) && !defined(__ANDROID__)
 #undef putchar
 #undef getchar
 #undef fputc
--- gcc/ada/cstreams.c.orig
+++ gcc/ada/cstreams.c
@@ -54,9 +54,10 @@
 #include <unixlib.h>
 #endif
 
-#ifdef linux
+#if defined(linux) && !defined(__ANDROID__)
 /* Don't use macros on GNU/Linux since they cause incompatible changes between
    glibc 2.0 and 2.1 */
+/* Android is The exception because it uses the BIONIC library */
 
 #ifdef stderr
 #  undef stderr
@@ -187,7 +188,10 @@
 	  *p = '\\';
     }
 
-#elif defined (sgi) || defined (__FreeBSD__)
+#elif defined (sgi) \
+  || defined (__FreeBSD__) \
+  || defined (__DragonFly__) \
+  || defined (__OpenBSD__)
 
   /* Use realpath function which resolves links and references to . and ..
      on those Unix systems that support it. Note that GNU/Linux provides it but
--- gcc/ada/env.c.orig
+++ gcc/ada/env.c
@@ -188,7 +188,9 @@
       LIB$SIGNAL (status);
   }
 
-#elif (defined (__vxworks) && defined (__RTP__)) || defined (__APPLE__)
+#elif (defined (__vxworks) && defined (__RTP__)) \
+  || defined (__APPLE__) \
+  || defined (__OpenBSD__)
   setenv (name, value, 1);
 
 #else
@@ -310,6 +312,7 @@
   }
 #elif defined (__MINGW32__) || defined (__FreeBSD__) || defined (__APPLE__) \
    || (defined (__vxworks) && defined (__RTP__)) || defined (__CYGWIN__) \
+   || defined (__DragonFly__) \
    || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__rtems__)
   /* On Windows, FreeBSD and MacOS there is no function to clean all the
      environment but there is a "clean" way to unset a variable. So go
--- gcc/ada/errno.c.orig
+++ gcc/ada/errno.c
@@ -39,6 +39,7 @@
 #define _REENTRANT
 #define _THREAD_SAFE
 #define _SGI_MP_SOURCE
+#define GNAT_SET_ERRNO
 
 #ifdef MaRTE
 
@@ -52,6 +53,17 @@
 
 #endif
 
+#ifdef __ANDROID__
+
+/* The ANDROID errno.h file also defines __set_errno as an external variable
+   for use with syscalls.  It should not be referenced directly, but we are
+   going to do it anyway because the alternative solution is to rename all 
+   uses of __set_errno in GNAT. */
+
+#undef GNAT_SET_ERRNO   
+#endif
+
+
 #include <errno.h>
 int
 __get_errno(void)
@@ -59,8 +71,10 @@
   return errno;
 }
 
+#ifdef GNAT_SET_ERRNO
 void
 __set_errno(int err)
 {
   errno = err;
 }
+#endif
--- gcc/ada/g-comlin.adb.orig
+++ gcc/ada/g-comlin.adb
@@ -514,6 +514,7 @@
    begin
       Index_In_Switches := 0;
       Switch_Length     := 0;
+      Param             := Parameter_None;
 
       --  Remove all leading spaces first to make sure that Index points
       --  at the start of the first switch.
--- gcc/ada/g-expect.adb.orig
+++ gcc/ada/g-expect.adb
@@ -1332,15 +1332,20 @@
 
       --  The following commands are not executed on Unix systems, and are only
       --  required for Windows systems. We are now in the parent process.
+      --  Although the if-statement is redundant, it's here so the compiler
+      --  doesn't complain about uninitialized variables.
 
-      --  Restore the old descriptors
+      if No_Fork_On_Target then
 
-      Dup2 (Input,  GNAT.OS_Lib.Standin);
-      Dup2 (Output, GNAT.OS_Lib.Standout);
-      Dup2 (Error,  GNAT.OS_Lib.Standerr);
-      Close (Input);
-      Close (Output);
-      Close (Error);
+         --  Restore the old descriptors
+
+         Dup2 (Input,  GNAT.OS_Lib.Standin);
+         Dup2 (Output, GNAT.OS_Lib.Standout);
+         Dup2 (Error,  GNAT.OS_Lib.Standerr);
+         Close (Input);
+         Close (Output);
+         Close (Error);
+      end if;
    end Set_Up_Child_Communications;
 
    ---------------------------
--- /dev/null
+++ gcc/ada/g-socthi-bsd.adb
@@ -0,0 +1,376 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                    G N A T . S O C K E T S . T H I N                     --
+--                                                                          --
+--                                 B o d y                                  --
+--                                                                          --
+--                     Copyright (C) 2001-2010, AdaCore                     --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This package provides a target dependent thin interface to the sockets
+--  layer for use by the GNAT.Sockets package (g-socket.ads). This package
+--  should not be directly with'ed by an applications program.
+
+--  This is the *BSD version which uses fcntl rather than ioctl
+--  The constant SCON.Thread_Blocking_IO is always true (for all platforms, not
+--  just *BSD), so this binding is significantly simpler than the standard
+--  one it replaces.
+
+with GNAT.OS_Lib; use GNAT.OS_Lib;
+
+with Interfaces.C; use Interfaces.C;
+
+package body GNAT.Sockets.Thin is
+
+   Unknown_System_Error : constant C.Strings.chars_ptr :=
+                            C.Strings.New_String ("Unknown system error");
+
+   function Syscall_Accept
+     (S       : C.int;
+      Addr    : System.Address;
+      Addrlen : not null access C.int) return C.int;
+   pragma Import (C, Syscall_Accept, "accept");
+   --  The accept() function accepts a connection on a socket.  An incoming
+   --  connection is acknowledged and associated with an immediately created
+   --  socket.  The original socket is returned to the listening state.
+
+   function Syscall_Connect
+     (S       : C.int;
+      Name    : System.Address;
+      Namelen : C.int) return C.int;
+   pragma Import (C, Syscall_Connect, "connect");
+   --  The connect() system call initiates a connection on a socket.  If the
+   --  parameter S is of type SOCK_DGRAM then connect() permanently specifies
+   --  the peer to which datagrams are to be sent.  If S is type SOCK_STREAM
+   --  then connect() attempts to make a connection with another socket, which
+   --  is identified by the parameter Name.
+
+   function Syscall_Recv
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.int;
+      Flags : C.int) return C.int;
+   pragma Import (C, Syscall_Recv, "recv");
+   --  The recv() function receives a message from a socket.  The call can be
+   --  used on a connection mode socket or a bound, connectionless socket.  If
+   --  no messages are available at the socket, the recv() call waits for a
+   --  message to arrive unless the socket is non-blocking.  If a socket is
+   --  non-blocking, the call returns a -1 and ERRNO is set to EWOULDBLOCK.
+
+   function Syscall_Recvfrom
+     (S       : C.int;
+      Msg     : System.Address;
+      Len     : C.int;
+      Flags   : C.int;
+      From    : System.Address;
+      Fromlen : not null access C.int) return C.int;
+   pragma Import (C, Syscall_Recvfrom, "recvfrom");
+   --  The recvfrom() system call receives a message from a socket and captures
+   --  the address from which the data was sent.  It can be used to receive
+   --  data on an unconnected socket as well.  If no messages are available,
+   --  the call waits for a message to arrive on blocking sockets.  For
+   --  non-blocking sockets without messages, -1 is returned and ERRNO is set
+   --  to EAGAIN or EWOULDBLOCK.
+
+   function Syscall_Recvmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t;
+   pragma Import (C, Syscall_Recvmsg, "recvmsg");
+   --  The recvmsg call receives a message from a socket, and can be used to
+   --  receive data on an unconnected socket as well.  If no messages are
+   --  available, the call waits for a message to arrive on blocking sockets.
+   --  For non-blocking sockets without messages, -1 is returned and ERRNO is
+   --  set to EAGAIN or EWOULDBLOCK.
+
+   function Syscall_Sendmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t;
+   pragma Import (C, Syscall_Sendmsg, "sendmsg");
+   --  The sendmsg() function sends a message to a socket, and can be used with
+   --  unconnected sockets as well (the msg is ignored in this case).  The
+   --  function returns the number of bytes sent when successful, otherwise it
+   --  returns -1 and ERRNO is set (many possible values).
+
+   function Syscall_Sendto
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.int;
+      Flags : C.int;
+      To    : System.Address;
+      Tolen : C.int) return C.int;
+   pragma Import (C, Syscall_Sendto, "sendto");
+   --  The sendto() function only works for connected sockets and it initiates
+   --  the transmission of a message.  A successful call returns the numbers of
+   --  bytes sent, and a failure returns a -1 and ERRNO is set.
+
+   function Syscall_Socket
+     (Domain   : C.int;
+      Typ      : C.int;
+      Protocol : C.int) return C.int;
+   pragma Import (C, Syscall_Socket, "socket");
+   --  The socket() function is used to create an unbound socket and returns a
+   --  file descriptor that can be used with other socket functions.  Upon
+   --  failure, a -1 is returned and ERRNO is set.
+
+   procedure Disable_SIGPIPE (S : C.int);
+   pragma Import (C, Disable_SIGPIPE, "__gnat_disable_sigpipe");
+
+   procedure Disable_All_SIGPIPEs;
+   pragma Import (C, Disable_All_SIGPIPEs, "__gnat_disable_all_sigpipes");
+   --  Sets the process to ignore all SIGPIPE signals on platforms that
+   --  don't support Disable_SIGPIPE for particular streams.
+
+   function C_Fcntl
+     (Fd  : C.int;
+      Cmd : C.int;
+      Val : C.int) return C.int;
+   pragma Import (C, C_Fcntl, "fcntl");
+   --  The ioctl of 64-bit DragonFlyBSD, OpenBSD, and NetBSD does not support
+   --  setting a socket in non-blocking mode.  fcntl must be used instead.
+
+   --------------
+   -- C_Accept --
+   --------------
+
+   function C_Accept
+     (S       : C.int;
+      Addr    : System.Address;
+      Addrlen : not null access C.int) return C.int
+   is
+      Res : constant C.int := Syscall_Accept (S, Addr, Addrlen);
+   begin
+
+      Disable_SIGPIPE (Res);
+      return Res;
+
+   end C_Accept;
+
+   ---------------
+   -- C_Connect --
+   ---------------
+
+   function C_Connect
+     (S       : C.int;
+      Name    : System.Address;
+      Namelen : C.int) return C.int
+   is
+   begin
+
+      return Syscall_Connect (S, Name, Namelen);
+
+   end C_Connect;
+
+   ------------------
+   -- Socket_Ioctl --
+   ------------------
+
+   function Socket_Ioctl
+     (S   : C.int;
+      Req : C.int;
+      Arg : access C.int) return C.int
+   is
+      --  Currently all requests are of the FIONBIO type, so always calc flags
+      use Interfaces;
+      flags    : constant Unsigned_32 :=
+                          Unsigned_32 (C_Fcntl (S, SOSC.F_GETFL, 0));
+      nonblock : constant Unsigned_32 := Unsigned_32 (SOSC.FNDELAY);
+      enabled  : constant Boolean := Arg.all = 1;
+      newval   : C.int;
+   begin
+      if Req = SOSC.FIONBIO then
+         if enabled then
+            newval := C.int (flags or nonblock);
+         elsif (flags and nonblock) > 0 then
+            newval := C.int (flags - nonblock);
+         else
+            newval := C.int (flags);
+         end if;
+         return C_Fcntl (Fd => S, Cmd => SOSC.F_SETFL, Val => newval);
+      else
+         return C_Ioctl (Fd => S, Req => Req, Arg => Arg);
+      end if;
+   end Socket_Ioctl;
+
+   ------------
+   -- C_Recv --
+   ------------
+
+   function C_Recv
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.int;
+      Flags : C.int) return C.int
+   is
+   begin
+
+      return Syscall_Recv (S, Msg, Len, Flags);
+
+   end C_Recv;
+
+   ----------------
+   -- C_Recvfrom --
+   ----------------
+
+   function C_Recvfrom
+     (S       : C.int;
+      Msg     : System.Address;
+      Len     : C.int;
+      Flags   : C.int;
+      From    : System.Address;
+      Fromlen : not null access C.int) return C.int
+   is
+   begin
+
+      return Syscall_Recvfrom (S, Msg, Len, Flags, From, Fromlen);
+
+   end C_Recvfrom;
+
+   ---------------
+   -- C_Recvmsg --
+   ---------------
+
+   function C_Recvmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t
+   is
+   begin
+
+      return  Syscall_Recvmsg (S, Msg, Flags);
+
+   end C_Recvmsg;
+
+   ---------------
+   -- C_Sendmsg --
+   ---------------
+
+   function C_Sendmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t
+   is
+   begin
+
+      return Syscall_Sendmsg (S, Msg, Flags);
+
+   end C_Sendmsg;
+
+   --------------
+   -- C_Sendto --
+   --------------
+
+   function C_Sendto
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.int;
+      Flags : C.int;
+      To    : System.Address;
+      Tolen : C.int) return C.int
+   is
+   begin
+
+      return Syscall_Sendto (S, Msg, Len, Flags, To, Tolen);
+
+   end C_Sendto;
+
+   --------------
+   -- C_Socket --
+   --------------
+
+   function C_Socket
+     (Domain   : C.int;
+      Typ      : C.int;
+      Protocol : C.int) return C.int
+   is
+      Res : constant C.int := Syscall_Socket (Domain, Typ, Protocol);
+   begin
+
+      Disable_SIGPIPE (Res);
+      return Res;
+
+   end C_Socket;
+
+   --------------
+   -- Finalize --
+   --------------
+
+   procedure Finalize is
+   begin
+      null;
+   end Finalize;
+
+   -------------------------
+   -- Host_Error_Messages --
+   -------------------------
+
+   package body Host_Error_Messages is separate;
+
+   ----------------
+   -- Initialize --
+   ----------------
+
+   procedure Initialize is
+   begin
+      Disable_All_SIGPIPEs;
+   end Initialize;
+
+   --------------------
+   -- Signalling_Fds --
+   --------------------
+
+   package body Signalling_Fds is
+
+      --  In this default implementation, we use a C version of these
+      --  subprograms provided by socket.c.
+
+      function C_Create (Fds : not null access Fd_Pair) return C.int;
+      function C_Read (Rsig : C.int) return C.int;
+      function C_Write (Wsig : C.int) return C.int;
+      procedure C_Close (Sig : C.int);
+
+      pragma Import (C, C_Create, "__gnat_create_signalling_fds");
+      pragma Import (C, C_Read,   "__gnat_read_signalling_fd");
+      pragma Import (C, C_Write,  "__gnat_write_signalling_fd");
+      pragma Import (C, C_Close,  "__gnat_close_signalling_fd");
+
+      function Create
+        (Fds : not null access Fd_Pair) return C.int renames C_Create;
+      function Read (Rsig : C.int) return C.int renames C_Read;
+      function Write (Wsig : C.int) return C.int renames C_Write;
+      procedure Close (Sig : C.int) renames C_Close;
+
+   end Signalling_Fds;
+
+   --------------------------
+   -- Socket_Error_Message --
+   --------------------------
+
+   function Socket_Error_Message
+     (Errno : Integer) return C.Strings.chars_ptr
+   is separate;
+
+end GNAT.Sockets.Thin;
--- /dev/null
+++ gcc/ada/g-socthi-netbsd.adb
@@ -0,0 +1,378 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                    G N A T . S O C K E T S . T H I N                     --
+--                                                                          --
+--                                 B o d y                                  --
+--                                                                          --
+--                     Copyright (C) 2001-2010, AdaCore                     --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This package provides a target dependent thin interface to the sockets
+--  layer for use by the GNAT.Sockets package (g-socket.ads). This package
+--  should not be directly with'ed by an applications program.
+
+--  This is the NetBSD version which uses fcntl rather than ioctl
+--  The constant SCON.Thread_Blocking_IO is always true (for all platforms, not
+--  just *BSD), so this binding is significantly simpler than the standard
+--  one it replaces.
+--  NetBSD uses binary compatibility functions that are forcing the use of
+--  their own files rather than sharing the *BSD versions.
+
+with GNAT.OS_Lib; use GNAT.OS_Lib;
+
+with Interfaces.C; use Interfaces.C;
+
+package body GNAT.Sockets.Thin is
+
+   Unknown_System_Error : constant C.Strings.chars_ptr :=
+                            C.Strings.New_String ("Unknown system error");
+
+   function Syscall_Accept
+     (S       : C.int;
+      Addr    : System.Address;
+      Addrlen : not null access C.int) return C.int;
+   pragma Import (C, Syscall_Accept, "accept");
+   --  The accept() function accepts a connection on a socket.  An incoming
+   --  connection is acknowledged and associated with an immediately created
+   --  socket.  The original socket is returned to the listening state.
+
+   function Syscall_Connect
+     (S       : C.int;
+      Name    : System.Address;
+      Namelen : C.int) return C.int;
+   pragma Import (C, Syscall_Connect, "connect");
+   --  The connect() system call initiates a connection on a socket.  If the
+   --  parameter S is of type SOCK_DGRAM then connect() permanently specifies
+   --  the peer to which datagrams are to be sent.  If S is type SOCK_STREAM
+   --  then connect() attempts to make a connection with another socket, which
+   --  is identified by the parameter Name.
+
+   function Syscall_Recv
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.int;
+      Flags : C.int) return C.int;
+   pragma Import (C, Syscall_Recv, "recv");
+   --  The recv() function receives a message from a socket.  The call can be
+   --  used on a connection mode socket or a bound, connectionless socket.  If
+   --  no messages are available at the socket, the recv() call waits for a
+   --  message to arrive unless the socket is non-blocking.  If a socket is
+   --  non-blocking, the call returns a -1 and ERRNO is set to EWOULDBLOCK.
+
+   function Syscall_Recvfrom
+     (S       : C.int;
+      Msg     : System.Address;
+      Len     : C.int;
+      Flags   : C.int;
+      From    : System.Address;
+      Fromlen : not null access C.int) return C.int;
+   pragma Import (C, Syscall_Recvfrom, "recvfrom");
+   --  The recvfrom() system call receives a message from a socket and captures
+   --  the address from which the data was sent.  It can be used to receive
+   --  data on an unconnected socket as well.  If no messages are available,
+   --  the call waits for a message to arrive on blocking sockets.  For
+   --  non-blocking sockets without messages, -1 is returned and ERRNO is set
+   --  to EAGAIN or EWOULDBLOCK.
+
+   function Syscall_Recvmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t;
+   pragma Import (C, Syscall_Recvmsg, "recvmsg");
+   --  The recvmsg call receives a message from a socket, and can be used to
+   --  receive data on an unconnected socket as well.  If no messages are
+   --  available, the call waits for a message to arrive on blocking sockets.
+   --  For non-blocking sockets without messages, -1 is returned and ERRNO is
+   --  set to EAGAIN or EWOULDBLOCK.
+
+   function Syscall_Sendmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t;
+   pragma Import (C, Syscall_Sendmsg, "sendmsg");
+   --  The sendmsg() function sends a message to a socket, and can be used with
+   --  unconnected sockets as well (the msg is ignored in this case).  The
+   --  function returns the number of bytes sent when successful, otherwise it
+   --  returns -1 and ERRNO is set (many possible values).
+
+   function Syscall_Sendto
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.int;
+      Flags : C.int;
+      To    : System.Address;
+      Tolen : C.int) return C.int;
+   pragma Import (C, Syscall_Sendto, "sendto");
+   --  The sendto() function only works for connected sockets and it initiates
+   --  the transmission of a message.  A successful call returns the numbers of
+   --  bytes sent, and a failure returns a -1 and ERRNO is set.
+
+   function Syscall_Socket
+     (Domain   : C.int;
+      Typ      : C.int;
+      Protocol : C.int) return C.int;
+   pragma Import (C, Syscall_Socket, "__socket30");
+   --  The socket() function is used to create an unbound socket and returns a
+   --  file descriptor that can be used with other socket functions.  Upon
+   --  failure, a -1 is returned and ERRNO is set.
+
+   procedure Disable_SIGPIPE (S : C.int);
+   pragma Import (C, Disable_SIGPIPE, "__gnat_disable_sigpipe");
+
+   procedure Disable_All_SIGPIPEs;
+   pragma Import (C, Disable_All_SIGPIPEs, "__gnat_disable_all_sigpipes");
+   --  Sets the process to ignore all SIGPIPE signals on platforms that
+   --  don't support Disable_SIGPIPE for particular streams.
+
+   function C_Fcntl
+     (Fd  : C.int;
+      Cmd : C.int;
+      Val : C.int) return C.int;
+   pragma Import (C, C_Fcntl, "fcntl");
+   --  The ioctl of 64-bit DragonFlyBSD, OpenBSD, and NetBSD does not support
+   --  setting a socket in non-blocking mode.  fcntl must be used instead.
+
+   --------------
+   -- C_Accept --
+   --------------
+
+   function C_Accept
+     (S       : C.int;
+      Addr    : System.Address;
+      Addrlen : not null access C.int) return C.int
+   is
+      Res : constant C.int := Syscall_Accept (S, Addr, Addrlen);
+   begin
+
+      Disable_SIGPIPE (Res);
+      return Res;
+
+   end C_Accept;
+
+   ---------------
+   -- C_Connect --
+   ---------------
+
+   function C_Connect
+     (S       : C.int;
+      Name    : System.Address;
+      Namelen : C.int) return C.int
+   is
+   begin
+
+      return Syscall_Connect (S, Name, Namelen);
+
+   end C_Connect;
+
+   ------------------
+   -- Socket_Ioctl --
+   ------------------
+
+   function Socket_Ioctl
+     (S   : C.int;
+      Req : C.int;
+      Arg : access C.int) return C.int
+   is
+      --  Currently all requests are of the FIONBIO type, so always calc flags
+      use Interfaces;
+      flags    : constant Unsigned_32 :=
+                          Unsigned_32 (C_Fcntl (S, SOSC.F_GETFL, 0));
+      nonblock : constant Unsigned_32 := Unsigned_32 (SOSC.FNDELAY);
+      enabled  : constant Boolean := Arg.all = 1;
+      newval   : C.int;
+   begin
+      if Req = SOSC.FIONBIO then
+         if enabled then
+            newval := C.int (flags or nonblock);
+         elsif (flags and nonblock) > 0 then
+            newval := C.int (flags - nonblock);
+         else
+            newval := C.int (flags);
+         end if;
+         return C_Fcntl (Fd => S, Cmd => SOSC.F_SETFL, Val => newval);
+      else
+         return C_Ioctl (Fd => S, Req => Req, Arg => Arg);
+      end if;
+   end Socket_Ioctl;
+
+   ------------
+   -- C_Recv --
+   ------------
+
+   function C_Recv
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.int;
+      Flags : C.int) return C.int
+   is
+   begin
+
+      return Syscall_Recv (S, Msg, Len, Flags);
+
+   end C_Recv;
+
+   ----------------
+   -- C_Recvfrom --
+   ----------------
+
+   function C_Recvfrom
+     (S       : C.int;
+      Msg     : System.Address;
+      Len     : C.int;
+      Flags   : C.int;
+      From    : System.Address;
+      Fromlen : not null access C.int) return C.int
+   is
+   begin
+
+      return Syscall_Recvfrom (S, Msg, Len, Flags, From, Fromlen);
+
+   end C_Recvfrom;
+
+   ---------------
+   -- C_Recvmsg --
+   ---------------
+
+   function C_Recvmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t
+   is
+   begin
+
+      return  Syscall_Recvmsg (S, Msg, Flags);
+
+   end C_Recvmsg;
+
+   ---------------
+   -- C_Sendmsg --
+   ---------------
+
+   function C_Sendmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t
+   is
+   begin
+
+      return Syscall_Sendmsg (S, Msg, Flags);
+
+   end C_Sendmsg;
+
+   --------------
+   -- C_Sendto --
+   --------------
+
+   function C_Sendto
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.int;
+      Flags : C.int;
+      To    : System.Address;
+      Tolen : C.int) return C.int
+   is
+   begin
+
+      return Syscall_Sendto (S, Msg, Len, Flags, To, Tolen);
+
+   end C_Sendto;
+
+   --------------
+   -- C_Socket --
+   --------------
+
+   function C_Socket
+     (Domain   : C.int;
+      Typ      : C.int;
+      Protocol : C.int) return C.int
+   is
+      Res : constant C.int := Syscall_Socket (Domain, Typ, Protocol);
+   begin
+
+      Disable_SIGPIPE (Res);
+      return Res;
+
+   end C_Socket;
+
+   --------------
+   -- Finalize --
+   --------------
+
+   procedure Finalize is
+   begin
+      null;
+   end Finalize;
+
+   -------------------------
+   -- Host_Error_Messages --
+   -------------------------
+
+   package body Host_Error_Messages is separate;
+
+   ----------------
+   -- Initialize --
+   ----------------
+
+   procedure Initialize is
+   begin
+      Disable_All_SIGPIPEs;
+   end Initialize;
+
+   --------------------
+   -- Signalling_Fds --
+   --------------------
+
+   package body Signalling_Fds is
+
+      --  In this default implementation, we use a C version of these
+      --  subprograms provided by socket.c.
+
+      function C_Create (Fds : not null access Fd_Pair) return C.int;
+      function C_Read (Rsig : C.int) return C.int;
+      function C_Write (Wsig : C.int) return C.int;
+      procedure C_Close (Sig : C.int);
+
+      pragma Import (C, C_Create, "__gnat_create_signalling_fds");
+      pragma Import (C, C_Read,   "__gnat_read_signalling_fd");
+      pragma Import (C, C_Write,  "__gnat_write_signalling_fd");
+      pragma Import (C, C_Close,  "__gnat_close_signalling_fd");
+
+      function Create
+        (Fds : not null access Fd_Pair) return C.int renames C_Create;
+      function Read (Rsig : C.int) return C.int renames C_Read;
+      function Write (Wsig : C.int) return C.int renames C_Write;
+      procedure Close (Sig : C.int) renames C_Close;
+
+   end Signalling_Fds;
+
+   --------------------------
+   -- Socket_Error_Message --
+   --------------------------
+
+   function Socket_Error_Message
+     (Errno : Integer) return C.Strings.chars_ptr
+   is separate;
+
+end GNAT.Sockets.Thin;
--- /dev/null
+++ gcc/ada/g-socthi-netbsd6.ads
@@ -0,0 +1,260 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                    G N A T . S O C K E T S . T H I N                     --
+--                                                                          --
+--                                 S p e c                                  --
+--                                                                          --
+--                     Copyright (C) 2001-2010, AdaCore                     --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This package provides a target dependent thin interface to the sockets
+--  layer for use by the GNAT.Sockets package (g-socket.ads). This package
+--  should not be directly with'ed by an applications program.
+
+--  This is the NetBSD 6+ version
+
+with Interfaces.C.Strings;
+
+with GNAT.OS_Lib;
+with GNAT.Sockets.Thin_Common;
+
+with System;
+with System.CRTL;
+
+package GNAT.Sockets.Thin is
+
+   --  This package is intended for hosts implementing BSD sockets with a
+   --  standard interface. It will be used as a default for all the platforms
+   --  that do not have a specific version of this file.
+
+   use Thin_Common;
+
+   package C renames Interfaces.C;
+
+   use type System.CRTL.ssize_t;
+
+   function Socket_Errno return Integer renames GNAT.OS_Lib.Errno;
+   --  Returns last socket error number
+
+   function Socket_Error_Message (Errno : Integer) return C.Strings.chars_ptr;
+   --  Returns the error message string for the error number Errno. If Errno is
+   --  not known, returns "Unknown system error".
+
+   function Host_Errno return Integer;
+   pragma Import (C, Host_Errno, "__gnat_get_h_errno");
+   --  Returns last host error number
+
+   package Host_Error_Messages is
+
+      function Host_Error_Message
+        (H_Errno : Integer) return C.Strings.chars_ptr;
+      --  Returns the error message string for the host error number H_Errno.
+      --  If H_Errno is not known, returns "Unknown system error".
+
+   end Host_Error_Messages;
+
+   --------------------------------
+   -- Standard library functions --
+   --------------------------------
+
+   function C_Accept
+     (S       : C.int;
+      Addr    : System.Address;
+      Addrlen : not null access C.int) return C.int;
+
+   function C_Bind
+     (S       : C.int;
+      Name    : System.Address;
+      Namelen : C.int) return C.int;
+
+   function C_Close
+     (Fd : C.int) return C.int;
+
+   function C_Connect
+     (S       : C.int;
+      Name    : System.Address;
+      Namelen : C.int) return C.int;
+
+   function C_Gethostname
+     (Name    : System.Address;
+      Namelen : C.int) return C.int;
+
+   function C_Getpeername
+     (S       : C.int;
+      Name    : System.Address;
+      Namelen : not null access C.int) return C.int;
+
+   function C_Getsockname
+     (S       : C.int;
+      Name    : System.Address;
+      Namelen : not null access C.int) return C.int;
+
+   function C_Getsockopt
+     (S       : C.int;
+      Level   : C.int;
+      Optname : C.int;
+      Optval  : System.Address;
+      Optlen  : not null access C.int) return C.int;
+
+   function Socket_Ioctl
+     (S   : C.int;
+      Req : C.int;
+      Arg : access C.int) return C.int;
+
+   function C_Listen
+     (S       : C.int;
+      Backlog : C.int) return C.int;
+
+   function C_Recv
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.int;
+      Flags : C.int) return C.int;
+
+   function C_Recvfrom
+     (S       : C.int;
+      Msg     : System.Address;
+      Len     : C.int;
+      Flags   : C.int;
+      From    : System.Address;
+      Fromlen : not null access C.int) return C.int;
+
+   function C_Recvmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t;
+
+   function C_Select
+     (Nfds      : C.int;
+      Readfds   : access Fd_Set;
+      Writefds  : access Fd_Set;
+      Exceptfds : access Fd_Set;
+      Timeout   : Timeval_Access) return C.int;
+
+   function C_Sendmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t;
+
+   function C_Sendto
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.int;
+      Flags : C.int;
+      To    : System.Address;
+      Tolen : C.int) return C.int;
+
+   function C_Setsockopt
+     (S       : C.int;
+      Level   : C.int;
+      Optname : C.int;
+      Optval  : System.Address;
+      Optlen  : C.int) return C.int;
+
+   function C_Shutdown
+     (S   : C.int;
+      How : C.int) return C.int;
+
+   function C_Socket
+     (Domain   : C.int;
+      Typ      : C.int;
+      Protocol : C.int) return C.int;
+
+   function C_System
+     (Command : System.Address) return C.int;
+
+   -------------------------------------------------------
+   -- Signalling file descriptors for selector abortion --
+   -------------------------------------------------------
+
+   package Signalling_Fds is
+
+      function Create (Fds : not null access Fd_Pair) return C.int;
+      pragma Convention (C, Create);
+      --  Create a pair of connected descriptors suitable for use with C_Select
+      --  (used for signalling in Selector objects).
+
+      function Read (Rsig : C.int) return C.int;
+      pragma Convention (C, Read);
+      --  Read one byte of data from rsig, the read end of a pair of signalling
+      --  fds created by Create_Signalling_Fds.
+
+      function Write (Wsig : C.int) return C.int;
+      pragma Convention (C, Write);
+      --  Write one byte of data to wsig, the write end of a pair of signalling
+      --  fds created by Create_Signalling_Fds.
+
+      procedure Close (Sig : C.int);
+      pragma Convention (C, Close);
+      --  Close one end of a pair of signalling fds (ignoring any error)
+
+   end Signalling_Fds;
+
+   -------------------------------------------
+   -- Nonreentrant network databases access --
+   -------------------------------------------
+
+   --  The following are used only on systems that have nonreentrant
+   --  getXXXbyYYY functions, and do NOT have corresponding getXXXbyYYY_
+   --  functions. Currently, LynxOS is the only such system.
+
+   function Nonreentrant_Gethostbyname
+     (Name : C.char_array) return Hostent_Access;
+
+   function Nonreentrant_Gethostbyaddr
+     (Addr      : System.Address;
+      Addr_Len  : C.int;
+      Addr_Type : C.int) return Hostent_Access;
+
+   function Nonreentrant_Getservbyname
+     (Name  : C.char_array;
+      Proto : C.char_array) return Servent_Access;
+
+   function Nonreentrant_Getservbyport
+     (Port  : C.int;
+      Proto : C.char_array) return Servent_Access;
+
+   procedure Initialize;
+   procedure Finalize;
+
+private
+   pragma Import (C, C_Bind, "bind");
+   pragma Import (C, C_Close, "close");
+   pragma Import (C, C_Gethostname, "gethostname");
+   pragma Import (C, C_Getpeername, "getpeername");
+   pragma Import (C, C_Getsockname, "getsockname");
+   pragma Import (C, C_Getsockopt, "getsockopt");
+   pragma Import (C, C_Listen, "listen");
+   pragma Import (C, C_Select, "__select50");
+   pragma Import (C, C_Setsockopt, "setsockopt");
+   pragma Import (C, C_Shutdown, "shutdown");
+   pragma Import (C, C_System, "system");
+
+   pragma Import (C, Nonreentrant_Gethostbyname, "gethostbyname");
+   pragma Import (C, Nonreentrant_Gethostbyaddr, "gethostbyaddr");
+   pragma Import (C, Nonreentrant_Getservbyname, "getservbyname");
+   pragma Import (C, Nonreentrant_Getservbyport, "getservbyport");
+
+end GNAT.Sockets.Thin;
--- /dev/null
+++ gcc/ada/g-trasym-bsd.adb
@@ -0,0 +1,150 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT RUN-TIME COMPONENTS                         --
+--                                                                          --
+--             G N A T . T R A C E B A C K . S Y M B O L I C                --
+--                                                                          --
+--                                 B o d y                                  --
+--                                                                          --
+--                     Copyright (C) 1999-2009, AdaCore                     --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  Run-time symbolic traceback support
+--  This file is based on the work by Juergen Pfiefer which is still used
+--  today to provide symbolic traceback support for gnu/kFreeBSD.
+--  Incorporated in GNAT-AUX by John Marino <http://www.dragonlace.net>
+
+with System.Soft_Links;
+with Ada.Exceptions.Traceback; use Ada.Exceptions.Traceback;
+
+package body GNAT.Traceback.Symbolic is
+
+   package TSL renames System.Soft_Links;
+
+   --  To perform the raw addresses to symbolic form translation we rely on a
+   --  libaddr2line symbolizer which examines debug info from a provided
+   --  executable file name, and an absolute path is needed to ensure the file
+   --  is always found. This is "__gnat_locate_exec_on_path (gnat_argv [0])"
+   --  for our executable file, a fairly heavy operation so we cache the
+   --  result.
+
+   Exename : System.Address;
+   --  Pointer to the name of the executable file to be used on all
+   --  invocations of the libaddr2line symbolization service.
+
+   Exename_Resolved : Boolean := False;
+   --  Flag to indicate whether we have performed the executable file name
+   --  resolution already. Relying on a not null Exename for this purpose
+   --  would be potentially inefficient as this is what we will get if the
+   --  resolution attempt fails.
+
+   ------------------------
+   -- Symbolic_Traceback --
+   ------------------------
+
+   function Symbolic_Traceback (Traceback : Tracebacks_Array) return String is
+
+      procedure convert_addresses
+        (filename : System.Address;
+         addrs    : System.Address;
+         n_addrs  : Integer;
+         buf      : System.Address;
+         len      : System.Address);
+      pragma Import (C, convert_addresses, "convert_addresses");
+      --  This is the procedure version of the Ada-aware addr2line. It places
+      --  in BUF a string representing the symbolic translation of the N_ADDRS
+      --  raw addresses provided in ADDRS, looked up in debug information from
+      --  FILENAME. LEN points to an integer which contains the size of the
+      --  BUF buffer at input and the result length at output.
+      --
+      --  Note that this procedure is *not* thread-safe.
+
+      type Argv_Array is array (0 .. 0) of System.Address;
+      gnat_argv : access Argv_Array;
+      pragma Import (C, gnat_argv, "gnat_argv");
+
+      function locate_exec_on_path
+        (c_exename : System.Address) return System.Address;
+      pragma Import (C, locate_exec_on_path, "__gnat_locate_exec_on_path");
+
+      B_Size : constant Integer := 256 * Traceback'Length;
+      Len    : Integer := B_Size;
+      Res    : String (1 .. B_Size);
+
+      use type System.Address;
+
+   begin
+      --  The symbolic translation of an empty set of addresses is an empty
+      --  string.
+
+      if Traceback'Length = 0 then
+         return "";
+      end if;
+
+      --  If our input set of raw addresses is not empty, resort to the
+      --  libaddr2line service to symbolize it all.
+
+      --  Compute, cache and provide the absolute path to our executable file
+      --  name as the binary file where the relevant debug information is to be
+      --  found. If the executable file name resolution fails, we have no
+      --  sensible basis to invoke the symbolizer at all.
+
+      --  Protect all this against concurrent accesses explicitly, as the
+      --  underlying services are potentially thread unsafe.
+
+      TSL.Lock_Task.all;
+
+      if not Exename_Resolved then
+         Exename := locate_exec_on_path (gnat_argv (0));
+         Exename_Resolved := True;
+      end if;
+
+      if Exename /= System.Null_Address then
+         Len := Res'Length;
+         convert_addresses
+           (Exename, Traceback'Address, Traceback'Length,
+            Res (1)'Address, Len'Address);
+      end if;
+
+      TSL.Unlock_Task.all;
+
+      --  Return what the addr2line symbolizer has produced if we have called
+      --  it (the executable name resolution succeeded), or an empty string
+      --  otherwise.
+
+      if Exename /= System.Null_Address then
+         return Res (1 .. Len);
+      else
+         return "";
+      end if;
+
+   end Symbolic_Traceback;
+
+   function Symbolic_Traceback (E : Exception_Occurrence) return String is
+   begin
+      return Symbolic_Traceback (Tracebacks (E));
+   end Symbolic_Traceback;
+
+end GNAT.Traceback.Symbolic;
--- gcc/ada/gnatchop.adb.orig
+++ gcc/ada/gnatchop.adb
@@ -45,7 +45,7 @@
    Config_File_Name : constant String_Access := new String'("gnat.adc");
    --  The name of the file holding the GNAT configuration pragmas
 
-   Gcc : String_Access := new String'("gcc");
+   Gcc : String_Access := new String'("ada");
    --  May be modified by switch --GCC=
 
    Gcc_Set : Boolean := False;
--- gcc/ada/gnatlink.adb.orig
+++ gcc/ada/gnatlink.adb
@@ -137,7 +137,7 @@
    --  This table collects the arguments to be passed to compile the binder
    --  generated file.
 
-   Gcc : String_Access := Program_Name ("gcc", "gnatlink");
+   Gcc : String_Access := Program_Name ("ada", "gnatlink");
 
    Read_Mode : constant String := "r" & ASCII.NUL;
 
--- gcc/ada/gsocket.h.orig
+++ gcc/ada/gsocket.h
@@ -203,8 +203,19 @@
 #include <netdb.h>
 #endif
 
-#if defined (_AIX) || defined (__FreeBSD__) || defined (__hpux__) || \
-    defined (__osf__) || defined (_WIN32) || defined (__APPLE__)
+#if defined(__ANDROID__)
+#include <sys/select.h>
+#endif
+
+#if defined (_AIX) \
+ || defined (__FreeBSD__) \
+ || defined (__DragonFly__) \
+ || defined (__NetBSD__) \
+ || defined (__OpenBSD__) \
+ || defined (__hpux__) \
+ || defined (__osf__) \
+ || defined (_WIN32) \
+ || defined (__APPLE__)
 # define HAVE_THREAD_SAFE_GETxxxBYyyy 1
 
 #elif defined (sgi) || defined (linux) || defined (__GLIBC__) || \
@@ -236,7 +247,13 @@
 # endif
 #endif
 
-#if defined (__FreeBSD__) || defined (__vxworks) || defined(__rtems__)
+#if defined (__FreeBSD__) \
+ || defined (__DragonFly__) \
+ || defined (__OpenBSD__) \
+ || defined (__NetBSD__) \
+ || defined (__ANDROID__) \
+ || defined (__vxworks) \
+ || defined(__rtems__)
 # define Has_Sockaddr_Len 1
 #else
 # define Has_Sockaddr_Len 0
--- gcc/ada/init.c.orig
+++ gcc/ada/init.c
@@ -536,7 +536,7 @@
 /* GNU/Linux Section */
 /*********************/
 
-#elif defined (linux)
+#elif defined (linux) && !defined(__ANDROID__)
 
 #include <signal.h>
 
@@ -1787,7 +1787,7 @@
 /* FreeBSD Section */
 /*******************/
 
-#elif defined (__FreeBSD__)
+#elif defined (__FreeBSD__)  || defined (__DragonFly__)
 
 #include <signal.h>
 #include <sys/ucontext.h>
@@ -1832,7 +1832,7 @@
 }
 
 void
-__gnat_install_handler ()
+__gnat_install_handler (void)
 {
   struct sigaction act;
 
@@ -1854,6 +1854,77 @@
 }
 
 /*******************/
+/* Android Section */
+/*******************/
+
+#elif defined(__ANDROID__)
+
+#include <signal.h>
+
+static void
+__gnat_error_handler (int             sig,
+		      struct siginfo *si          ATTRIBUTE_UNUSED,
+		      void           *ucontext    ATTRIBUTE_UNUSED)
+{
+  struct Exception_Data *exception;
+  const char *msg;
+
+  switch (sig)
+    {
+    case SIGFPE:
+      exception = &constraint_error;
+      msg = "SIGFPE";
+      break;
+
+    case SIGILL:
+      exception = &constraint_error;
+      msg = "SIGILL";
+      break;
+      
+    case SIGSEGV:
+      exception = &storage_error;
+      msg = "stack overflow or erroneous memory access";
+      break;
+
+    case SIGBUS:
+      exception = &constraint_error;
+      msg = "SIGBUS";
+      break;
+
+    default:
+      exception = &program_error;
+      msg = "unhandled signal";
+    }
+
+  Raise_From_Signal_Handler (exception, msg);
+}
+
+void
+__gnat_install_handler (void)
+{
+  struct sigaction act;
+
+  act.sa_sigaction = __gnat_error_handler;
+  act.sa_flags = SA_NODEFER | SA_RESTART | SA_SIGINFO;
+  sigemptyset (&act.sa_mask);
+
+  /* Do not install handlers if interrupt state is "System".  */
+  if (__gnat_get_interrupt_state (SIGABRT) != 's') 
+    sigaction (SIGABRT, &act, NULL);
+  if (__gnat_get_interrupt_state (SIGFPE)  != 's')
+    sigaction (SIGFPE,  &act, NULL);
+  if (__gnat_get_interrupt_state (SIGILL)  != 's')
+    sigaction (SIGILL,  &act, NULL);
+  if (__gnat_get_interrupt_state (SIGBUS)  != 's')
+    sigaction (SIGBUS,  &act, NULL);
+  if (__gnat_get_interrupt_state (SIGSEGV) != 's')
+    sigaction (SIGSEGV, &act, NULL);
+
+  __gnat_handler_installed = 1;
+}
+
+
+/*******************/
 /* VxWorks Section */
 /*******************/
 
@@ -2416,9 +2487,13 @@
    initialization of the FP processor.  This version is used under INTERIX
    and WIN32.  */
 
-#if defined (_WIN32) || defined (__INTERIX) \
-  || defined (__Lynx__) || defined(__NetBSD__) || defined(__FreeBSD__) \
-  || defined (__OpenBSD__)
+#if defined (_WIN32) \
+ || defined (__INTERIX) \
+ || defined (__Lynx__) \
+ || defined (__NetBSD__) \
+ || defined (__FreeBSD__) \
+ || defined (__DragonFly__) \
+ || defined (__OpenBSD__)
 
 #define HAVE_GNAT_INIT_FLOAT
 
--- gcc/ada/initialize.c.orig
+++ gcc/ada/initialize.c
@@ -257,8 +257,11 @@
 /* __gnat_initialize (init_float version) */
 /******************************************/
 
-#elif defined (__Lynx__) || defined (__FreeBSD__) || defined(__NetBSD__) \
-  || defined (__OpenBSD__)
+#elif defined (__Lynx__) \
+   || defined (__FreeBSD__) \
+   || defined (__DragonFly__) \
+   || defined (__NetBSD__) \
+   || defined (__OpenBSD__)
 
 extern void __gnat_init_float (void);
 
--- gcc/ada/link.c.orig
+++ gcc/ada/link.c
@@ -133,7 +133,10 @@
 unsigned char __gnat_separate_run_path_options = 0;
 const char *__gnat_default_libgcc_subdir = "lib";
 
-#elif defined (__FreeBSD__)
+#elif defined (__FreeBSD__) \
+   || defined (__DragonFly__) \
+   || defined (__OpenBSD__) \
+   || defined (__NetBSD__)
 const char *__gnat_object_file_option = "-Wl,@";
 const char *__gnat_run_path_option = "-Wl,-rpath,";
 char __gnat_shared_libgnat_default = STATIC;
--- gcc/ada/make.adb.orig
+++ gcc/ada/make.adb
@@ -669,7 +669,7 @@
    -- Compiler, Binder & Linker Data and Subprograms --
    ----------------------------------------------------
 
-   Gcc          : String_Access := Program_Name ("gcc", "gnatmake");
+   Gcc          : String_Access := Program_Name ("ada", "gnatmake");
    Original_Gcc : constant String_Access := Gcc;
    --  Original_Gcc is used to check if Gcc has been modified by a switch
    --  --GCC=, so that for VM platforms, it is not modified again, as it can
--- gcc/ada/mlib-prj.adb.orig
+++ gcc/ada/mlib-prj.adb
@@ -339,6 +339,11 @@
 
       Foreign_Sources : Boolean;
 
+      Rpath_Disabled : Boolean := False;
+      --  If -R is passed through the library options for the linker, it will
+      --  prevent the implemented libraries portion of the rpath switch from
+      --  being built, even if the linker is capable of supporting rpath.
+
       Rpath : String_Access := null;
       --  Allocated only if Path Option is supported
 
@@ -782,7 +787,7 @@
             Opts.Table (Opts.Last) :=
               new String'("-L" & Name_Buffer (1 .. Name_Len));
 
-            if Path_Option /= null then
+            if not Rpath_Disabled and then Path_Option /= null then
                Add_Rpath (Name_Buffer (1 .. Name_Len));
             end if;
 
@@ -1323,9 +1328,13 @@
                   Get_Name_String (Element.Value);
 
                   if Name_Len /= 0 then
-                     Opts.Increment_Last;
-                     Opts.Table (Opts.Last) :=
-                       new String'(Name_Buffer (1 .. Name_Len));
+                     if Name_Buffer (1 .. Name_Len) = "-R" then
+                        Rpath_Disabled := True;
+                     else
+                        Opts.Increment_Last;
+                        Opts.Table (Opts.Last) :=
+                          new String'(Name_Buffer (1 .. Name_Len));
+                     end if;
                   end if;
 
                   Current := Element.Next;
--- gcc/ada/mlib-utl.adb.orig
+++ gcc/ada/mlib-utl.adb
@@ -433,7 +433,7 @@
       if Driver_Name = No_Name then
          if Gcc_Exec = null then
             if Gcc_Name = null then
-               Gcc_Name := Osint.Program_Name ("gcc", "gnatmake");
+               Gcc_Name := Osint.Program_Name ("ada", "gnatmake");
             end if;
 
             Gcc_Exec := Locate_Exec_On_Path (Gcc_Name.all);
--- gcc/ada/prj-makr.adb.orig
+++ gcc/ada/prj-makr.adb
@@ -114,7 +114,7 @@
 
    procedure Dup2 (Old_Fd, New_Fd : File_Descriptor);
 
-   Gcc      : constant String := "gcc";
+   Gcc      : constant String := "ada";
    Gcc_Path : String_Access := null;
 
    Non_Empty_Node : constant Project_Node_Id := 1;
--- gcc/ada/s-fileio.adb.orig
+++ gcc/ada/s-fileio.adb
@@ -231,7 +231,7 @@
       Close_Status : int := 0;
       Dup_Strm     : Boolean := False;
       File         : AFCB_Ptr renames File_Ptr.all;
-      Errno        : Integer;
+      Errno        : Integer := 0;
 
    begin
       --  Take a task lock, to protect the global data value Open_Files
--- /dev/null
+++ gcc/ada/s-osinte-android.ads
@@ -0,0 +1,566 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                  S p e c                                 --
+--                                                                          --
+--             Copyright (C) 1991-1994, Florida State University            --
+--          Copyright (C) 1995-2010, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --
+-- sion. GNARL is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --
+-- for  more details.  You should have  received  a copy of the GNU General --
+-- Public License  distributed with GNARL; see file COPYING.  If not, write --
+-- to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, --
+-- Boston, MA 02110-1301, USA.                                              --
+--                                                                          --
+-- As a special exception,  if other files  instantiate  generics from this --
+-- unit, or you link  this unit with other files  to produce an executable, --
+-- this  unit  does not  by itself cause  the resulting  executable  to  be --
+-- covered  by the  GNU  General  Public  License.  This exception does not --
+-- however invalidate  any other reasons why  the executable file  might be --
+-- covered by the  GNU Public License.                                      --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is a GNU/Linux (GNU/LinuxThreads) version of this package
+
+--  This package encapsulates all direct interfaces to OS services
+--  that are needed by the tasking run-time (libgnarl).
+
+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma
+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.
+
+with Ada.Unchecked_Conversion;
+with Interfaces.C;
+with System.Linux;
+
+package System.OS_Interface is
+   pragma Preelaborate;
+
+   subtype int            is Interfaces.C.int;
+   subtype char           is Interfaces.C.char;
+   subtype short          is Interfaces.C.short;
+   subtype long           is Interfaces.C.long;
+   subtype unsigned       is Interfaces.C.unsigned;
+   subtype unsigned_short is Interfaces.C.unsigned_short;
+   subtype unsigned_long  is Interfaces.C.unsigned_long;
+   subtype unsigned_char  is Interfaces.C.unsigned_char;
+   subtype plain_char     is Interfaces.C.plain_char;
+   subtype size_t         is Interfaces.C.size_t;
+
+   -----------
+   -- Errno --
+   -----------
+
+   function errno return int;
+   pragma Import (C, errno, "__get_errno");
+
+   EAGAIN    : constant := System.Linux.EAGAIN;
+   EINTR     : constant := System.Linux.EINTR;
+   EINVAL    : constant := System.Linux.EINVAL;
+   ENOMEM    : constant := System.Linux.ENOMEM;
+   EPERM     : constant := System.Linux.EPERM;
+   ETIMEDOUT : constant := System.Linux.ETIMEDOUT;
+
+   -------------
+   -- Signals --
+   -------------
+
+   Max_Interrupt : constant := 63;
+   type Signal is new int range 0 .. Max_Interrupt;
+   for Signal'Size use int'Size;
+
+   SIGHUP     : constant := System.Linux.SIGHUP;
+   SIGINT     : constant := System.Linux.SIGINT;
+   SIGQUIT    : constant := System.Linux.SIGQUIT;
+   SIGILL     : constant := System.Linux.SIGILL;
+   SIGTRAP    : constant := System.Linux.SIGTRAP;
+   SIGIOT     : constant := System.Linux.SIGIOT;
+   SIGABRT    : constant := System.Linux.SIGABRT;
+   SIGFPE     : constant := System.Linux.SIGFPE;
+   SIGKILL    : constant := System.Linux.SIGKILL;
+   SIGBUS     : constant := System.Linux.SIGBUS;
+   SIGSEGV    : constant := System.Linux.SIGSEGV;
+   SIGPIPE    : constant := System.Linux.SIGPIPE;
+   SIGALRM    : constant := System.Linux.SIGALRM;
+   SIGTERM    : constant := System.Linux.SIGTERM;
+   SIGUSR1    : constant := System.Linux.SIGUSR1;
+   SIGUSR2    : constant := System.Linux.SIGUSR2;
+   SIGCLD     : constant := System.Linux.SIGCLD;
+   SIGCHLD    : constant := System.Linux.SIGCHLD;
+   SIGPWR     : constant := System.Linux.SIGPWR;
+   SIGWINCH   : constant := System.Linux.SIGWINCH;
+   SIGURG     : constant := System.Linux.SIGURG;
+   SIGPOLL    : constant := System.Linux.SIGPOLL;
+   SIGIO      : constant := System.Linux.SIGIO;
+   SIGLOST    : constant := System.Linux.SIGLOST;
+   SIGSTOP    : constant := System.Linux.SIGSTOP;
+   SIGTSTP    : constant := System.Linux.SIGTSTP;
+   SIGCONT    : constant := System.Linux.SIGCONT;
+   SIGTTIN    : constant := System.Linux.SIGTTIN;
+   SIGTTOU    : constant := System.Linux.SIGTTOU;
+   SIGVTALRM  : constant := System.Linux.SIGVTALRM;
+   SIGPROF    : constant := System.Linux.SIGPROF;
+   SIGXCPU    : constant := System.Linux.SIGXCPU;
+   SIGXFSZ    : constant := System.Linux.SIGXFSZ;
+   SIGUNUSED  : constant := System.Linux.SIGUNUSED;
+   SIGSTKFLT  : constant := System.Linux.SIGSTKFLT;
+   SIGLTHRRES : constant := System.Linux.SIGLTHRRES;
+   SIGLTHRCAN : constant := System.Linux.SIGLTHRCAN;
+   SIGLTHRDBG : constant := System.Linux.SIGLTHRDBG;
+
+   SIGADAABORT : constant := SIGABRT;
+   --  Change this if you want to use another signal for task abort.
+   --  SIGTERM might be a good one.
+
+   type Signal_Set is array (Natural range <>) of Signal;
+
+   Unmasked    : constant Signal_Set := (
+      SIGTRAP,
+      --  To enable debugging on multithreaded applications, mark SIGTRAP to
+      --  be kept unmasked.
+
+      SIGBUS,
+
+      SIGTTIN, SIGTTOU, SIGTSTP,
+      --  Keep these three signals unmasked so that background processes
+      --  and IO behaves as normal "C" applications
+
+      SIGPROF,
+      --  To avoid confusing the profiler
+
+      SIGKILL, SIGSTOP,
+      --  These two signals actually cannot be masked;
+      --  POSIX simply won't allow it.
+
+      SIGLTHRRES, SIGLTHRCAN, SIGLTHRDBG);
+      --  These three signals are used by GNU/LinuxThreads starting from
+      --  glibc 2.1 (future 2.2).
+
+   Reserved    : constant Signal_Set :=
+   --  I am not sure why the following two signals are reserved.
+   --  I guess they are not supported by this version of GNU/Linux.
+     (SIGVTALRM, SIGUNUSED);
+
+   type sigset_t is private;
+
+   function sigaddset (set : access sigset_t; sig : Signal) return int;
+   pragma Import (C, sigaddset, "sigaddset");
+
+   function sigdelset (set : access sigset_t; sig : Signal) return int;
+   pragma Import (C, sigdelset, "sigdelset");
+
+   function sigfillset (set : access sigset_t) return int;
+   pragma Import (C, sigfillset, "sigfillset");
+
+   function sigismember (set : access sigset_t; sig : Signal) return int;
+   pragma Import (C, sigismember, "sigismember");
+
+   function sigemptyset (set : access sigset_t) return int;
+   pragma Import (C, sigemptyset, "sigemptyset");
+
+   type union_type_3 is new String (1 .. 116);
+   type siginfo_t is record
+      si_signo : int;
+      si_code  : int;
+      si_errno : int;
+      X_data   : union_type_3;
+   end record;
+   pragma Convention (C, siginfo_t);
+
+   type struct_sigaction is record
+      sa_handler  : System.Address;
+      sa_mask     : sigset_t;
+      sa_flags    : Interfaces.C.unsigned_long;
+      sa_restorer : System.Address;
+   end record;
+   pragma Convention (C, struct_sigaction);
+
+   type struct_sigaction_ptr is access all struct_sigaction;
+
+   type Machine_State is record
+      eip : unsigned_long;
+      ebx : unsigned_long;
+      esp : unsigned_long;
+      ebp : unsigned_long;
+      esi : unsigned_long;
+      edi : unsigned_long;
+   end record;
+   type Machine_State_Ptr is access all Machine_State;
+
+   SA_SIGINFO : constant := System.Linux.SA_SIGINFO;
+   SA_ONSTACK : constant := System.Linux.SA_ONSTACK;
+
+   SIG_BLOCK   : constant := 0;
+   SIG_UNBLOCK : constant := 1;
+   SIG_SETMASK : constant := 2;
+
+   SIG_DFL : constant := 0;
+   SIG_IGN : constant := 1;
+
+   function sigaction
+     (sig  : Signal;
+      act  : struct_sigaction_ptr;
+      oact : struct_sigaction_ptr) return int;
+   pragma Import (C, sigaction, "sigaction");
+
+   ----------
+   -- Time --
+   ----------
+
+   type timespec is private;
+
+   function To_Duration (TS : timespec) return Duration;
+   pragma Inline (To_Duration);
+
+   function To_Timespec (D : Duration) return timespec;
+   pragma Inline (To_Timespec);
+
+   function sysconf (name : int) return long;
+   pragma Import (C, sysconf);
+
+   SC_CLK_TCK          : constant := 2;
+   SC_NPROCESSORS_ONLN : constant := 84;
+
+   -------------------------
+   -- Priority Scheduling --
+   -------------------------
+
+   SCHED_OTHER : constant := 0;
+   SCHED_FIFO  : constant := 1;
+   SCHED_RR    : constant := 2;
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int;
+   --  Maps System.Any_Priority to a POSIX priority
+
+   -------------
+   -- Process --
+   -------------
+
+   type pid_t is private;
+
+   function kill (pid : pid_t; sig : Signal) return int;
+   pragma Import (C, kill, "kill");
+
+   function getpid return pid_t;
+   pragma Import (C, getpid, "getpid");
+
+   -------------
+   -- Threads --
+   -------------
+
+   type Thread_Body is access
+     function (arg : System.Address) return System.Address;
+   pragma Convention (C, Thread_Body);
+
+   function Thread_Body_Access is new
+     Ada.Unchecked_Conversion (System.Address, Thread_Body);
+
+   type pthread_t is new unsigned_long;
+   subtype Thread_Id        is pthread_t;
+
+   function To_pthread_t is new Ada.Unchecked_Conversion
+     (unsigned_long, pthread_t);
+
+   type pthread_mutex_t     is limited private;
+   type pthread_cond_t      is limited private;
+   type pthread_attr_t      is limited private;
+   type pthread_mutexattr_t is limited private;
+   type pthread_condattr_t  is limited private;
+   type pthread_key_t       is private;
+
+   PTHREAD_CREATE_DETACHED : constant := 1;
+
+   -----------
+   -- Stack --
+   -----------
+
+   type stack_t is record
+      ss_sp    : System.Address;
+      ss_flags : int;
+      ss_size  : size_t;
+   end record;
+   pragma Convention (C, stack_t);
+
+   function sigaltstack
+     (ss  : not null access stack_t;
+      oss : access stack_t) return int;
+   pragma Import (C, sigaltstack, "sigaltstack");
+
+   Alternate_Stack : aliased System.Address;
+   pragma Import (C, Alternate_Stack, "__gnat_alternate_stack");
+   --  The alternate signal stack for stack overflows
+
+   Alternate_Stack_Size : constant := 16 * 1024;
+   --  This must be in keeping with init.c:__gnat_alternate_stack
+
+   function Get_Stack_Base (thread : pthread_t) return Address;
+   pragma Inline (Get_Stack_Base);
+   --  This is a dummy procedure to share some GNULLI files
+
+   ---------------------------------------
+   -- Nonstandard Thread Initialization --
+   ---------------------------------------
+
+   procedure pthread_init;
+   pragma Inline (pthread_init);
+   --  This is a dummy procedure to share some GNULLI files
+
+   -------------------------
+   -- POSIX.1c  Section 3 --
+   -------------------------
+
+   function sigwait (set : access sigset_t; sig : access Signal) return int;
+   pragma Import (C, sigwait, "sigwait");
+
+   function pthread_kill (thread : pthread_t; sig : Signal) return int;
+   pragma Import (C, pthread_kill, "pthread_kill");
+
+   function pthread_sigmask
+     (how  : int;
+      set  : access sigset_t;
+      oset : access sigset_t) return int;
+   pragma Import (C, pthread_sigmask, "pthread_sigmask");
+
+   --------------------------
+   -- POSIX.1c  Section 11 --
+   --------------------------
+
+   function pthread_mutexattr_init
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_init, "pthread_mutexattr_init");
+
+   function pthread_mutexattr_destroy
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_destroy, "pthread_mutexattr_destroy");
+
+   function pthread_mutex_init
+     (mutex : access pthread_mutex_t;
+      attr  : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutex_init, "pthread_mutex_init");
+
+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_destroy, "pthread_mutex_destroy");
+
+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_lock, "pthread_mutex_lock");
+
+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_unlock, "pthread_mutex_unlock");
+
+   function pthread_condattr_init
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_init, "pthread_condattr_init");
+
+   function pthread_condattr_destroy
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_destroy, "pthread_condattr_destroy");
+
+   function pthread_cond_init
+     (cond : access pthread_cond_t;
+      attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_cond_init, "pthread_cond_init");
+
+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_destroy, "pthread_cond_destroy");
+
+   function pthread_cond_signal (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_signal, "pthread_cond_signal");
+
+   function pthread_cond_wait
+     (cond  : access pthread_cond_t;
+      mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_cond_wait, "pthread_cond_wait");
+
+   function pthread_cond_timedwait
+     (cond    : access pthread_cond_t;
+      mutex   : access pthread_mutex_t;
+      abstime : access timespec) return int;
+   pragma Import (C, pthread_cond_timedwait, "pthread_cond_timedwait");
+
+   --------------------------
+   -- POSIX.1c  Section 13 --
+   --------------------------
+
+   type struct_sched_param is record
+      sched_priority : int;  --  scheduling priority
+   end record;
+   pragma Convention (C, struct_sched_param);
+
+   function pthread_setschedparam
+     (thread : pthread_t;
+      policy : int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
+
+   function pthread_attr_setschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : int) return int;
+   pragma Import
+     (C, pthread_attr_setschedpolicy, "pthread_attr_setschedpolicy");
+
+   function sched_yield return int;
+   pragma Import (C, sched_yield, "sched_yield");
+
+   ---------------------------
+   -- P1003.1c - Section 16 --
+   ---------------------------
+
+   function pthread_attr_init
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_init, "pthread_attr_init");
+
+   function pthread_attr_destroy
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_destroy, "pthread_attr_destroy");
+
+   function pthread_attr_setdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : int) return int;
+   pragma Import
+     (C, pthread_attr_setdetachstate, "pthread_attr_setdetachstate");
+
+   function pthread_attr_setstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : size_t) return int;
+   pragma Import (C, pthread_attr_setstacksize, "pthread_attr_setstacksize");
+
+   function pthread_create
+     (thread        : access pthread_t;
+      attributes    : access pthread_attr_t;
+      start_routine : Thread_Body;
+      arg           : System.Address) return int;
+   pragma Import (C, pthread_create, "pthread_create");
+
+   procedure pthread_exit (status : System.Address);
+   pragma Import (C, pthread_exit, "pthread_exit");
+
+   function pthread_self return pthread_t;
+   pragma Import (C, pthread_self, "pthread_self");
+
+   function lwp_self return System.Address;
+   pragma Import (C, lwp_self, "__gnat_lwp_self");
+
+   --------------------------
+   -- POSIX.1c  Section 17 --
+   --------------------------
+
+   function pthread_setspecific
+     (key   : pthread_key_t;
+      value : System.Address) return int;
+   pragma Import (C, pthread_setspecific, "pthread_setspecific");
+
+   function pthread_getspecific (key : pthread_key_t) return System.Address;
+   pragma Import (C, pthread_getspecific, "pthread_getspecific");
+
+   type destructor_pointer is access procedure (arg : System.Address);
+   pragma Convention (C, destructor_pointer);
+
+   function pthread_key_create
+     (key        : access pthread_key_t;
+      destructor : destructor_pointer) return int;
+   pragma Import (C, pthread_key_create, "pthread_key_create");
+
+   CPU_SETSIZE : constant := 1_024;
+
+   type bit_field is array (1 .. CPU_SETSIZE) of Boolean;
+   for bit_field'Size use CPU_SETSIZE;
+   pragma Pack (bit_field);
+   pragma Convention (C, bit_field);
+
+   type cpu_set_t is record
+      bits : bit_field;
+   end record;
+   pragma Convention (C, cpu_set_t);
+
+   function pthread_setaffinity_np
+     (thread     : pthread_t;
+      cpusetsize : size_t;
+      cpuset     : access cpu_set_t) return int;
+   pragma Import (C, pthread_setaffinity_np, "pthread_setaffinity_np");
+   pragma Weak_External (pthread_setaffinity_np);
+   --  Use a weak symbol because this function may be available or not,
+   --  depending on the version of the system.
+
+   function pthread_attr_setaffinity_np
+     (attr       : access pthread_attr_t;
+      cpusetsize : size_t;
+      cpuset     : access cpu_set_t) return int;
+   pragma Import (C, pthread_attr_setaffinity_np,
+                    "pthread_attr_setaffinity_np");
+   pragma Weak_External (pthread_attr_setaffinity_np);
+   --  Use a weak symbol because this function may be available or not,
+   --  depending on the version of the system.
+
+private
+
+   type sigset_t is array (0 .. 127) of unsigned_char;
+   pragma Convention (C, sigset_t);
+   for sigset_t'Alignment use Interfaces.C.unsigned_long'Alignment;
+
+   pragma Warnings (Off);
+   for struct_sigaction use record
+      sa_handler at Linux.sa_handler_pos range 0 .. Standard'Address_Size - 1;
+      sa_mask    at Linux.sa_mask_pos    range 0 .. 1023;
+      sa_flags   at Linux.sa_flags_pos   range 0 .. Standard'Address_Size - 1;
+   end record;
+   --  We intentionally leave sa_restorer unspecified and let the compiler
+   --  append it after the last field, so disable corresponding warning.
+   pragma Warnings (On);
+
+   type pid_t is new int;
+
+   type time_t is new long;
+
+   type timespec is record
+      tv_sec  : time_t;
+      tv_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type pthread_attr_t is record
+      detachstate   : int;
+      schedpolicy   : int;
+      schedparam    : struct_sched_param;
+      inheritsched  : int;
+      scope         : int;
+      guardsize     : size_t;
+      stackaddr_set : int;
+      stackaddr     : System.Address;
+      stacksize     : size_t;
+   end record;
+   pragma Convention (C, pthread_attr_t);
+
+   type pthread_condattr_t is record
+      dummy : int;
+   end record;
+   pragma Convention (C, pthread_condattr_t);
+
+   type pthread_mutexattr_t is record
+      mutexkind : int;
+   end record;
+   pragma Convention (C, pthread_mutexattr_t);
+
+   type pthread_mutex_t is new System.Linux.pthread_mutex_t;
+
+   type unsigned_long_long_t is mod 2 ** 64;
+   --  Interfaces.C.Extensions isn't preelaborated so cannot be with-ed
+
+   type pthread_cond_t is array (0 .. 47) of unsigned_char;
+   pragma Convention (C, pthread_cond_t);
+   for pthread_cond_t'Alignment use unsigned_long_long_t'Alignment;
+
+   type pthread_key_t is new unsigned;
+
+end System.OS_Interface;
--- /dev/null
+++ gcc/ada/s-osinte-dragonfly.adb
@@ -0,0 +1,116 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                   B o d y                                --
+--                                                                          --
+--          Copyright (C) 1991-2009, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University. It is --
+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
+-- State University (http://www.gnat.com).                                  --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the DragonFly THREADS version of this package
+
+with Interfaces.C; use Interfaces.C;
+
+package body System.OS_Interface is
+
+   -----------
+   -- Errno --
+   -----------
+
+   function Errno return int is
+      type int_ptr is access all int;
+
+      function internal_errno return int_ptr;
+      pragma Import (C, internal_errno, "__get_errno");
+
+   begin
+      return (internal_errno.all);
+   end Errno;
+
+   --------------------
+   -- Get_Stack_Base --
+   --------------------
+
+   function Get_Stack_Base (thread : pthread_t) return Address is
+      pragma Unreferenced (thread);
+   begin
+      return Null_Address;
+   end Get_Stack_Base;
+
+   ------------------
+   -- pthread_init --
+   ------------------
+
+   procedure pthread_init is
+   begin
+      null;
+   end pthread_init;
+
+   -----------------
+   -- To_Duration --
+   -----------------
+
+   function To_Duration (TS : timespec) return Duration is
+   begin
+      return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;
+   end To_Duration;
+
+   ------------------------
+   -- To_Target_Priority --
+   ------------------------
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int
+   is
+   begin
+      return Interfaces.C.int (Prio);
+   end To_Target_Priority;
+
+   -----------------
+   -- To_Timespec --
+   -----------------
+
+   function To_Timespec (D : Duration) return timespec is
+      S : time_t;
+      F : Duration;
+
+   begin
+      S := time_t (Long_Long_Integer (D));
+      F := D - Duration (S);
+
+      --  If F has negative value due to a round-up, adjust for positive F
+      --  value.
+
+      if F < 0.0 then
+         S := S - 1;
+         F := F + 1.0;
+      end if;
+
+      return timespec'(tv_sec => S,
+                       tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));
+   end To_Timespec;
+
+end System.OS_Interface;
--- /dev/null
+++ gcc/ada/s-osinte-dragonfly.ads
@@ -0,0 +1,648 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                   S p e c                                --
+--                                                                          --
+--             Copyright (C) 1991-1994, Florida State University            --
+--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University. It is --
+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
+-- State University (http://www.gnat.com).                                  --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the DragonFly BSD PTHREADS version of this package
+
+--  This package encapsulates all direct interfaces to OS services
+--  that are needed by the tasking run-time (libgnarl).
+
+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma
+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.
+
+with Ada.Unchecked_Conversion;
+
+with Interfaces.C;
+
+package System.OS_Interface is
+   pragma Preelaborate;
+
+   pragma Linker_Options ("-pthread");
+
+   subtype int            is Interfaces.C.int;
+   subtype short          is Interfaces.C.short;
+   subtype long           is Interfaces.C.long;
+   subtype unsigned       is Interfaces.C.unsigned;
+   subtype unsigned_short is Interfaces.C.unsigned_short;
+   subtype unsigned_long  is Interfaces.C.unsigned_long;
+   subtype unsigned_char  is Interfaces.C.unsigned_char;
+   subtype plain_char     is Interfaces.C.plain_char;
+   subtype size_t         is Interfaces.C.size_t;
+
+   -----------
+   -- Errno --
+   -----------
+
+   function Errno return int;
+   pragma Inline (Errno);
+
+   EAGAIN    : constant := 35;
+   EINTR     : constant := 4;
+   EINVAL    : constant := 22;
+   ENOMEM    : constant := 12;
+   ETIMEDOUT : constant := 60;
+
+   -------------
+   -- Signals --
+   -------------
+
+   Max_Interrupt : constant := 31;
+   type Signal is new int range 0 .. Max_Interrupt;
+   for Signal'Size use int'Size;
+
+   SIGHUP     : constant := 1; --  hangup
+   SIGINT     : constant := 2; --  interrupt (rubout)
+   SIGQUIT    : constant := 3; --  quit (ASCD FS)
+   SIGILL     : constant := 4; --  illegal instruction (not reset)
+   SIGTRAP    : constant := 5; --  trace trap (not reset)
+   SIGIOT     : constant := 6; --  IOT instruction
+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future
+   SIGEMT     : constant := 7; --  EMT instruction
+   SIGFPE     : constant := 8; --  floating point exception
+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)
+   SIGBUS     : constant := 10; --  bus error
+   SIGSEGV    : constant := 11; --  segmentation violation
+   SIGSYS     : constant := 12; --  bad argument to system call
+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it
+   SIGALRM    : constant := 14; --  alarm clock
+   SIGTERM    : constant := 15; --  software termination signal from kill
+   SIGURG     : constant := 16; --  urgent condition on IO channel
+   SIGSTOP    : constant := 17; --  stop (cannot be caught or ignored)
+   SIGTSTP    : constant := 18; --  user stop requested from tty
+   SIGCONT    : constant := 19; --  stopped process has been continued
+   SIGCLD     : constant := 20; --  alias for SIGCHLD
+   SIGCHLD    : constant := 20; --  child status change
+   SIGTTIN    : constant := 21; --  background tty read attempted
+   SIGTTOU    : constant := 22; --  background tty write attempted
+   SIGIO      : constant := 23; --  I/O possible (Solaris SIGPOLL alias)
+   SIGXCPU    : constant := 24; --  CPU time limit exceeded
+   SIGXFSZ    : constant := 25; --  filesize limit exceeded
+   SIGVTALRM  : constant := 26; --  virtual timer expired
+   SIGPROF    : constant := 27; --  profiling timer expired
+   SIGWINCH   : constant := 28; --  window size change
+   SIGINFO    : constant := 29; --  information request (BSD)
+   SIGUSR1    : constant := 30; --  user defined signal 1
+   SIGUSR2    : constant := 31; --  user defined signal 2
+
+   SIGADAABORT : constant := SIGABRT;
+   --  Change this if you want to use another signal for task abort.
+   --  SIGTERM might be a good one.
+
+   type Signal_Set is array (Natural range <>) of Signal;
+
+   --  Interrupts that must be unmasked at all times.  DragonFlyBSD
+   --  pthreads will not allow an application to mask out any
+   --  interrupt needed by the threads library.
+   Unmasked : constant Signal_Set :=
+     (SIGTRAP, SIGBUS, SIGTTIN, SIGTTOU, SIGTSTP);
+
+   --  DragonFlyBSD will uses SIGPROF for timing.  Do not allow a
+   --  handler to attach to this signal.
+   Reserved : constant Signal_Set := (0 .. 0 => SIGPROF);
+
+   type sigset_t is private;
+
+   function sigaddset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigaddset, "sigaddset");
+
+   function sigdelset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigdelset, "sigdelset");
+
+   function sigfillset (set : access sigset_t) return int;
+   pragma Import (C, sigfillset, "sigfillset");
+
+   function sigismember
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigismember, "sigismember");
+
+   function sigemptyset (set : access sigset_t) return int;
+   pragma Import (C, sigemptyset, "sigemptyset");
+
+   --  sigcontext is architecture dependent, so define it private
+   type struct_sigcontext is private;
+
+   type old_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_mask    : sigset_t;
+      sa_flags   : int;
+   end record;
+   pragma Convention (C, old_struct_sigaction);
+
+   type new_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_flags   : int;
+      sa_mask    : sigset_t;
+   end record;
+   pragma Convention (C, new_struct_sigaction);
+
+   subtype struct_sigaction is new_struct_sigaction;
+   type struct_sigaction_ptr is access all struct_sigaction;
+
+   SIG_BLOCK   : constant := 1;
+   SIG_UNBLOCK : constant := 2;
+   SIG_SETMASK : constant := 3;
+
+   SIG_DFL : constant := 0;
+   SIG_IGN : constant := 1;
+
+   SA_SIGINFO : constant := 16#0040#;
+   SA_ONSTACK : constant := 16#0001#;
+
+   function sigaction
+     (sig  : Signal;
+      act  : struct_sigaction_ptr;
+      oact : struct_sigaction_ptr) return int;
+   pragma Import (C, sigaction, "sigaction");
+
+   ----------
+   -- Time --
+   ----------
+
+   Time_Slice_Supported : constant Boolean := True;
+   --  Indicates whether time slicing is supported (i.e SCHED_RR is supported)
+
+   type timespec is private;
+
+   function nanosleep (rqtp, rmtp : access timespec)  return int;
+   pragma Import (C, nanosleep, "nanosleep");
+
+   type clockid_t is new unsigned_long;
+
+   function clock_gettime
+     (clock_id : clockid_t;
+      tp       : access timespec)
+      return int;
+   pragma Import (C, clock_gettime, "clock_gettime");
+
+   function To_Duration (TS : timespec) return Duration;
+   pragma Inline (To_Duration);
+
+   function To_Timespec (D : Duration) return timespec;
+   pragma Inline (To_Timespec);
+
+   type struct_timezone is record
+      tz_minuteswest : int;
+      tz_dsttime     : int;
+   end record;
+   pragma Convention (C, struct_timezone);
+
+   procedure usleep (useconds : unsigned_long);
+   pragma Import (C, usleep, "usleep");
+
+   -------------------------
+   -- Priority Scheduling --
+   -------------------------
+
+   SCHED_FIFO  : constant := 1;
+   SCHED_OTHER : constant := 2;
+   SCHED_RR    : constant := 3;
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int;
+   --  Maps System.Any_Priority to a POSIX priority
+
+   -------------
+   -- Process --
+   -------------
+
+   type pid_t is private;
+
+   function kill (pid : pid_t; sig : Signal) return int;
+   pragma Import (C, kill, "kill");
+
+   function getpid return pid_t;
+   pragma Import (C, getpid, "getpid");
+
+   ---------
+   -- LWP --
+   ---------
+
+   function lwp_self return System.Address;
+   --  lwp_self does not exist on this thread library, revert to pthread_self
+   --  which is the closest approximation (with getpid). This function is
+   --  needed to share 7staprop.adb across POSIX-like targets.
+   pragma Import (C, lwp_self, "pthread_self");
+
+   -------------
+   -- Threads --
+   -------------
+
+   type Thread_Body is access
+     function (arg : System.Address) return System.Address;
+   pragma Convention (C, Thread_Body);
+
+   function Thread_Body_Access is new
+     Ada.Unchecked_Conversion (System.Address, Thread_Body);
+
+   type pthread_t           is private;
+   subtype Thread_Id        is pthread_t;
+
+   type pthread_mutex_t     is limited private;
+   type pthread_cond_t      is limited private;
+   type pthread_attr_t      is limited private;
+   type pthread_mutexattr_t is limited private;
+   type pthread_condattr_t  is limited private;
+   type pthread_key_t       is private;
+
+   PTHREAD_CREATE_DETACHED : constant := 1;
+   PTHREAD_CREATE_JOINABLE : constant := 0;
+
+   PTHREAD_SCOPE_PROCESS : constant := 0;
+   PTHREAD_SCOPE_SYSTEM  : constant := 2;
+
+   --  Read/Write lock not supported on DragonFly. To add support both types
+   --  pthread_rwlock_t and pthread_rwlockattr_t must properly be defined
+   --  with the associated routines pthread_rwlock_[init/destroy] and
+   --  pthread_rwlock_[rdlock/wrlock/unlock].
+
+   subtype pthread_rwlock_t     is pthread_mutex_t;
+   subtype pthread_rwlockattr_t is pthread_mutexattr_t;
+
+   -----------
+   -- Stack --
+   -----------
+
+   type stack_t is record
+      ss_sp    : System.Address;
+      ss_size  : size_t;
+      ss_flags : int;
+   end record;
+   pragma Convention (C, stack_t);
+
+   function sigaltstack
+     (ss  : not null access stack_t;
+      oss : access stack_t) return int;
+   pragma Import (C, sigaltstack, "sigaltstack");
+
+   Alternate_Stack : aliased System.Address;
+   --  This is a dummy definition, never used (Alternate_Stack_Size is null)
+
+   Alternate_Stack_Size : constant := 0;
+   --  No alternate signal stack is used on this platform
+
+   Stack_Base_Available : constant Boolean := False;
+   --  Indicates whether the stack base is available on this target. This
+   --  allows us to share s-osinte.adb between all the FSU run time. Note that
+   --  this value can only be true if pthread_t has a complete definition that
+   --  corresponds exactly to the C header files.
+
+   function Get_Stack_Base (thread : pthread_t) return Address;
+   pragma Inline (Get_Stack_Base);
+   --  returns the stack base of the specified thread. Only call this function
+   --  when Stack_Base_Available is True.
+
+   function Get_Page_Size return size_t;
+   function Get_Page_Size return Address;
+   pragma Import (C, Get_Page_Size, "getpagesize");
+   --  Returns the size of a page
+
+   PROT_NONE  : constant := 0;
+   PROT_READ  : constant := 1;
+   PROT_WRITE : constant := 2;
+   PROT_EXEC  : constant := 4;
+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;
+   PROT_ON    : constant := PROT_NONE;
+   PROT_OFF   : constant := PROT_ALL;
+
+   function mprotect (addr : Address; len : size_t; prot : int) return int;
+   pragma Import (C, mprotect);
+
+   ---------------------------------------
+   -- Nonstandard Thread Initialization --
+   ---------------------------------------
+
+   --  FSU_THREADS requires pthread_init, which is nonstandard and this should
+   --  be invoked during the elaboration of s-taprop.adb.
+
+   --  DragonFlyBSD does not require this so we provide an empty Ada body
+
+   procedure pthread_init;
+
+   -------------------------
+   -- POSIX.1c  Section 3 --
+   -------------------------
+
+   function sigwait
+     (set : access sigset_t;
+      sig : access Signal) return int;
+   pragma Import (C, sigwait, "sigwait");
+
+   function pthread_kill
+     (thread : pthread_t;
+      sig    : Signal) return int;
+   pragma Import (C, pthread_kill, "pthread_kill");
+
+   function pthread_sigmask
+     (how  : int;
+      set  : access sigset_t;
+      oset : access sigset_t) return int;
+   pragma Import (C, pthread_sigmask, "pthread_sigmask");
+
+   --------------------------
+   -- POSIX.1c  Section 11 --
+   --------------------------
+
+   function pthread_mutexattr_init
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_init, "pthread_mutexattr_init");
+
+   function pthread_mutexattr_destroy
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_destroy, "pthread_mutexattr_destroy");
+
+   function pthread_mutex_init
+     (mutex : access pthread_mutex_t;
+      attr  : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutex_init, "pthread_mutex_init");
+
+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_destroy, "pthread_mutex_destroy");
+
+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_lock, "pthread_mutex_lock");
+
+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_unlock, "pthread_mutex_unlock");
+
+   function pthread_condattr_init
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_init, "pthread_condattr_init");
+
+   function pthread_condattr_destroy
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_destroy, "pthread_condattr_destroy");
+
+   function pthread_cond_init
+     (cond : access pthread_cond_t;
+      attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_cond_init, "pthread_cond_init");
+
+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_destroy, "pthread_cond_destroy");
+
+   function pthread_cond_signal (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_signal, "pthread_cond_signal");
+
+   function pthread_cond_wait
+     (cond  : access pthread_cond_t;
+      mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_cond_wait, "pthread_cond_wait");
+
+   function pthread_cond_timedwait
+     (cond    : access pthread_cond_t;
+      mutex   : access pthread_mutex_t;
+      abstime : access timespec) return int;
+   pragma Import (C, pthread_cond_timedwait, "pthread_cond_timedwait");
+
+   Relative_Timed_Wait : constant Boolean := False;
+   --  pthread_cond_timedwait requires an absolute delay time
+
+   --------------------------
+   -- POSIX.1c  Section 13 --
+   --------------------------
+
+   PTHREAD_PRIO_NONE    : constant := 0;
+   PTHREAD_PRIO_PROTECT : constant := 2;
+   PTHREAD_PRIO_INHERIT : constant := 1;
+
+   function pthread_mutexattr_setprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : int) return int;
+   pragma Import
+      (C, pthread_mutexattr_setprotocol, "pthread_mutexattr_setprotocol");
+
+   function pthread_mutexattr_getprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprotocol, "pthread_mutexattr_getprotocol");
+
+   function pthread_mutexattr_setprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : int) return int;
+   pragma Import
+     (C, pthread_mutexattr_setprioceiling,
+      "pthread_mutexattr_setprioceiling");
+
+   function pthread_mutexattr_getprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprioceiling,
+      "pthread_mutexattr_getprioceiling");
+
+   type struct_sched_param is record
+      sched_priority : int;
+   end record;
+   pragma Convention (C, struct_sched_param);
+
+   function pthread_getschedparam
+     (thread : pthread_t;
+      policy : access int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_getschedparam, "pthread_getschedparam");
+
+   function pthread_setschedparam
+     (thread : pthread_t;
+      policy : int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
+
+   function pthread_attr_setscope
+     (attr            : access pthread_attr_t;
+      contentionscope : int) return int;
+   pragma Import (C, pthread_attr_setscope, "pthread_attr_setscope");
+
+   function pthread_attr_getscope
+     (attr            : access pthread_attr_t;
+      contentionscope : access int) return int;
+   pragma Import (C, pthread_attr_getscope, "pthread_attr_getscope");
+
+   function pthread_attr_setinheritsched
+     (attr            : access pthread_attr_t;
+      inheritsched : int) return int;
+   pragma Import
+     (C, pthread_attr_setinheritsched, "pthread_attr_setinheritsched");
+
+   function pthread_attr_getinheritsched
+     (attr         : access pthread_attr_t;
+      inheritsched : access int) return int;
+   pragma Import
+     (C, pthread_attr_getinheritsched, "pthread_attr_getinheritsched");
+
+   function pthread_attr_setschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : int) return int;
+   pragma Import (C, pthread_attr_setschedpolicy,
+     "pthread_attr_setschedpolicy");
+
+   function pthread_attr_getschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : access int) return int;
+   pragma Import (C, pthread_attr_getschedpolicy,
+     "pthread_attr_getschedpolicy");
+
+   function pthread_attr_setschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : int) return int;
+   pragma Import (C, pthread_attr_setschedparam, "pthread_attr_setschedparam");
+
+   function pthread_attr_getschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : access int) return int;
+   pragma Import (C, pthread_attr_getschedparam, "pthread_attr_getschedparam");
+
+   function sched_yield return int;
+   pragma Import (C, sched_yield, "pthread_yield");
+
+   --------------------------
+   -- P1003.1c  Section 16 --
+   --------------------------
+
+   function pthread_attr_init (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_init, "pthread_attr_init");
+
+   function pthread_attr_destroy
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_destroy, "pthread_attr_destroy");
+
+   function pthread_attr_setdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : int) return int;
+   pragma Import
+     (C, pthread_attr_setdetachstate, "pthread_attr_setdetachstate");
+
+   function pthread_attr_getdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : access int) return int;
+   pragma Import
+     (C, pthread_attr_getdetachstate, "pthread_attr_getdetachstate");
+
+   function pthread_attr_getstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : access size_t) return int;
+   pragma Import
+     (C, pthread_attr_getstacksize, "pthread_attr_getstacksize");
+
+   function pthread_attr_setstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : size_t) return int;
+   pragma Import
+     (C, pthread_attr_setstacksize, "pthread_attr_setstacksize");
+
+   function pthread_create
+     (thread        : access pthread_t;
+      attributes    : access pthread_attr_t;
+      start_routine : Thread_Body;
+      arg           : System.Address) return int;
+   pragma Import (C, pthread_create, "pthread_create");
+
+   function pthread_detach (thread : pthread_t) return int;
+   pragma Import (C, pthread_detach, "pthread_detach");
+
+   procedure pthread_exit (status : System.Address);
+   pragma Import (C, pthread_exit, "pthread_exit");
+
+   function pthread_self return pthread_t;
+   pragma Import (C, pthread_self, "pthread_self");
+
+   --------------------------
+   -- POSIX.1c  Section 17 --
+   --------------------------
+
+   function pthread_setspecific
+     (key   : pthread_key_t;
+      value : System.Address) return  int;
+   pragma Import (C, pthread_setspecific, "pthread_setspecific");
+
+   function pthread_getspecific (key : pthread_key_t) return System.Address;
+   pragma Import (C, pthread_getspecific, "pthread_getspecific");
+
+   type destructor_pointer is access procedure (arg : System.Address);
+   pragma Convention (C, destructor_pointer);
+
+   function pthread_key_create
+     (key        : access pthread_key_t;
+      destructor : destructor_pointer) return int;
+   pragma Import (C, pthread_key_create, "pthread_key_create");
+
+   ------------------------------------
+   -- Non-portable Pthread Functions --
+   ------------------------------------
+
+   function pthread_set_name_np
+     (thread : pthread_t;
+      name   : System.Address) return int;
+   pragma Import (C, pthread_set_name_np, "pthread_set_name_np");
+
+private
+
+   type sigset_t is array (1 .. 4) of unsigned;
+
+   --  In DragonFlyBSD the component sa_handler turns out to
+   --  be one a union type, and the selector is a macro:
+   --  #define sa_handler __sigaction_u._handler
+   --  #define sa_sigaction __sigaction_u._sigaction
+
+   --  Should we add a signal_context type here ???
+   --  How could it be done independent of the CPU architecture ???
+   --  sigcontext type is opaque, so it is architecturally neutral.
+   --  It is always passed as an access type, so define it as an empty record
+   --  since the contents are not used anywhere.
+
+   type struct_sigcontext is null record;
+   pragma Convention (C, struct_sigcontext);
+
+   type pid_t is new int;
+
+   type time_t is new long;
+
+   type timespec is record
+      tv_sec  : time_t;
+      tv_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type pthread_t           is new System.Address;
+   type pthread_attr_t      is new System.Address;
+   type pthread_mutex_t     is new System.Address;
+   type pthread_mutexattr_t is new System.Address;
+   type pthread_cond_t      is new System.Address;
+   type pthread_condattr_t  is new System.Address;
+   type pthread_key_t       is new int;
+
+end System.OS_Interface;
--- gcc/ada/s-osinte-freebsd.adb.orig
+++ gcc/ada/s-osinte-freebsd.adb
@@ -44,7 +44,7 @@
       type int_ptr is access all int;
 
       function internal_errno return int_ptr;
-      pragma Import (C, internal_errno, "__error");
+      pragma Import (C, internal_errno, "__get_errno");
 
    begin
       return (internal_errno.all);
@@ -57,7 +57,7 @@
    function Get_Stack_Base (thread : pthread_t) return Address is
       pragma Unreferenced (thread);
    begin
-      return (0);
+      return Null_Address;
    end Get_Stack_Base;
 
    ------------------
@@ -75,7 +75,7 @@
 
    function To_Duration (TS : timespec) return Duration is
    begin
-      return Duration (TS.ts_sec) + Duration (TS.ts_nsec) / 10#1#E9;
+      return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;
    end To_Duration;
 
    ------------------------
@@ -108,8 +108,8 @@
          F := F + 1.0;
       end if;
 
-      return timespec'(ts_sec => S,
-                       ts_nsec => long (Long_Long_Integer (F * 10#1#E9)));
+      return timespec'(tv_sec => S,
+                       tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));
    end To_Timespec;
 
 end System.OS_Interface;
--- /dev/null
+++ gcc/ada/s-osinte-freebsd32.ads
@@ -0,0 +1,648 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                   S p e c                                --
+--                                                                          --
+--             Copyright (C) 1991-1994, Florida State University            --
+--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University. It is --
+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
+-- State University (http://www.gnat.com).                                  --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the FreeBSD PTHREADS version of this package
+
+--  This package encapsulates all direct interfaces to OS services
+--  that are needed by the tasking run-time (libgnarl).
+
+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma
+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.
+
+with Ada.Unchecked_Conversion;
+
+with Interfaces.C;
+
+package System.OS_Interface is
+   pragma Preelaborate;
+
+   pragma Linker_Options ("-pthread");
+
+   subtype int            is Interfaces.C.int;
+   subtype short          is Interfaces.C.short;
+   subtype long           is Interfaces.C.long;
+   subtype unsigned       is Interfaces.C.unsigned;
+   subtype unsigned_short is Interfaces.C.unsigned_short;
+   subtype unsigned_long  is Interfaces.C.unsigned_long;
+   subtype unsigned_char  is Interfaces.C.unsigned_char;
+   subtype plain_char     is Interfaces.C.plain_char;
+   subtype size_t         is Interfaces.C.size_t;
+
+   -----------
+   -- Errno --
+   -----------
+
+   function Errno return int;
+   pragma Inline (Errno);
+
+   EAGAIN    : constant := 35;
+   EINTR     : constant := 4;
+   EINVAL    : constant := 22;
+   ENOMEM    : constant := 12;
+   ETIMEDOUT : constant := 60;
+
+   -------------
+   -- Signals --
+   -------------
+
+   Max_Interrupt : constant := 31;
+   type Signal is new int range 0 .. Max_Interrupt;
+   for Signal'Size use int'Size;
+
+   SIGHUP     : constant := 1; --  hangup
+   SIGINT     : constant := 2; --  interrupt (rubout)
+   SIGQUIT    : constant := 3; --  quit (ASCD FS)
+   SIGILL     : constant := 4; --  illegal instruction (not reset)
+   SIGTRAP    : constant := 5; --  trace trap (not reset)
+   SIGIOT     : constant := 6; --  IOT instruction
+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future
+   SIGEMT     : constant := 7; --  EMT instruction
+   SIGFPE     : constant := 8; --  floating point exception
+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)
+   SIGBUS     : constant := 10; --  bus error
+   SIGSEGV    : constant := 11; --  segmentation violation
+   SIGSYS     : constant := 12; --  bad argument to system call
+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it
+   SIGALRM    : constant := 14; --  alarm clock
+   SIGTERM    : constant := 15; --  software termination signal from kill
+   SIGURG     : constant := 16; --  urgent condition on IO channel
+   SIGSTOP    : constant := 17; --  stop (cannot be caught or ignored)
+   SIGTSTP    : constant := 18; --  user stop requested from tty
+   SIGCONT    : constant := 19; --  stopped process has been continued
+   SIGCLD     : constant := 20; --  alias for SIGCHLD
+   SIGCHLD    : constant := 20; --  child status change
+   SIGTTIN    : constant := 21; --  background tty read attempted
+   SIGTTOU    : constant := 22; --  background tty write attempted
+   SIGIO      : constant := 23; --  I/O possible (Solaris SIGPOLL alias)
+   SIGXCPU    : constant := 24; --  CPU time limit exceeded
+   SIGXFSZ    : constant := 25; --  filesize limit exceeded
+   SIGVTALRM  : constant := 26; --  virtual timer expired
+   SIGPROF    : constant := 27; --  profiling timer expired
+   SIGWINCH   : constant := 28; --  window size change
+   SIGINFO    : constant := 29; --  information request (BSD)
+   SIGUSR1    : constant := 30; --  user defined signal 1
+   SIGUSR2    : constant := 31; --  user defined signal 2
+
+   SIGADAABORT : constant := SIGABRT;
+   --  Change this if you want to use another signal for task abort.
+   --  SIGTERM might be a good one.
+
+   type Signal_Set is array (Natural range <>) of Signal;
+
+   --  Interrupts that must be unmasked at all times.  FreeBSD
+   --  pthreads will not allow an application to mask out any
+   --  interrupt needed by the threads library.
+   Unmasked : constant Signal_Set :=
+     (SIGTRAP, SIGBUS, SIGTTIN, SIGTTOU, SIGTSTP);
+
+   --  FreeBSD will uses SIGPROF for timing.  Do not allow a
+   --  handler to attach to this signal.
+   Reserved : constant Signal_Set := (0 .. 0 => SIGPROF);
+
+   type sigset_t is private;
+
+   function sigaddset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigaddset, "sigaddset");
+
+   function sigdelset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigdelset, "sigdelset");
+
+   function sigfillset (set : access sigset_t) return int;
+   pragma Import (C, sigfillset, "sigfillset");
+
+   function sigismember
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigismember, "sigismember");
+
+   function sigemptyset (set : access sigset_t) return int;
+   pragma Import (C, sigemptyset, "sigemptyset");
+
+   --  sigcontext is architecture dependent, so define it private
+   type struct_sigcontext is private;
+
+   type old_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_mask    : sigset_t;
+      sa_flags   : int;
+   end record;
+   pragma Convention (C, old_struct_sigaction);
+
+   type new_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_flags   : int;
+      sa_mask    : sigset_t;
+   end record;
+   pragma Convention (C, new_struct_sigaction);
+
+   subtype struct_sigaction is new_struct_sigaction;
+   type struct_sigaction_ptr is access all struct_sigaction;
+
+   SIG_BLOCK   : constant := 1;
+   SIG_UNBLOCK : constant := 2;
+   SIG_SETMASK : constant := 3;
+
+   SIG_DFL : constant := 0;
+   SIG_IGN : constant := 1;
+
+   SA_SIGINFO : constant := 16#0040#;
+   SA_ONSTACK : constant := 16#0001#;
+
+   function sigaction
+     (sig  : Signal;
+      act  : struct_sigaction_ptr;
+      oact : struct_sigaction_ptr) return int;
+   pragma Import (C, sigaction, "sigaction");
+
+   ----------
+   -- Time --
+   ----------
+
+   Time_Slice_Supported : constant Boolean := True;
+   --  Indicates whether time slicing is supported (i.e SCHED_RR is supported)
+
+   type timespec is private;
+
+   function nanosleep (rqtp, rmtp : access timespec)  return int;
+   pragma Import (C, nanosleep, "nanosleep");
+
+   type clockid_t is new int;
+
+   function clock_gettime
+     (clock_id : clockid_t;
+      tp       : access timespec)
+      return int;
+   pragma Import (C, clock_gettime, "clock_gettime");
+
+   function To_Duration (TS : timespec) return Duration;
+   pragma Inline (To_Duration);
+
+   function To_Timespec (D : Duration) return timespec;
+   pragma Inline (To_Timespec);
+
+   type struct_timezone is record
+      tz_minuteswest : int;
+      tz_dsttime     : int;
+   end record;
+   pragma Convention (C, struct_timezone);
+
+   procedure usleep (useconds : unsigned_long);
+   pragma Import (C, usleep, "usleep");
+
+   -------------------------
+   -- Priority Scheduling --
+   -------------------------
+
+   SCHED_FIFO  : constant := 1;
+   SCHED_OTHER : constant := 2;
+   SCHED_RR    : constant := 3;
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int;
+   --  Maps System.Any_Priority to a POSIX priority
+
+   -------------
+   -- Process --
+   -------------
+
+   type pid_t is private;
+
+   function kill (pid : pid_t; sig : Signal) return int;
+   pragma Import (C, kill, "kill");
+
+   function getpid return pid_t;
+   pragma Import (C, getpid, "getpid");
+
+   ---------
+   -- LWP --
+   ---------
+
+   function lwp_self return System.Address;
+   --  lwp_self does not exist on this thread library, revert to pthread_self
+   --  which is the closest approximation (with getpid). This function is
+   --  needed to share 7staprop.adb across POSIX-like targets.
+   pragma Import (C, lwp_self, "pthread_self");
+
+   -------------
+   -- Threads --
+   -------------
+
+   type Thread_Body is access
+     function (arg : System.Address) return System.Address;
+   pragma Convention (C, Thread_Body);
+
+   function Thread_Body_Access is new
+     Ada.Unchecked_Conversion (System.Address, Thread_Body);
+
+   type pthread_t           is private;
+   subtype Thread_Id        is pthread_t;
+
+   type pthread_mutex_t     is limited private;
+   type pthread_cond_t      is limited private;
+   type pthread_attr_t      is limited private;
+   type pthread_mutexattr_t is limited private;
+   type pthread_condattr_t  is limited private;
+   type pthread_key_t       is private;
+
+   PTHREAD_CREATE_DETACHED : constant := 1;
+   PTHREAD_CREATE_JOINABLE : constant := 0;
+
+   PTHREAD_SCOPE_PROCESS : constant := 0;
+   PTHREAD_SCOPE_SYSTEM  : constant := 2;
+
+   --  Read/Write lock not supported on freebsd. To add support both types
+   --  pthread_rwlock_t and pthread_rwlockattr_t must properly be defined
+   --  with the associated routines pthread_rwlock_[init/destroy] and
+   --  pthread_rwlock_[rdlock/wrlock/unlock].
+
+   subtype pthread_rwlock_t     is pthread_mutex_t;
+   subtype pthread_rwlockattr_t is pthread_mutexattr_t;
+
+   -----------
+   -- Stack --
+   -----------
+
+   type stack_t is record
+      ss_sp    : System.Address;
+      ss_size  : size_t;
+      ss_flags : int;
+   end record;
+   pragma Convention (C, stack_t);
+
+   function sigaltstack
+     (ss  : not null access stack_t;
+      oss : access stack_t) return int;
+   pragma Import (C, sigaltstack, "sigaltstack");
+
+   Alternate_Stack : aliased System.Address;
+   --  This is a dummy definition, never used (Alternate_Stack_Size is null)
+
+   Alternate_Stack_Size : constant := 0;
+   --  No alternate signal stack is used on this platform
+
+   Stack_Base_Available : constant Boolean := False;
+   --  Indicates whether the stack base is available on this target. This
+   --  allows us to share s-osinte.adb between all the FSU run time. Note that
+   --  this value can only be true if pthread_t has a complete definition that
+   --  corresponds exactly to the C header files.
+
+   function Get_Stack_Base (thread : pthread_t) return Address;
+   pragma Inline (Get_Stack_Base);
+   --  returns the stack base of the specified thread. Only call this function
+   --  when Stack_Base_Available is True.
+
+   function Get_Page_Size return size_t;
+   function Get_Page_Size return Address;
+   pragma Import (C, Get_Page_Size, "getpagesize");
+   --  Returns the size of a page
+
+   PROT_NONE  : constant := 0;
+   PROT_READ  : constant := 1;
+   PROT_WRITE : constant := 2;
+   PROT_EXEC  : constant := 4;
+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;
+   PROT_ON    : constant := PROT_NONE;
+   PROT_OFF   : constant := PROT_ALL;
+
+   function mprotect (addr : Address; len : size_t; prot : int) return int;
+   pragma Import (C, mprotect);
+
+   ---------------------------------------
+   -- Nonstandard Thread Initialization --
+   ---------------------------------------
+
+   --  FSU_THREADS requires pthread_init, which is nonstandard and this should
+   --  be invoked during the elaboration of s-taprop.adb.
+
+   --  FreeBSD does not require this so we provide an empty Ada body
+
+   procedure pthread_init;
+
+   -------------------------
+   -- POSIX.1c  Section 3 --
+   -------------------------
+
+   function sigwait
+     (set : access sigset_t;
+      sig : access Signal) return int;
+   pragma Import (C, sigwait, "sigwait");
+
+   function pthread_kill
+     (thread : pthread_t;
+      sig    : Signal) return int;
+   pragma Import (C, pthread_kill, "pthread_kill");
+
+   function pthread_sigmask
+     (how  : int;
+      set  : access sigset_t;
+      oset : access sigset_t) return int;
+   pragma Import (C, pthread_sigmask, "pthread_sigmask");
+
+   --------------------------
+   -- POSIX.1c  Section 11 --
+   --------------------------
+
+   function pthread_mutexattr_init
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_init, "pthread_mutexattr_init");
+
+   function pthread_mutexattr_destroy
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_destroy, "pthread_mutexattr_destroy");
+
+   function pthread_mutex_init
+     (mutex : access pthread_mutex_t;
+      attr  : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutex_init, "pthread_mutex_init");
+
+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_destroy, "pthread_mutex_destroy");
+
+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_lock, "pthread_mutex_lock");
+
+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_unlock, "pthread_mutex_unlock");
+
+   function pthread_condattr_init
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_init, "pthread_condattr_init");
+
+   function pthread_condattr_destroy
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_destroy, "pthread_condattr_destroy");
+
+   function pthread_cond_init
+     (cond : access pthread_cond_t;
+      attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_cond_init, "pthread_cond_init");
+
+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_destroy, "pthread_cond_destroy");
+
+   function pthread_cond_signal (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_signal, "pthread_cond_signal");
+
+   function pthread_cond_wait
+     (cond  : access pthread_cond_t;
+      mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_cond_wait, "pthread_cond_wait");
+
+   function pthread_cond_timedwait
+     (cond    : access pthread_cond_t;
+      mutex   : access pthread_mutex_t;
+      abstime : access timespec) return int;
+   pragma Import (C, pthread_cond_timedwait, "pthread_cond_timedwait");
+
+   Relative_Timed_Wait : constant Boolean := False;
+   --  pthread_cond_timedwait requires an absolute delay time
+
+   --------------------------
+   -- POSIX.1c  Section 13 --
+   --------------------------
+
+   PTHREAD_PRIO_NONE    : constant := 0;
+   PTHREAD_PRIO_PROTECT : constant := 2;
+   PTHREAD_PRIO_INHERIT : constant := 1;
+
+   function pthread_mutexattr_setprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : int) return int;
+   pragma Import
+      (C, pthread_mutexattr_setprotocol, "pthread_mutexattr_setprotocol");
+
+   function pthread_mutexattr_getprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprotocol, "pthread_mutexattr_getprotocol");
+
+   function pthread_mutexattr_setprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : int) return int;
+   pragma Import
+     (C, pthread_mutexattr_setprioceiling,
+      "pthread_mutexattr_setprioceiling");
+
+   function pthread_mutexattr_getprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprioceiling,
+      "pthread_mutexattr_getprioceiling");
+
+   type struct_sched_param is record
+      sched_priority : int;
+   end record;
+   pragma Convention (C, struct_sched_param);
+
+   function pthread_getschedparam
+     (thread : pthread_t;
+      policy : access int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_getschedparam, "pthread_getschedparam");
+
+   function pthread_setschedparam
+     (thread : pthread_t;
+      policy : int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
+
+   function pthread_attr_setscope
+     (attr            : access pthread_attr_t;
+      contentionscope : int) return int;
+   pragma Import (C, pthread_attr_setscope, "pthread_attr_setscope");
+
+   function pthread_attr_getscope
+     (attr            : access pthread_attr_t;
+      contentionscope : access int) return int;
+   pragma Import (C, pthread_attr_getscope, "pthread_attr_getscope");
+
+   function pthread_attr_setinheritsched
+     (attr            : access pthread_attr_t;
+      inheritsched : int) return int;
+   pragma Import
+     (C, pthread_attr_setinheritsched, "pthread_attr_setinheritsched");
+
+   function pthread_attr_getinheritsched
+     (attr         : access pthread_attr_t;
+      inheritsched : access int) return int;
+   pragma Import
+     (C, pthread_attr_getinheritsched, "pthread_attr_getinheritsched");
+
+   function pthread_attr_setschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : int) return int;
+   pragma Import (C, pthread_attr_setschedpolicy,
+     "pthread_attr_setschedpolicy");
+
+   function pthread_attr_getschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : access int) return int;
+   pragma Import (C, pthread_attr_getschedpolicy,
+     "pthread_attr_getschedpolicy");
+
+   function pthread_attr_setschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : int) return int;
+   pragma Import (C, pthread_attr_setschedparam, "pthread_attr_setschedparam");
+
+   function pthread_attr_getschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : access int) return int;
+   pragma Import (C, pthread_attr_getschedparam, "pthread_attr_getschedparam");
+
+   function sched_yield return int;
+   pragma Import (C, sched_yield, "pthread_yield");
+
+   --------------------------
+   -- P1003.1c  Section 16 --
+   --------------------------
+
+   function pthread_attr_init (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_init, "pthread_attr_init");
+
+   function pthread_attr_destroy
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_destroy, "pthread_attr_destroy");
+
+   function pthread_attr_setdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : int) return int;
+   pragma Import
+     (C, pthread_attr_setdetachstate, "pthread_attr_setdetachstate");
+
+   function pthread_attr_getdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : access int) return int;
+   pragma Import
+     (C, pthread_attr_getdetachstate, "pthread_attr_getdetachstate");
+
+   function pthread_attr_getstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : access size_t) return int;
+   pragma Import
+     (C, pthread_attr_getstacksize, "pthread_attr_getstacksize");
+
+   function pthread_attr_setstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : size_t) return int;
+   pragma Import
+     (C, pthread_attr_setstacksize, "pthread_attr_setstacksize");
+
+   function pthread_create
+     (thread        : access pthread_t;
+      attributes    : access pthread_attr_t;
+      start_routine : Thread_Body;
+      arg           : System.Address) return int;
+   pragma Import (C, pthread_create, "pthread_create");
+
+   function pthread_detach (thread : pthread_t) return int;
+   pragma Import (C, pthread_detach, "pthread_detach");
+
+   procedure pthread_exit (status : System.Address);
+   pragma Import (C, pthread_exit, "pthread_exit");
+
+   function pthread_self return pthread_t;
+   pragma Import (C, pthread_self, "pthread_self");
+
+   --------------------------
+   -- POSIX.1c  Section 17 --
+   --------------------------
+
+   function pthread_setspecific
+     (key   : pthread_key_t;
+      value : System.Address) return  int;
+   pragma Import (C, pthread_setspecific, "pthread_setspecific");
+
+   function pthread_getspecific (key : pthread_key_t) return System.Address;
+   pragma Import (C, pthread_getspecific, "pthread_getspecific");
+
+   type destructor_pointer is access procedure (arg : System.Address);
+   pragma Convention (C, destructor_pointer);
+
+   function pthread_key_create
+     (key        : access pthread_key_t;
+      destructor : destructor_pointer) return int;
+   pragma Import (C, pthread_key_create, "pthread_key_create");
+
+   ------------------------------------
+   -- Non-portable Pthread Functions --
+   ------------------------------------
+
+   function pthread_set_name_np
+     (thread : pthread_t;
+      name   : System.Address) return int;
+   pragma Import (C, pthread_set_name_np, "pthread_set_name_np");
+
+private
+
+   type sigset_t is array (1 .. 4) of unsigned;
+
+   --  In FreeBSD the component sa_handler turns out to
+   --  be one a union type, and the selector is a macro:
+   --  #define sa_handler __sigaction_u._handler
+   --  #define sa_sigaction __sigaction_u._sigaction
+
+   --  Should we add a signal_context type here ???
+   --  How could it be done independent of the CPU architecture ???
+   --  sigcontext type is opaque, so it is architecturally neutral.
+   --  It is always passed as an access type, so define it as an empty record
+   --  since the contents are not used anywhere.
+
+   type struct_sigcontext is null record;
+   pragma Convention (C, struct_sigcontext);
+
+   type pid_t is new int;
+
+   type time_t is new int;
+
+   type timespec is record
+      tv_sec  : time_t;
+      tv_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type pthread_t           is new System.Address;
+   type pthread_attr_t      is new System.Address;
+   type pthread_mutex_t     is new System.Address;
+   type pthread_mutexattr_t is new System.Address;
+   type pthread_cond_t      is new System.Address;
+   type pthread_condattr_t  is new System.Address;
+   type pthread_key_t       is new int;
+
+end System.OS_Interface;
--- /dev/null
+++ gcc/ada/s-osinte-freebsd64.ads
@@ -0,0 +1,649 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                   S p e c                                --
+--                                                                          --
+--             Copyright (C) 1991-1994, Florida State University            --
+--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University. It is --
+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
+-- State University (http://www.gnat.com).                                  --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the FreeBSD PTHREADS version of this package
+
+--  This package encapsulates all direct interfaces to OS services
+--  that are needed by the tasking run-time (libgnarl).
+
+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma
+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.
+
+with Ada.Unchecked_Conversion;
+
+with Interfaces.C;
+
+package System.OS_Interface is
+   pragma Preelaborate;
+
+   pragma Linker_Options ("-pthread");
+
+   subtype int            is Interfaces.C.int;
+   subtype short          is Interfaces.C.short;
+   subtype long           is Interfaces.C.long;
+   subtype unsigned       is Interfaces.C.unsigned;
+   subtype unsigned_short is Interfaces.C.unsigned_short;
+   subtype unsigned_long  is Interfaces.C.unsigned_long;
+   subtype unsigned_char  is Interfaces.C.unsigned_char;
+   subtype plain_char     is Interfaces.C.plain_char;
+   subtype size_t         is Interfaces.C.size_t;
+   subtype int64_t        is Interfaces.Integer_64;
+
+   -----------
+   -- Errno --
+   -----------
+
+   function Errno return int;
+   pragma Inline (Errno);
+
+   EAGAIN    : constant := 35;
+   EINTR     : constant := 4;
+   EINVAL    : constant := 22;
+   ENOMEM    : constant := 12;
+   ETIMEDOUT : constant := 60;
+
+   -------------
+   -- Signals --
+   -------------
+
+   Max_Interrupt : constant := 31;
+   type Signal is new int range 0 .. Max_Interrupt;
+   for Signal'Size use int'Size;
+
+   SIGHUP     : constant := 1; --  hangup
+   SIGINT     : constant := 2; --  interrupt (rubout)
+   SIGQUIT    : constant := 3; --  quit (ASCD FS)
+   SIGILL     : constant := 4; --  illegal instruction (not reset)
+   SIGTRAP    : constant := 5; --  trace trap (not reset)
+   SIGIOT     : constant := 6; --  IOT instruction
+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future
+   SIGEMT     : constant := 7; --  EMT instruction
+   SIGFPE     : constant := 8; --  floating point exception
+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)
+   SIGBUS     : constant := 10; --  bus error
+   SIGSEGV    : constant := 11; --  segmentation violation
+   SIGSYS     : constant := 12; --  bad argument to system call
+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it
+   SIGALRM    : constant := 14; --  alarm clock
+   SIGTERM    : constant := 15; --  software termination signal from kill
+   SIGURG     : constant := 16; --  urgent condition on IO channel
+   SIGSTOP    : constant := 17; --  stop (cannot be caught or ignored)
+   SIGTSTP    : constant := 18; --  user stop requested from tty
+   SIGCONT    : constant := 19; --  stopped process has been continued
+   SIGCLD     : constant := 20; --  alias for SIGCHLD
+   SIGCHLD    : constant := 20; --  child status change
+   SIGTTIN    : constant := 21; --  background tty read attempted
+   SIGTTOU    : constant := 22; --  background tty write attempted
+   SIGIO      : constant := 23; --  I/O possible (Solaris SIGPOLL alias)
+   SIGXCPU    : constant := 24; --  CPU time limit exceeded
+   SIGXFSZ    : constant := 25; --  filesize limit exceeded
+   SIGVTALRM  : constant := 26; --  virtual timer expired
+   SIGPROF    : constant := 27; --  profiling timer expired
+   SIGWINCH   : constant := 28; --  window size change
+   SIGINFO    : constant := 29; --  information request (BSD)
+   SIGUSR1    : constant := 30; --  user defined signal 1
+   SIGUSR2    : constant := 31; --  user defined signal 2
+
+   SIGADAABORT : constant := SIGABRT;
+   --  Change this if you want to use another signal for task abort.
+   --  SIGTERM might be a good one.
+
+   type Signal_Set is array (Natural range <>) of Signal;
+
+   --  Interrupts that must be unmasked at all times.  FreeBSD
+   --  pthreads will not allow an application to mask out any
+   --  interrupt needed by the threads library.
+   Unmasked : constant Signal_Set :=
+     (SIGTRAP, SIGBUS, SIGTTIN, SIGTTOU, SIGTSTP);
+
+   --  FreeBSD will uses SIGPROF for timing.  Do not allow a
+   --  handler to attach to this signal.
+   Reserved : constant Signal_Set := (0 .. 0 => SIGPROF);
+
+   type sigset_t is private;
+
+   function sigaddset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigaddset, "sigaddset");
+
+   function sigdelset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigdelset, "sigdelset");
+
+   function sigfillset (set : access sigset_t) return int;
+   pragma Import (C, sigfillset, "sigfillset");
+
+   function sigismember
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigismember, "sigismember");
+
+   function sigemptyset (set : access sigset_t) return int;
+   pragma Import (C, sigemptyset, "sigemptyset");
+
+   --  sigcontext is architecture dependent, so define it private
+   type struct_sigcontext is private;
+
+   type old_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_mask    : sigset_t;
+      sa_flags   : int;
+   end record;
+   pragma Convention (C, old_struct_sigaction);
+
+   type new_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_flags   : int;
+      sa_mask    : sigset_t;
+   end record;
+   pragma Convention (C, new_struct_sigaction);
+
+   subtype struct_sigaction is new_struct_sigaction;
+   type struct_sigaction_ptr is access all struct_sigaction;
+
+   SIG_BLOCK   : constant := 1;
+   SIG_UNBLOCK : constant := 2;
+   SIG_SETMASK : constant := 3;
+
+   SIG_DFL : constant := 0;
+   SIG_IGN : constant := 1;
+
+   SA_SIGINFO : constant := 16#0040#;
+   SA_ONSTACK : constant := 16#0001#;
+
+   function sigaction
+     (sig  : Signal;
+      act  : struct_sigaction_ptr;
+      oact : struct_sigaction_ptr) return int;
+   pragma Import (C, sigaction, "sigaction");
+
+   ----------
+   -- Time --
+   ----------
+
+   Time_Slice_Supported : constant Boolean := True;
+   --  Indicates whether time slicing is supported (i.e SCHED_RR is supported)
+
+   type timespec is private;
+
+   function nanosleep (rqtp, rmtp : access timespec)  return int;
+   pragma Import (C, nanosleep, "nanosleep");
+
+   type clockid_t is new int;
+
+   function clock_gettime
+     (clock_id : clockid_t;
+      tp       : access timespec)
+      return int;
+   pragma Import (C, clock_gettime, "clock_gettime");
+
+   function To_Duration (TS : timespec) return Duration;
+   pragma Inline (To_Duration);
+
+   function To_Timespec (D : Duration) return timespec;
+   pragma Inline (To_Timespec);
+
+   type struct_timezone is record
+      tz_minuteswest : int;
+      tz_dsttime     : int;
+   end record;
+   pragma Convention (C, struct_timezone);
+
+   procedure usleep (useconds : unsigned_long);
+   pragma Import (C, usleep, "usleep");
+
+   -------------------------
+   -- Priority Scheduling --
+   -------------------------
+
+   SCHED_FIFO  : constant := 1;
+   SCHED_OTHER : constant := 2;
+   SCHED_RR    : constant := 3;
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int;
+   --  Maps System.Any_Priority to a POSIX priority
+
+   -------------
+   -- Process --
+   -------------
+
+   type pid_t is private;
+
+   function kill (pid : pid_t; sig : Signal) return int;
+   pragma Import (C, kill, "kill");
+
+   function getpid return pid_t;
+   pragma Import (C, getpid, "getpid");
+
+   ---------
+   -- LWP --
+   ---------
+
+   function lwp_self return System.Address;
+   --  lwp_self does not exist on this thread library, revert to pthread_self
+   --  which is the closest approximation (with getpid). This function is
+   --  needed to share 7staprop.adb across POSIX-like targets.
+   pragma Import (C, lwp_self, "pthread_self");
+
+   -------------
+   -- Threads --
+   -------------
+
+   type Thread_Body is access
+     function (arg : System.Address) return System.Address;
+   pragma Convention (C, Thread_Body);
+
+   function Thread_Body_Access is new
+     Ada.Unchecked_Conversion (System.Address, Thread_Body);
+
+   type pthread_t           is private;
+   subtype Thread_Id        is pthread_t;
+
+   type pthread_mutex_t     is limited private;
+   type pthread_cond_t      is limited private;
+   type pthread_attr_t      is limited private;
+   type pthread_mutexattr_t is limited private;
+   type pthread_condattr_t  is limited private;
+   type pthread_key_t       is private;
+
+   PTHREAD_CREATE_DETACHED : constant := 1;
+   PTHREAD_CREATE_JOINABLE : constant := 0;
+
+   PTHREAD_SCOPE_PROCESS : constant := 0;
+   PTHREAD_SCOPE_SYSTEM  : constant := 2;
+
+   --  Read/Write lock not supported on freebsd. To add support both types
+   --  pthread_rwlock_t and pthread_rwlockattr_t must properly be defined
+   --  with the associated routines pthread_rwlock_[init/destroy] and
+   --  pthread_rwlock_[rdlock/wrlock/unlock].
+
+   subtype pthread_rwlock_t     is pthread_mutex_t;
+   subtype pthread_rwlockattr_t is pthread_mutexattr_t;
+
+   -----------
+   -- Stack --
+   -----------
+
+   type stack_t is record
+      ss_sp    : System.Address;
+      ss_size  : size_t;
+      ss_flags : int;
+   end record;
+   pragma Convention (C, stack_t);
+
+   function sigaltstack
+     (ss  : not null access stack_t;
+      oss : access stack_t) return int;
+   pragma Import (C, sigaltstack, "sigaltstack");
+
+   Alternate_Stack : aliased System.Address;
+   --  This is a dummy definition, never used (Alternate_Stack_Size is null)
+
+   Alternate_Stack_Size : constant := 0;
+   --  No alternate signal stack is used on this platform
+
+   Stack_Base_Available : constant Boolean := False;
+   --  Indicates whether the stack base is available on this target. This
+   --  allows us to share s-osinte.adb between all the FSU run time. Note that
+   --  this value can only be true if pthread_t has a complete definition that
+   --  corresponds exactly to the C header files.
+
+   function Get_Stack_Base (thread : pthread_t) return Address;
+   pragma Inline (Get_Stack_Base);
+   --  returns the stack base of the specified thread. Only call this function
+   --  when Stack_Base_Available is True.
+
+   function Get_Page_Size return size_t;
+   function Get_Page_Size return Address;
+   pragma Import (C, Get_Page_Size, "getpagesize");
+   --  Returns the size of a page
+
+   PROT_NONE  : constant := 0;
+   PROT_READ  : constant := 1;
+   PROT_WRITE : constant := 2;
+   PROT_EXEC  : constant := 4;
+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;
+   PROT_ON    : constant := PROT_NONE;
+   PROT_OFF   : constant := PROT_ALL;
+
+   function mprotect (addr : Address; len : size_t; prot : int) return int;
+   pragma Import (C, mprotect);
+
+   ---------------------------------------
+   -- Nonstandard Thread Initialization --
+   ---------------------------------------
+
+   --  FSU_THREADS requires pthread_init, which is nonstandard and this should
+   --  be invoked during the elaboration of s-taprop.adb.
+
+   --  FreeBSD does not require this so we provide an empty Ada body
+
+   procedure pthread_init;
+
+   -------------------------
+   -- POSIX.1c  Section 3 --
+   -------------------------
+
+   function sigwait
+     (set : access sigset_t;
+      sig : access Signal) return int;
+   pragma Import (C, sigwait, "sigwait");
+
+   function pthread_kill
+     (thread : pthread_t;
+      sig    : Signal) return int;
+   pragma Import (C, pthread_kill, "pthread_kill");
+
+   function pthread_sigmask
+     (how  : int;
+      set  : access sigset_t;
+      oset : access sigset_t) return int;
+   pragma Import (C, pthread_sigmask, "pthread_sigmask");
+
+   --------------------------
+   -- POSIX.1c  Section 11 --
+   --------------------------
+
+   function pthread_mutexattr_init
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_init, "pthread_mutexattr_init");
+
+   function pthread_mutexattr_destroy
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_destroy, "pthread_mutexattr_destroy");
+
+   function pthread_mutex_init
+     (mutex : access pthread_mutex_t;
+      attr  : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutex_init, "pthread_mutex_init");
+
+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_destroy, "pthread_mutex_destroy");
+
+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_lock, "pthread_mutex_lock");
+
+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_unlock, "pthread_mutex_unlock");
+
+   function pthread_condattr_init
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_init, "pthread_condattr_init");
+
+   function pthread_condattr_destroy
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_destroy, "pthread_condattr_destroy");
+
+   function pthread_cond_init
+     (cond : access pthread_cond_t;
+      attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_cond_init, "pthread_cond_init");
+
+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_destroy, "pthread_cond_destroy");
+
+   function pthread_cond_signal (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_signal, "pthread_cond_signal");
+
+   function pthread_cond_wait
+     (cond  : access pthread_cond_t;
+      mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_cond_wait, "pthread_cond_wait");
+
+   function pthread_cond_timedwait
+     (cond    : access pthread_cond_t;
+      mutex   : access pthread_mutex_t;
+      abstime : access timespec) return int;
+   pragma Import (C, pthread_cond_timedwait, "pthread_cond_timedwait");
+
+   Relative_Timed_Wait : constant Boolean := False;
+   --  pthread_cond_timedwait requires an absolute delay time
+
+   --------------------------
+   -- POSIX.1c  Section 13 --
+   --------------------------
+
+   PTHREAD_PRIO_NONE    : constant := 0;
+   PTHREAD_PRIO_PROTECT : constant := 2;
+   PTHREAD_PRIO_INHERIT : constant := 1;
+
+   function pthread_mutexattr_setprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : int) return int;
+   pragma Import
+      (C, pthread_mutexattr_setprotocol, "pthread_mutexattr_setprotocol");
+
+   function pthread_mutexattr_getprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprotocol, "pthread_mutexattr_getprotocol");
+
+   function pthread_mutexattr_setprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : int) return int;
+   pragma Import
+     (C, pthread_mutexattr_setprioceiling,
+      "pthread_mutexattr_setprioceiling");
+
+   function pthread_mutexattr_getprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprioceiling,
+      "pthread_mutexattr_getprioceiling");
+
+   type struct_sched_param is record
+      sched_priority : int;
+   end record;
+   pragma Convention (C, struct_sched_param);
+
+   function pthread_getschedparam
+     (thread : pthread_t;
+      policy : access int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_getschedparam, "pthread_getschedparam");
+
+   function pthread_setschedparam
+     (thread : pthread_t;
+      policy : int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
+
+   function pthread_attr_setscope
+     (attr            : access pthread_attr_t;
+      contentionscope : int) return int;
+   pragma Import (C, pthread_attr_setscope, "pthread_attr_setscope");
+
+   function pthread_attr_getscope
+     (attr            : access pthread_attr_t;
+      contentionscope : access int) return int;
+   pragma Import (C, pthread_attr_getscope, "pthread_attr_getscope");
+
+   function pthread_attr_setinheritsched
+     (attr            : access pthread_attr_t;
+      inheritsched : int) return int;
+   pragma Import
+     (C, pthread_attr_setinheritsched, "pthread_attr_setinheritsched");
+
+   function pthread_attr_getinheritsched
+     (attr         : access pthread_attr_t;
+      inheritsched : access int) return int;
+   pragma Import
+     (C, pthread_attr_getinheritsched, "pthread_attr_getinheritsched");
+
+   function pthread_attr_setschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : int) return int;
+   pragma Import (C, pthread_attr_setschedpolicy,
+     "pthread_attr_setschedpolicy");
+
+   function pthread_attr_getschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : access int) return int;
+   pragma Import (C, pthread_attr_getschedpolicy,
+     "pthread_attr_getschedpolicy");
+
+   function pthread_attr_setschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : int) return int;
+   pragma Import (C, pthread_attr_setschedparam, "pthread_attr_setschedparam");
+
+   function pthread_attr_getschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : access int) return int;
+   pragma Import (C, pthread_attr_getschedparam, "pthread_attr_getschedparam");
+
+   function sched_yield return int;
+   pragma Import (C, sched_yield, "pthread_yield");
+
+   --------------------------
+   -- P1003.1c  Section 16 --
+   --------------------------
+
+   function pthread_attr_init (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_init, "pthread_attr_init");
+
+   function pthread_attr_destroy
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_destroy, "pthread_attr_destroy");
+
+   function pthread_attr_setdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : int) return int;
+   pragma Import
+     (C, pthread_attr_setdetachstate, "pthread_attr_setdetachstate");
+
+   function pthread_attr_getdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : access int) return int;
+   pragma Import
+     (C, pthread_attr_getdetachstate, "pthread_attr_getdetachstate");
+
+   function pthread_attr_getstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : access size_t) return int;
+   pragma Import
+     (C, pthread_attr_getstacksize, "pthread_attr_getstacksize");
+
+   function pthread_attr_setstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : size_t) return int;
+   pragma Import
+     (C, pthread_attr_setstacksize, "pthread_attr_setstacksize");
+
+   function pthread_create
+     (thread        : access pthread_t;
+      attributes    : access pthread_attr_t;
+      start_routine : Thread_Body;
+      arg           : System.Address) return int;
+   pragma Import (C, pthread_create, "pthread_create");
+
+   function pthread_detach (thread : pthread_t) return int;
+   pragma Import (C, pthread_detach, "pthread_detach");
+
+   procedure pthread_exit (status : System.Address);
+   pragma Import (C, pthread_exit, "pthread_exit");
+
+   function pthread_self return pthread_t;
+   pragma Import (C, pthread_self, "pthread_self");
+
+   --------------------------
+   -- POSIX.1c  Section 17 --
+   --------------------------
+
+   function pthread_setspecific
+     (key   : pthread_key_t;
+      value : System.Address) return  int;
+   pragma Import (C, pthread_setspecific, "pthread_setspecific");
+
+   function pthread_getspecific (key : pthread_key_t) return System.Address;
+   pragma Import (C, pthread_getspecific, "pthread_getspecific");
+
+   type destructor_pointer is access procedure (arg : System.Address);
+   pragma Convention (C, destructor_pointer);
+
+   function pthread_key_create
+     (key        : access pthread_key_t;
+      destructor : destructor_pointer) return int;
+   pragma Import (C, pthread_key_create, "pthread_key_create");
+
+   ------------------------------------
+   -- Non-portable Pthread Functions --
+   ------------------------------------
+
+   function pthread_set_name_np
+     (thread : pthread_t;
+      name   : System.Address) return int;
+   pragma Import (C, pthread_set_name_np, "pthread_set_name_np");
+
+private
+
+   type sigset_t is array (1 .. 4) of unsigned;
+
+   --  In FreeBSD the component sa_handler turns out to
+   --  be one a union type, and the selector is a macro:
+   --  #define sa_handler __sigaction_u._handler
+   --  #define sa_sigaction __sigaction_u._sigaction
+
+   --  Should we add a signal_context type here ???
+   --  How could it be done independent of the CPU architecture ???
+   --  sigcontext type is opaque, so it is architecturally neutral.
+   --  It is always passed as an access type, so define it as an empty record
+   --  since the contents are not used anywhere.
+
+   type struct_sigcontext is null record;
+   pragma Convention (C, struct_sigcontext);
+
+   type pid_t is new int;
+
+   type time_t is new int64_t;
+
+   type timespec is record
+      tv_sec  : time_t;
+      tv_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type pthread_t           is new System.Address;
+   type pthread_attr_t      is new System.Address;
+   type pthread_mutex_t     is new System.Address;
+   type pthread_mutexattr_t is new System.Address;
+   type pthread_cond_t      is new System.Address;
+   type pthread_condattr_t  is new System.Address;
+   type pthread_key_t       is new int;
+
+end System.OS_Interface;
--- /dev/null
+++ gcc/ada/s-osinte-netbsd.adb
@@ -0,0 +1,140 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                   B o d y                                --
+--                                                                          --
+--          Copyright (C) 1991-2009, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University. It is --
+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
+-- State University (http://www.gnat.com).                                  --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the NetBSD THREADS version of this package
+
+with Interfaces.C; use Interfaces.C;
+
+package body System.OS_Interface is
+
+   -----------
+   -- Errno --
+   -----------
+
+   function Errno return int is
+      type int_ptr is access all int;
+
+      function internal_errno return int_ptr;
+      pragma Import (C, internal_errno, "__errno");
+
+   begin
+      return (internal_errno.all);
+   end Errno;
+
+   --------------------
+   -- Get_Stack_Base --
+   --------------------
+
+   function Get_Stack_Base (thread : pthread_t) return Address is
+      pragma Unreferenced (thread);
+   begin
+      return Null_Address;
+   end Get_Stack_Base;
+
+   ------------------
+   -- pthread_init --
+   ------------------
+
+   procedure pthread_init is
+   begin
+      null;
+   end pthread_init;
+
+   -----------------------------------
+   -- pthread_mutexattr_setprotocol --
+   -----------------------------------
+
+   function pthread_mutexattr_setprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : int) return int is
+      pragma Unreferenced (attr, protocol);
+   begin
+      return 0;
+   end pthread_mutexattr_setprotocol;
+
+   --------------------------------------
+   -- pthread_mutexattr_setprioceiling --
+   --------------------------------------
+
+   function pthread_mutexattr_setprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : int) return int is
+      pragma Unreferenced (attr, prioceiling);
+   begin
+      return 0;
+   end pthread_mutexattr_setprioceiling;
+
+   -----------------
+   -- To_Duration --
+   -----------------
+
+   function To_Duration (TS : timespec) return Duration is
+   begin
+      return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;
+   end To_Duration;
+
+   ------------------------
+   -- To_Target_Priority --
+   ------------------------
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int
+   is
+   begin
+      return Interfaces.C.int (Prio);
+   end To_Target_Priority;
+
+   -----------------
+   -- To_Timespec --
+   -----------------
+
+   function To_Timespec (D : Duration) return timespec is
+      S : time_t;
+      F : Duration;
+
+   begin
+      S := time_t (Long_Long_Integer (D));
+      F := D - Duration (S);
+
+      --  If F has negative value due to a round-up, adjust for positive F
+      --  value.
+
+      if F < 0.0 then
+         S := S - 1;
+         F := F + 1.0;
+      end if;
+
+      return timespec'(tv_sec => S,
+                       tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));
+   end To_Timespec;
+
+end System.OS_Interface;
--- /dev/null
+++ gcc/ada/s-osinte-netbsd.ads
@@ -0,0 +1,674 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                   S p e c                                --
+--                                                                          --
+--             Copyright (C) 1991-1994, Florida State University            --
+--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University. It is --
+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
+-- State University (http://www.gnat.com).                                  --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the NetBSD PTHREADS version of this package.
+--  It is based off of the FreeBSD PTHREADS as of 4.2.3.
+
+--  This package encapsulates all direct interfaces to OS services
+--  that are needed by the tasking run-time (libgnarl).
+
+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma
+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.
+
+with Ada.Unchecked_Conversion;
+
+with Interfaces.C;
+
+package System.OS_Interface is
+   pragma Preelaborate;
+
+   pragma Linker_Options ("-pthread");
+
+   subtype int            is Interfaces.C.int;
+   subtype short          is Interfaces.C.short;
+   subtype long           is Interfaces.C.long;
+   subtype unsigned       is Interfaces.C.unsigned;
+   subtype unsigned_short is Interfaces.C.unsigned_short;
+   subtype unsigned_long  is Interfaces.C.unsigned_long;
+   subtype unsigned_char  is Interfaces.C.unsigned_char;
+   subtype plain_char     is Interfaces.C.plain_char;
+   subtype size_t         is Interfaces.C.size_t;
+
+   -----------
+   -- Errno --
+   -----------
+
+   function Errno return int;
+   pragma Inline (Errno);
+
+   EAGAIN    : constant := 35;
+   EINTR     : constant := 4;
+   EINVAL    : constant := 22;
+   ENOMEM    : constant := 12;
+   ETIMEDOUT : constant := 60;
+
+   -------------
+   -- Signals --
+   -------------
+
+   Max_Interrupt : constant := 63;
+   type Signal is new int range 0 .. Max_Interrupt;
+   for Signal'Size use int'Size;
+
+   SIGHUP     : constant := 1; --  hangup
+   SIGINT     : constant := 2; --  interrupt (rubout)
+   SIGQUIT    : constant := 3; --  quit (ASCD FS)
+   SIGILL     : constant := 4; --  illegal instruction (not reset)
+   SIGTRAP    : constant := 5; --  trace trap (not reset)
+   SIGIOT     : constant := 6; --  IOT instruction
+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future
+   SIGEMT     : constant := 7; --  EMT instruction
+   SIGFPE     : constant := 8; --  floating point exception
+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)
+   SIGBUS     : constant := 10; --  bus error
+   SIGSEGV    : constant := 11; --  segmentation violation
+   SIGSYS     : constant := 12; --  bad argument to system call
+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it
+   SIGALRM    : constant := 14; --  alarm clock
+   SIGTERM    : constant := 15; --  software termination signal from kill
+   SIGURG     : constant := 16; --  urgent condition on IO channel
+   SIGSTOP    : constant := 17; --  stop (cannot be caught or ignored)
+   SIGTSTP    : constant := 18; --  user stop requested from tty
+   SIGCONT    : constant := 19; --  stopped process has been continued
+   SIGCLD     : constant := 20; --  alias for SIGCHLD
+   SIGCHLD    : constant := 20; --  child status change
+   SIGTTIN    : constant := 21; --  background tty read attempted
+   SIGTTOU    : constant := 22; --  background tty write attempted
+   SIGIO      : constant := 23; --  I/O possible (Solaris SIGPOLL alias)
+   SIGXCPU    : constant := 24; --  CPU time limit exceeded
+   SIGXFSZ    : constant := 25; --  filesize limit exceeded
+   SIGVTALRM  : constant := 26; --  virtual timer expired
+   SIGPROF    : constant := 27; --  profiling timer expired
+   SIGWINCH   : constant := 28; --  window size change
+   SIGINFO    : constant := 29; --  information request (BSD)
+   SIGUSR1    : constant := 30; --  user defined signal 1
+   SIGUSR2    : constant := 31; --  user defined signal 2
+   SIGPWR     : constant := 32; --  power fail/restart (not reset when caught)
+
+   SIGADAABORT : constant := SIGABRT;
+   --  Change this if you want to use another signal for task abort.
+   --  SIGTERM might be a good one.
+
+   type Signal_Set is array (Natural range <>) of Signal;
+
+   --  Interrupts that must be unmasked at all times.  NetBSD
+   --  pthreads will not allow an application to mask out any
+   --  interrupt needed by the threads library.
+   Unmasked : constant Signal_Set :=
+     (SIGTRAP, SIGBUS, SIGTTIN, SIGTTOU, SIGTSTP);
+
+   --  NetBSD will uses SIGPROF for timing.  Do not allow a
+   --  handler to attach to this signal.
+   Reserved : constant Signal_Set := (0 .. 0 => SIGPROF);
+
+   type sigset_t is private;
+
+   function sigaddset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigaddset, "__sigaddset14");
+
+   function sigdelset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigdelset, "__sigdelset14");
+
+   function sigfillset (set : access sigset_t) return int;
+   pragma Import (C, sigfillset, "__sigfillset14");
+
+   function sigismember
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigismember, "__sigismember14");
+
+   function sigemptyset (set : access sigset_t) return int;
+   pragma Import (C, sigemptyset, "__sigemptyset14");
+
+   --  sigcontext is architecture dependent, so define it private
+   type struct_sigcontext is private;
+
+   type old_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_mask    : sigset_t;
+      sa_flags   : int;
+   end record;
+   pragma Convention (C, old_struct_sigaction);
+
+   type new_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_flags   : int;
+      sa_mask    : sigset_t;
+   end record;
+   pragma Convention (C, new_struct_sigaction);
+
+   subtype struct_sigaction is new_struct_sigaction;
+   type struct_sigaction_ptr is access all struct_sigaction;
+
+   SIG_BLOCK   : constant := 1;
+   SIG_UNBLOCK : constant := 2;
+   SIG_SETMASK : constant := 3;
+
+   SIG_DFL  : constant := 0;
+   SIG_IGN  : constant := 1;
+   SIG_ERR  : constant := -1;
+   SIG_HOLD : constant := 3;
+
+   SA_SIGINFO : constant := 16#0040#;
+   SA_ONSTACK : constant := 16#0001#;
+
+   function sigaction
+     (sig  : Signal;
+      act  : struct_sigaction_ptr;
+      oact : struct_sigaction_ptr) return int;
+   pragma Import (C, sigaction, "__sigaction14");
+
+   ----------
+   -- Time --
+   ----------
+
+   Time_Slice_Supported : constant Boolean := True;
+   --  Indicates whether time slicing is supported (i.e SCHED_RR is supported)
+
+   type timespec is private;
+
+   function nanosleep (rqtp, rmtp : access timespec)  return int;
+   pragma Import (C, nanosleep, "nanosleep");
+
+   type clockid_t is new int;
+
+   function clock_gettime
+     (clock_id : clockid_t;
+      tp       : access timespec)
+      return int;
+   pragma Import (C, clock_gettime, "clock_gettime");
+
+   function To_Duration (TS : timespec) return Duration;
+   pragma Inline (To_Duration);
+
+   function To_Timespec (D : Duration) return timespec;
+   pragma Inline (To_Timespec);
+
+   type struct_timezone is record
+      tz_minuteswest : int;
+      tz_dsttime     : int;
+   end record;
+   pragma Convention (C, struct_timezone);
+
+   -------------------------
+   -- Priority Scheduling --
+   -------------------------
+
+   SCHED_FIFO  : constant := 1;
+   SCHED_OTHER : constant := 2;
+   SCHED_RR    : constant := 3;
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int;
+   --  Maps System.Any_Priority to a POSIX priority
+
+   -------------
+   -- Process --
+   -------------
+
+   type pid_t is private;
+
+   function kill (pid : pid_t; sig : Signal) return int;
+   pragma Import (C, kill, "kill");
+
+   function getpid return pid_t;
+   pragma Import (C, getpid, "getpid");
+
+   ---------
+   -- LWP --
+   ---------
+
+   function lwp_self return System.Address;
+   --  lwp_self does not exist on this thread library, revert to pthread_self
+   --  which is the closest approximation (with getpid). This function is
+   --  needed to share 7staprop.adb across POSIX-like targets.
+   pragma Import (C, lwp_self, "pthread_self");
+
+   -------------
+   -- Threads --
+   -------------
+
+   type Thread_Body is access
+     function (arg : System.Address) return System.Address;
+   pragma Convention (C, Thread_Body);
+
+   function Thread_Body_Access is new
+     Ada.Unchecked_Conversion (System.Address, Thread_Body);
+
+   type pthread_t           is private;
+   subtype Thread_Id        is pthread_t;
+
+   type pthread_mutex_t     is limited private;
+   type pthread_cond_t      is limited private;
+   type pthread_attr_t      is limited private;
+   type pthread_mutexattr_t is limited private;
+   type pthread_condattr_t  is limited private;
+   type pthread_key_t       is private;
+
+   PTHREAD_CREATE_DETACHED : constant := 1;
+   PTHREAD_CREATE_JOINABLE : constant := 0;
+
+   PTHREAD_SCOPE_PROCESS : constant := 0;
+   PTHREAD_SCOPE_SYSTEM  : constant := 2;
+
+   --  Read/Write lock not supported on OpenBSD. To add support both types
+   --  pthread_rwlock_t and pthread_rwlockattr_t must properly be defined
+   --  with the associated routines pthread_rwlock_[init/destroy] and
+   --  pthread_rwlock_[rdlock/wrlock/unlock].
+
+   subtype pthread_rwlock_t     is pthread_mutex_t;
+   subtype pthread_rwlockattr_t is pthread_mutexattr_t;
+
+   -----------
+   -- Stack --
+   -----------
+
+   type stack_t is record
+      ss_sp    : System.Address;
+      ss_size  : size_t;
+      ss_flags : int;
+   end record;
+   pragma Convention (C, stack_t);
+
+   function sigaltstack
+     (ss  : not null access stack_t;
+      oss : access stack_t) return int;
+   pragma Import (C, sigaltstack, "sigaltstack");
+
+   Alternate_Stack : aliased System.Address;
+   --  This is a dummy definition, never used (Alternate_Stack_Size is null)
+
+   Alternate_Stack_Size : constant := 0;
+   --  No alternate signal stack is used on this platform
+
+   Stack_Base_Available : constant Boolean := False;
+   --  Indicates whether the stack base is available on this target. This
+   --  allows us to share s-osinte.adb between all the FSU run time. Note that
+   --  this value can only be true if pthread_t has a complete definition that
+   --  corresponds exactly to the C header files.
+
+   function Get_Stack_Base (thread : pthread_t) return Address;
+   pragma Inline (Get_Stack_Base);
+   --  returns the stack base of the specified thread. Only call this function
+   --  when Stack_Base_Available is True.
+
+   function Get_Page_Size return size_t;
+   function Get_Page_Size return Address;
+   pragma Import (C, Get_Page_Size, "getpagesize");
+   --  Returns the size of a page
+
+   PROT_NONE  : constant := 0;
+   PROT_READ  : constant := 1;
+   PROT_WRITE : constant := 2;
+   PROT_EXEC  : constant := 4;
+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;
+   PROT_ON    : constant := PROT_NONE;
+   PROT_OFF   : constant := PROT_ALL;
+
+   function mprotect (addr : Address; len : size_t; prot : int) return int;
+   pragma Import (C, mprotect);
+
+   ---------------------------------------
+   -- Nonstandard Thread Initialization --
+   ---------------------------------------
+
+   --  FSU_THREADS requires pthread_init, which is nonstandard and this should
+   --  be invoked during the elaboration of s-taprop.adb.
+
+   --  NetBSD does not require this so we provide an empty Ada body
+
+   procedure pthread_init;
+
+   -------------------------
+   -- POSIX.1c  Section 3 --
+   -------------------------
+
+   function sigwait
+     (set : access sigset_t;
+      sig : access Signal) return int;
+   pragma Import (C, sigwait, "sigwait");
+
+   function pthread_kill
+     (thread : pthread_t;
+      sig    : Signal) return int;
+   pragma Import (C, pthread_kill, "pthread_kill");
+
+   function pthread_sigmask
+     (how  : int;
+      set  : access sigset_t;
+      oset : access sigset_t) return int;
+   pragma Import (C, pthread_sigmask, "pthread_sigmask");
+
+   --------------------------
+   -- POSIX.1c  Section 11 --
+   --------------------------
+
+   function pthread_mutexattr_init
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_init, "pthread_mutexattr_init");
+
+   function pthread_mutexattr_destroy
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_destroy, "pthread_mutexattr_destroy");
+
+   function pthread_mutex_init
+     (mutex : access pthread_mutex_t;
+      attr  : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutex_init, "pthread_mutex_init");
+
+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_destroy, "pthread_mutex_destroy");
+
+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_lock, "pthread_mutex_lock");
+
+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_unlock, "pthread_mutex_unlock");
+
+   function pthread_condattr_init
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_init, "pthread_condattr_init");
+
+   function pthread_condattr_destroy
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_destroy, "pthread_condattr_destroy");
+
+   function pthread_cond_init
+     (cond : access pthread_cond_t;
+      attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_cond_init, "pthread_cond_init");
+
+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_destroy, "pthread_cond_destroy");
+
+   function pthread_cond_signal (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_signal, "pthread_cond_signal");
+
+   function pthread_cond_wait
+     (cond  : access pthread_cond_t;
+      mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_cond_wait, "pthread_cond_wait");
+
+   function pthread_cond_timedwait
+     (cond    : access pthread_cond_t;
+      mutex   : access pthread_mutex_t;
+      abstime : access timespec) return int;
+   pragma Import (C, pthread_cond_timedwait, "pthread_cond_timedwait");
+
+   Relative_Timed_Wait : constant Boolean := False;
+   --  pthread_cond_timedwait requires an absolute delay time
+
+   --------------------------
+   -- POSIX.1c  Section 13 --
+   --------------------------
+
+   PTHREAD_PRIO_NONE    : constant := 0;
+   PTHREAD_PRIO_PROTECT : constant := 2;
+   PTHREAD_PRIO_INHERIT : constant := 1;
+
+   function pthread_mutexattr_setprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : int) return int;
+
+   function pthread_mutexattr_setprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : int) return int;
+
+   type struct_sched_param is record
+      sched_priority : int;
+   end record;
+   pragma Convention (C, struct_sched_param);
+
+   function pthread_getschedparam
+     (thread : pthread_t;
+      policy : access int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_getschedparam, "pthread_getschedparam");
+
+   function pthread_setschedparam
+     (thread : pthread_t;
+      policy : int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
+
+   function pthread_attr_setscope
+     (attr            : access pthread_attr_t;
+      contentionscope : int) return int;
+   pragma Import (C, pthread_attr_setscope, "pthread_attr_setscope");
+
+   function pthread_attr_getscope
+     (attr            : access pthread_attr_t;
+      contentionscope : access int) return int;
+   pragma Import (C, pthread_attr_getscope, "pthread_attr_getscope");
+
+   function pthread_attr_setinheritsched
+     (attr            : access pthread_attr_t;
+      inheritsched : int) return int;
+   pragma Import
+     (C, pthread_attr_setinheritsched, "pthread_attr_setinheritsched");
+
+   function pthread_attr_getinheritsched
+     (attr         : access pthread_attr_t;
+      inheritsched : access int) return int;
+   pragma Import
+     (C, pthread_attr_getinheritsched, "pthread_attr_getinheritsched");
+
+   function pthread_attr_setschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : int) return int;
+   pragma Import (C, pthread_attr_setschedpolicy,
+     "pthread_attr_setschedpolicy");
+
+   function pthread_attr_getschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : access int) return int;
+   pragma Import (C, pthread_attr_getschedpolicy,
+     "pthread_attr_getschedpolicy");
+
+   function pthread_attr_setschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : int) return int;
+   pragma Import (C, pthread_attr_setschedparam, "pthread_attr_setschedparam");
+
+   function pthread_attr_getschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : access int) return int;
+   pragma Import (C, pthread_attr_getschedparam, "pthread_attr_getschedparam");
+
+   function sched_yield return int;
+   pragma Import (C, sched_yield, "sched_yield");
+
+   --------------------------
+   -- P1003.1c  Section 16 --
+   --------------------------
+
+   function pthread_attr_init (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_init, "pthread_attr_init");
+
+   function pthread_attr_destroy
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_destroy, "pthread_attr_destroy");
+
+   function pthread_attr_setdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : int) return int;
+   pragma Import
+     (C, pthread_attr_setdetachstate, "pthread_attr_setdetachstate");
+
+   function pthread_attr_getdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : access int) return int;
+   pragma Import
+     (C, pthread_attr_getdetachstate, "pthread_attr_getdetachstate");
+
+   function pthread_attr_getstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : access size_t) return int;
+   pragma Import
+     (C, pthread_attr_getstacksize, "pthread_attr_getstacksize");
+
+   function pthread_attr_setstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : size_t) return int;
+   pragma Import
+     (C, pthread_attr_setstacksize, "pthread_attr_setstacksize");
+
+   function pthread_create
+     (thread        : access pthread_t;
+      attributes    : access pthread_attr_t;
+      start_routine : Thread_Body;
+      arg           : System.Address) return int;
+   pragma Import (C, pthread_create, "pthread_create");
+
+   function pthread_detach (thread : pthread_t) return int;
+   pragma Import (C, pthread_detach, "pthread_detach");
+
+   procedure pthread_exit (status : System.Address);
+   pragma Import (C, pthread_exit, "pthread_exit");
+
+   function pthread_self return pthread_t;
+   pragma Import (C, pthread_self, "pthread_self");
+
+   --------------------------
+   -- POSIX.1c  Section 17 --
+   --------------------------
+
+   function pthread_setspecific
+     (key   : pthread_key_t;
+      value : System.Address) return  int;
+   pragma Import (C, pthread_setspecific, "pthread_setspecific");
+
+   function pthread_getspecific (key : pthread_key_t) return System.Address;
+   pragma Import (C, pthread_getspecific, "pthread_getspecific");
+
+   type destructor_pointer is access procedure (arg : System.Address);
+   pragma Convention (C, destructor_pointer);
+
+   function pthread_key_create
+     (key        : access pthread_key_t;
+      destructor : destructor_pointer) return int;
+   pragma Import (C, pthread_key_create, "pthread_key_create");
+
+   ------------------------------------
+   -- Non-portable Pthread Functions --
+   ------------------------------------
+
+   function pthread_set_name_np
+     (thread : pthread_t;
+      name   : System.Address) return int;
+   pragma Import (C, pthread_set_name_np, "pthread_set_name_np");
+
+private
+
+   type sigset_t is array (1 .. 4) of unsigned;
+
+   --  In NetBSD the component sa_handler turns out to
+   --  be one a union type, and the selector is a macro:
+   --  #define sa_handler __sigaction_u._handler
+   --  #define sa_sigaction __sigaction_u._sigaction
+
+   --  Should we add a signal_context type here ???
+   --  How could it be done independent of the CPU architecture ???
+   --  sigcontext type is opaque, so it is architecturally neutral.
+   --  It is always passed as an access type, so define it as an empty record
+   --  since the contents are not used anywhere.
+
+   type struct_sigcontext is null record;
+   pragma Convention (C, struct_sigcontext);
+
+   type pid_t is new int;
+
+   type time_t is new int;
+
+   type timespec is record
+      tv_sec  : time_t;
+      tv_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type pthread_t           is new System.Address;
+   type pthread_attr_t      is record
+      Pta_Magic   : unsigned;
+      Pta_Flags   : int;
+      Pta_Private : System.Address;
+   end record;
+   pragma Convention (C, pthread_attr_t);
+
+   --  PORT NOTE:  The size of pthread_spin_t is defined in
+   --  /src/sys/arch/*/include/types.h
+   type pthread_spin_t is new unsigned_char;
+
+   type pthread_queue_t is record
+      Pthqh_First : pthread_t;
+      Pthqh_Last  : System.Address;
+   end record;
+   pragma Convention (C, pthread_queue_t);
+
+   type pthread_mutex_t     is record
+      Ptm_Majic     : unsigned;
+      Ptm_Lock      : pthread_spin_t;
+      Ptm_Interlock : pthread_spin_t;
+      Ptm_Owner     : pthread_t;
+      Ptm_Block     : pthread_queue_t;
+      Ptm_Private   : System.Address;
+   end record;
+   pragma Convention (C, pthread_mutex_t);
+
+   type pthread_mutexattr_t is record
+      Ptma_Majic   : unsigned;
+      Ptma_Private : System.Address;
+   end record;
+   pragma Convention (C, pthread_mutexattr_t);
+
+   type pthread_cond_t      is record
+      Ptc_Magic   : unsigned;
+      Ptc_Lock    : pthread_spin_t;
+      Ptc_Waiters : pthread_queue_t;
+      Ptc_Mutex   : pthread_mutex_t;
+      Ptc_Private : System.Address;
+   end record;
+   pragma Convention (C, pthread_cond_t);
+
+   type pthread_condattr_t  is record
+      Ptca_Magic   : unsigned;
+      Ptca_Private : System.Address;
+   end record;
+   pragma Convention (C, pthread_condattr_t);
+
+   type pthread_key_t       is new int;
+
+end System.OS_Interface;
--- /dev/null
+++ gcc/ada/s-osinte-netbsd6.ads
@@ -0,0 +1,675 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                   S p e c                                --
+--                                                                          --
+--             Copyright (C) 1991-1994, Florida State University            --
+--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University. It is --
+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
+-- State University (http://www.gnat.com).                                  --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the NetBSD 6+ PTHREADS version of this package.
+--  It is based off of the FreeBSD PTHREADS as of 4.2.3.
+
+--  This package encapsulates all direct interfaces to OS services
+--  that are needed by the tasking run-time (libgnarl).
+
+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma
+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.
+
+with Ada.Unchecked_Conversion;
+
+with Interfaces.C;
+
+package System.OS_Interface is
+   pragma Preelaborate;
+
+   pragma Linker_Options ("-pthread");
+
+   subtype int            is Interfaces.C.int;
+   subtype short          is Interfaces.C.short;
+   subtype long           is Interfaces.C.long;
+   subtype unsigned       is Interfaces.C.unsigned;
+   subtype unsigned_short is Interfaces.C.unsigned_short;
+   subtype unsigned_long  is Interfaces.C.unsigned_long;
+   subtype unsigned_char  is Interfaces.C.unsigned_char;
+   subtype plain_char     is Interfaces.C.plain_char;
+   subtype size_t         is Interfaces.C.size_t;
+   subtype int64_t        is Interfaces.Integer_64;
+
+   -----------
+   -- Errno --
+   -----------
+
+   function Errno return int;
+   pragma Inline (Errno);
+
+   EAGAIN    : constant := 35;
+   EINTR     : constant := 4;
+   EINVAL    : constant := 22;
+   ENOMEM    : constant := 12;
+   ETIMEDOUT : constant := 60;
+
+   -------------
+   -- Signals --
+   -------------
+
+   Max_Interrupt : constant := 63;
+   type Signal is new int range 0 .. Max_Interrupt;
+   for Signal'Size use int'Size;
+
+   SIGHUP     : constant := 1; --  hangup
+   SIGINT     : constant := 2; --  interrupt (rubout)
+   SIGQUIT    : constant := 3; --  quit (ASCD FS)
+   SIGILL     : constant := 4; --  illegal instruction (not reset)
+   SIGTRAP    : constant := 5; --  trace trap (not reset)
+   SIGIOT     : constant := 6; --  IOT instruction
+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future
+   SIGEMT     : constant := 7; --  EMT instruction
+   SIGFPE     : constant := 8; --  floating point exception
+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)
+   SIGBUS     : constant := 10; --  bus error
+   SIGSEGV    : constant := 11; --  segmentation violation
+   SIGSYS     : constant := 12; --  bad argument to system call
+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it
+   SIGALRM    : constant := 14; --  alarm clock
+   SIGTERM    : constant := 15; --  software termination signal from kill
+   SIGURG     : constant := 16; --  urgent condition on IO channel
+   SIGSTOP    : constant := 17; --  stop (cannot be caught or ignored)
+   SIGTSTP    : constant := 18; --  user stop requested from tty
+   SIGCONT    : constant := 19; --  stopped process has been continued
+   SIGCLD     : constant := 20; --  alias for SIGCHLD
+   SIGCHLD    : constant := 20; --  child status change
+   SIGTTIN    : constant := 21; --  background tty read attempted
+   SIGTTOU    : constant := 22; --  background tty write attempted
+   SIGIO      : constant := 23; --  I/O possible (Solaris SIGPOLL alias)
+   SIGXCPU    : constant := 24; --  CPU time limit exceeded
+   SIGXFSZ    : constant := 25; --  filesize limit exceeded
+   SIGVTALRM  : constant := 26; --  virtual timer expired
+   SIGPROF    : constant := 27; --  profiling timer expired
+   SIGWINCH   : constant := 28; --  window size change
+   SIGINFO    : constant := 29; --  information request (BSD)
+   SIGUSR1    : constant := 30; --  user defined signal 1
+   SIGUSR2    : constant := 31; --  user defined signal 2
+   SIGPWR     : constant := 32; --  power fail/restart (not reset when caught)
+
+   SIGADAABORT : constant := SIGABRT;
+   --  Change this if you want to use another signal for task abort.
+   --  SIGTERM might be a good one.
+
+   type Signal_Set is array (Natural range <>) of Signal;
+
+   --  Interrupts that must be unmasked at all times.  NetBSD
+   --  pthreads will not allow an application to mask out any
+   --  interrupt needed by the threads library.
+   Unmasked : constant Signal_Set :=
+     (SIGTRAP, SIGBUS, SIGTTIN, SIGTTOU, SIGTSTP);
+
+   --  NetBSD will uses SIGPROF for timing.  Do not allow a
+   --  handler to attach to this signal.
+   Reserved : constant Signal_Set := (0 .. 0 => SIGPROF);
+
+   type sigset_t is private;
+
+   function sigaddset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigaddset, "__sigaddset14");
+
+   function sigdelset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigdelset, "__sigdelset14");
+
+   function sigfillset (set : access sigset_t) return int;
+   pragma Import (C, sigfillset, "__sigfillset14");
+
+   function sigismember
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigismember, "__sigismember14");
+
+   function sigemptyset (set : access sigset_t) return int;
+   pragma Import (C, sigemptyset, "__sigemptyset14");
+
+   --  sigcontext is architecture dependent, so define it private
+   type struct_sigcontext is private;
+
+   type old_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_mask    : sigset_t;
+      sa_flags   : int;
+   end record;
+   pragma Convention (C, old_struct_sigaction);
+
+   type new_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_flags   : int;
+      sa_mask    : sigset_t;
+   end record;
+   pragma Convention (C, new_struct_sigaction);
+
+   subtype struct_sigaction is new_struct_sigaction;
+   type struct_sigaction_ptr is access all struct_sigaction;
+
+   SIG_BLOCK   : constant := 1;
+   SIG_UNBLOCK : constant := 2;
+   SIG_SETMASK : constant := 3;
+
+   SIG_DFL  : constant := 0;
+   SIG_IGN  : constant := 1;
+   SIG_ERR  : constant := -1;
+   SIG_HOLD : constant := 3;
+
+   SA_SIGINFO : constant := 16#0040#;
+   SA_ONSTACK : constant := 16#0001#;
+
+   function sigaction
+     (sig  : Signal;
+      act  : struct_sigaction_ptr;
+      oact : struct_sigaction_ptr) return int;
+   pragma Import (C, sigaction, "__sigaction14");
+
+   ----------
+   -- Time --
+   ----------
+
+   Time_Slice_Supported : constant Boolean := True;
+   --  Indicates whether time slicing is supported (i.e SCHED_RR is supported)
+
+   type timespec is private;
+
+   function nanosleep (rqtp, rmtp : access timespec)  return int;
+   pragma Import (C, nanosleep, "__nanosleep50");
+
+   type clockid_t is new int;
+
+   function clock_gettime
+     (clock_id : clockid_t;
+      tp       : access timespec)
+      return int;
+   pragma Import (C, clock_gettime, "__clock_gettime50");
+
+   function To_Duration (TS : timespec) return Duration;
+   pragma Inline (To_Duration);
+
+   function To_Timespec (D : Duration) return timespec;
+   pragma Inline (To_Timespec);
+
+   type struct_timezone is record
+      tz_minuteswest : int;
+      tz_dsttime     : int;
+   end record;
+   pragma Convention (C, struct_timezone);
+
+   -------------------------
+   -- Priority Scheduling --
+   -------------------------
+
+   SCHED_FIFO  : constant := 1;
+   SCHED_OTHER : constant := 2;
+   SCHED_RR    : constant := 3;
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int;
+   --  Maps System.Any_Priority to a POSIX priority
+
+   -------------
+   -- Process --
+   -------------
+
+   type pid_t is private;
+
+   function kill (pid : pid_t; sig : Signal) return int;
+   pragma Import (C, kill, "kill");
+
+   function getpid return pid_t;
+   pragma Import (C, getpid, "getpid");
+
+   ---------
+   -- LWP --
+   ---------
+
+   function lwp_self return System.Address;
+   --  lwp_self does not exist on this thread library, revert to pthread_self
+   --  which is the closest approximation (with getpid). This function is
+   --  needed to share 7staprop.adb across POSIX-like targets.
+   pragma Import (C, lwp_self, "pthread_self");
+
+   -------------
+   -- Threads --
+   -------------
+
+   type Thread_Body is access
+     function (arg : System.Address) return System.Address;
+   pragma Convention (C, Thread_Body);
+
+   function Thread_Body_Access is new
+     Ada.Unchecked_Conversion (System.Address, Thread_Body);
+
+   type pthread_t           is private;
+   subtype Thread_Id        is pthread_t;
+
+   type pthread_mutex_t     is limited private;
+   type pthread_cond_t      is limited private;
+   type pthread_attr_t      is limited private;
+   type pthread_mutexattr_t is limited private;
+   type pthread_condattr_t  is limited private;
+   type pthread_key_t       is private;
+
+   PTHREAD_CREATE_DETACHED : constant := 1;
+   PTHREAD_CREATE_JOINABLE : constant := 0;
+
+   PTHREAD_SCOPE_PROCESS : constant := 0;
+   PTHREAD_SCOPE_SYSTEM  : constant := 2;
+
+   --  Read/Write lock not supported on freebsd. To add support both types
+   --  pthread_rwlock_t and pthread_rwlockattr_t must properly be defined
+   --  with the associated routines pthread_rwlock_[init/destroy] and
+   --  pthread_rwlock_[rdlock/wrlock/unlock].
+
+   subtype pthread_rwlock_t     is pthread_mutex_t;
+   subtype pthread_rwlockattr_t is pthread_mutexattr_t;
+
+   -----------
+   -- Stack --
+   -----------
+
+   type stack_t is record
+      ss_sp    : System.Address;
+      ss_size  : size_t;
+      ss_flags : int;
+   end record;
+   pragma Convention (C, stack_t);
+
+   function sigaltstack
+     (ss  : not null access stack_t;
+      oss : access stack_t) return int;
+   pragma Import (C, sigaltstack, "sigaltstack");
+
+   Alternate_Stack : aliased System.Address;
+   --  This is a dummy definition, never used (Alternate_Stack_Size is null)
+
+   Alternate_Stack_Size : constant := 0;
+   --  No alternate signal stack is used on this platform
+
+   Stack_Base_Available : constant Boolean := False;
+   --  Indicates whether the stack base is available on this target. This
+   --  allows us to share s-osinte.adb between all the FSU run time. Note that
+   --  this value can only be true if pthread_t has a complete definition that
+   --  corresponds exactly to the C header files.
+
+   function Get_Stack_Base (thread : pthread_t) return Address;
+   pragma Inline (Get_Stack_Base);
+   --  returns the stack base of the specified thread. Only call this function
+   --  when Stack_Base_Available is True.
+
+   function Get_Page_Size return size_t;
+   function Get_Page_Size return Address;
+   pragma Import (C, Get_Page_Size, "getpagesize");
+   --  Returns the size of a page
+
+   PROT_NONE  : constant := 0;
+   PROT_READ  : constant := 1;
+   PROT_WRITE : constant := 2;
+   PROT_EXEC  : constant := 4;
+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;
+   PROT_ON    : constant := PROT_NONE;
+   PROT_OFF   : constant := PROT_ALL;
+
+   function mprotect (addr : Address; len : size_t; prot : int) return int;
+   pragma Import (C, mprotect);
+
+   ---------------------------------------
+   -- Nonstandard Thread Initialization --
+   ---------------------------------------
+
+   --  FSU_THREADS requires pthread_init, which is nonstandard and this should
+   --  be invoked during the elaboration of s-taprop.adb.
+
+   --  NetBSD does not require this so we provide an empty Ada body
+
+   procedure pthread_init;
+
+   -------------------------
+   -- POSIX.1c  Section 3 --
+   -------------------------
+
+   function sigwait
+     (set : access sigset_t;
+      sig : access Signal) return int;
+   pragma Import (C, sigwait, "sigwait");
+
+   function pthread_kill
+     (thread : pthread_t;
+      sig    : Signal) return int;
+   pragma Import (C, pthread_kill, "pthread_kill");
+
+   function pthread_sigmask
+     (how  : int;
+      set  : access sigset_t;
+      oset : access sigset_t) return int;
+   pragma Import (C, pthread_sigmask, "pthread_sigmask");
+
+   --------------------------
+   -- POSIX.1c  Section 11 --
+   --------------------------
+
+   function pthread_mutexattr_init
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_init, "pthread_mutexattr_init");
+
+   function pthread_mutexattr_destroy
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_destroy, "pthread_mutexattr_destroy");
+
+   function pthread_mutex_init
+     (mutex : access pthread_mutex_t;
+      attr  : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutex_init, "pthread_mutex_init");
+
+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_destroy, "pthread_mutex_destroy");
+
+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_lock, "pthread_mutex_lock");
+
+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_unlock, "pthread_mutex_unlock");
+
+   function pthread_condattr_init
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_init, "pthread_condattr_init");
+
+   function pthread_condattr_destroy
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_destroy, "pthread_condattr_destroy");
+
+   function pthread_cond_init
+     (cond : access pthread_cond_t;
+      attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_cond_init, "pthread_cond_init");
+
+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_destroy, "pthread_cond_destroy");
+
+   function pthread_cond_signal (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_signal, "pthread_cond_signal");
+
+   function pthread_cond_wait
+     (cond  : access pthread_cond_t;
+      mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_cond_wait, "pthread_cond_wait");
+
+   function pthread_cond_timedwait
+     (cond    : access pthread_cond_t;
+      mutex   : access pthread_mutex_t;
+      abstime : access timespec) return int;
+   pragma Import (C, pthread_cond_timedwait, "pthread_cond_timedwait");
+
+   Relative_Timed_Wait : constant Boolean := False;
+   --  pthread_cond_timedwait requires an absolute delay time
+
+   --------------------------
+   -- POSIX.1c  Section 13 --
+   --------------------------
+
+   PTHREAD_PRIO_NONE    : constant := 0;
+   PTHREAD_PRIO_PROTECT : constant := 2;
+   PTHREAD_PRIO_INHERIT : constant := 1;
+
+   function pthread_mutexattr_setprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : int) return int;
+
+   function pthread_mutexattr_setprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : int) return int;
+
+   type struct_sched_param is record
+      sched_priority : int;
+   end record;
+   pragma Convention (C, struct_sched_param);
+
+   function pthread_getschedparam
+     (thread : pthread_t;
+      policy : access int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_getschedparam, "pthread_getschedparam");
+
+   function pthread_setschedparam
+     (thread : pthread_t;
+      policy : int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
+
+   function pthread_attr_setscope
+     (attr            : access pthread_attr_t;
+      contentionscope : int) return int;
+   pragma Import (C, pthread_attr_setscope, "pthread_attr_setscope");
+
+   function pthread_attr_getscope
+     (attr            : access pthread_attr_t;
+      contentionscope : access int) return int;
+   pragma Import (C, pthread_attr_getscope, "pthread_attr_getscope");
+
+   function pthread_attr_setinheritsched
+     (attr            : access pthread_attr_t;
+      inheritsched : int) return int;
+   pragma Import
+     (C, pthread_attr_setinheritsched, "pthread_attr_setinheritsched");
+
+   function pthread_attr_getinheritsched
+     (attr         : access pthread_attr_t;
+      inheritsched : access int) return int;
+   pragma Import
+     (C, pthread_attr_getinheritsched, "pthread_attr_getinheritsched");
+
+   function pthread_attr_setschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : int) return int;
+   pragma Import (C, pthread_attr_setschedpolicy,
+     "pthread_attr_setschedpolicy");
+
+   function pthread_attr_getschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : access int) return int;
+   pragma Import (C, pthread_attr_getschedpolicy,
+     "pthread_attr_getschedpolicy");
+
+   function pthread_attr_setschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : int) return int;
+   pragma Import (C, pthread_attr_setschedparam, "pthread_attr_setschedparam");
+
+   function pthread_attr_getschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : access int) return int;
+   pragma Import (C, pthread_attr_getschedparam, "pthread_attr_getschedparam");
+
+   function sched_yield return int;
+   pragma Import (C, sched_yield, "sched_yield");
+
+   --------------------------
+   -- P1003.1c  Section 16 --
+   --------------------------
+
+   function pthread_attr_init (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_init, "pthread_attr_init");
+
+   function pthread_attr_destroy
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_destroy, "pthread_attr_destroy");
+
+   function pthread_attr_setdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : int) return int;
+   pragma Import
+     (C, pthread_attr_setdetachstate, "pthread_attr_setdetachstate");
+
+   function pthread_attr_getdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : access int) return int;
+   pragma Import
+     (C, pthread_attr_getdetachstate, "pthread_attr_getdetachstate");
+
+   function pthread_attr_getstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : access size_t) return int;
+   pragma Import
+     (C, pthread_attr_getstacksize, "pthread_attr_getstacksize");
+
+   function pthread_attr_setstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : size_t) return int;
+   pragma Import
+     (C, pthread_attr_setstacksize, "pthread_attr_setstacksize");
+
+   function pthread_create
+     (thread        : access pthread_t;
+      attributes    : access pthread_attr_t;
+      start_routine : Thread_Body;
+      arg           : System.Address) return int;
+   pragma Import (C, pthread_create, "pthread_create");
+
+   function pthread_detach (thread : pthread_t) return int;
+   pragma Import (C, pthread_detach, "pthread_detach");
+
+   procedure pthread_exit (status : System.Address);
+   pragma Import (C, pthread_exit, "pthread_exit");
+
+   function pthread_self return pthread_t;
+   pragma Import (C, pthread_self, "pthread_self");
+
+   --------------------------
+   -- POSIX.1c  Section 17 --
+   --------------------------
+
+   function pthread_setspecific
+     (key   : pthread_key_t;
+      value : System.Address) return  int;
+   pragma Import (C, pthread_setspecific, "pthread_setspecific");
+
+   function pthread_getspecific (key : pthread_key_t) return System.Address;
+   pragma Import (C, pthread_getspecific, "pthread_getspecific");
+
+   type destructor_pointer is access procedure (arg : System.Address);
+   pragma Convention (C, destructor_pointer);
+
+   function pthread_key_create
+     (key        : access pthread_key_t;
+      destructor : destructor_pointer) return int;
+   pragma Import (C, pthread_key_create, "pthread_key_create");
+
+   ------------------------------------
+   -- Non-portable Pthread Functions --
+   ------------------------------------
+
+   function pthread_set_name_np
+     (thread : pthread_t;
+      name   : System.Address) return int;
+   pragma Import (C, pthread_set_name_np, "pthread_set_name_np");
+
+private
+
+   type sigset_t is array (1 .. 4) of unsigned;
+
+   --  In NetBSD the component sa_handler turns out to
+   --  be one a union type, and the selector is a macro:
+   --  #define sa_handler __sigaction_u._handler
+   --  #define sa_sigaction __sigaction_u._sigaction
+
+   --  Should we add a signal_context type here ???
+   --  How could it be done independent of the CPU architecture ???
+   --  sigcontext type is opaque, so it is architecturally neutral.
+   --  It is always passed as an access type, so define it as an empty record
+   --  since the contents are not used anywhere.
+
+   type struct_sigcontext is null record;
+   pragma Convention (C, struct_sigcontext);
+
+   type pid_t is new int;
+
+   type time_t is new int64_t;
+
+   type timespec is record
+      tv_sec  : time_t;
+      tv_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type pthread_t           is new System.Address;
+   type pthread_attr_t      is record
+      Pta_Magic   : unsigned;
+      Pta_Flags   : int;
+      Pta_Private : System.Address;
+   end record;
+   pragma Convention (C, pthread_attr_t);
+
+   --  PORT NOTE:  The size of pthread_spin_t is defined in
+   --  /src/sys/arch/*/include/types.h
+   type pthread_spin_t is new unsigned_char;
+
+   type pthread_queue_t is record
+      Pthqh_First : pthread_t;
+      Pthqh_Last  : System.Address;
+   end record;
+   pragma Convention (C, pthread_queue_t);
+
+   type pthread_mutex_t     is record
+      Ptm_Majic     : unsigned;
+      Ptm_Lock      : pthread_spin_t;
+      Ptm_Interlock : pthread_spin_t;
+      Ptm_Owner     : pthread_t;
+      Ptm_Block     : pthread_queue_t;
+      Ptm_Private   : System.Address;
+   end record;
+   pragma Convention (C, pthread_mutex_t);
+
+   type pthread_mutexattr_t is record
+      Ptma_Majic   : unsigned;
+      Ptma_Private : System.Address;
+   end record;
+   pragma Convention (C, pthread_mutexattr_t);
+
+   type pthread_cond_t      is record
+      Ptc_Magic   : unsigned;
+      Ptc_Lock    : pthread_spin_t;
+      Ptc_Waiters : pthread_queue_t;
+      Ptc_Mutex   : pthread_mutex_t;
+      Ptc_Private : System.Address;
+   end record;
+   pragma Convention (C, pthread_cond_t);
+
+   type pthread_condattr_t  is record
+      Ptca_Magic   : unsigned;
+      Ptca_Private : System.Address;
+   end record;
+   pragma Convention (C, pthread_condattr_t);
+
+   type pthread_key_t       is new int;
+
+end System.OS_Interface;
--- /dev/null
+++ gcc/ada/s-osinte-openbsd.adb
@@ -0,0 +1,116 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                   B o d y                                --
+--                                                                          --
+--          Copyright (C) 1991-2009, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University. It is --
+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
+-- State University (http://www.gnat.com).                                  --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the OpenBSD THREADS version of this package
+
+with Interfaces.C; use Interfaces.C;
+
+package body System.OS_Interface is
+
+   -----------
+   -- Errno --
+   -----------
+
+   function Errno return int is
+      type int_ptr is access all int;
+
+      function internal_errno return int_ptr;
+      pragma Import (C, internal_errno, "__errno");
+
+   begin
+      return (internal_errno.all);
+   end Errno;
+
+   --------------------
+   -- Get_Stack_Base --
+   --------------------
+
+   function Get_Stack_Base (thread : pthread_t) return Address is
+      pragma Unreferenced (thread);
+   begin
+      return Null_Address;
+   end Get_Stack_Base;
+
+   ------------------
+   -- pthread_init --
+   ------------------
+
+   procedure pthread_init is
+   begin
+      null;
+   end pthread_init;
+
+   -----------------
+   -- To_Duration --
+   -----------------
+
+   function To_Duration (TS : timespec) return Duration is
+   begin
+      return Duration (TS.tv_sec) + Duration (TS.tv_nsec) / 10#1#E9;
+   end To_Duration;
+
+   ------------------------
+   -- To_Target_Priority --
+   ------------------------
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int
+   is
+   begin
+      return Interfaces.C.int (Prio);
+   end To_Target_Priority;
+
+   -----------------
+   -- To_Timespec --
+   -----------------
+
+   function To_Timespec (D : Duration) return timespec is
+      S : time_t;
+      F : Duration;
+
+   begin
+      S := time_t (Long_Long_Integer (D));
+      F := D - Duration (S);
+
+      --  If F has negative value due to a round-up, adjust for positive F
+      --  value.
+
+      if F < 0.0 then
+         S := S - 1;
+         F := F + 1.0;
+      end if;
+
+      return timespec'(tv_sec => S,
+                       tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));
+   end To_Timespec;
+
+end System.OS_Interface;
--- /dev/null
+++ gcc/ada/s-osinte-openbsd.ads
@@ -0,0 +1,648 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                   S p e c                                --
+--                                                                          --
+--             Copyright (C) 1991-1994, Florida State University            --
+--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University. It is --
+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
+-- State University (http://www.gnat.com).                                  --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the OpenBSD PTHREADS version of this package
+
+--  This package encapsulates all direct interfaces to OS services
+--  that are needed by the tasking run-time (libgnarl).
+
+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma
+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.
+
+with Ada.Unchecked_Conversion;
+
+with Interfaces.C;
+
+package System.OS_Interface is
+   pragma Preelaborate;
+
+   pragma Linker_Options ("-pthread");
+
+   subtype int            is Interfaces.C.int;
+   subtype short          is Interfaces.C.short;
+   subtype long           is Interfaces.C.long;
+   subtype unsigned       is Interfaces.C.unsigned;
+   subtype unsigned_short is Interfaces.C.unsigned_short;
+   subtype unsigned_long  is Interfaces.C.unsigned_long;
+   subtype unsigned_char  is Interfaces.C.unsigned_char;
+   subtype plain_char     is Interfaces.C.plain_char;
+   subtype size_t         is Interfaces.C.size_t;
+
+   -----------
+   -- Errno --
+   -----------
+
+   function Errno return int;
+   pragma Inline (Errno);
+
+   EAGAIN    : constant := 35;
+   EINTR     : constant := 4;
+   EINVAL    : constant := 22;
+   ENOMEM    : constant := 12;
+   ETIMEDOUT : constant := 60;
+
+   -------------
+   -- Signals --
+   -------------
+
+   Max_Interrupt : constant := 31;
+   type Signal is new int range 0 .. Max_Interrupt;
+   for Signal'Size use int'Size;
+
+   SIGHUP     : constant := 1; --  hangup
+   SIGINT     : constant := 2; --  interrupt (rubout)
+   SIGQUIT    : constant := 3; --  quit (ASCD FS)
+   SIGILL     : constant := 4; --  illegal instruction (not reset)
+   SIGTRAP    : constant := 5; --  trace trap (not reset)
+   SIGIOT     : constant := 6; --  IOT instruction
+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future
+   SIGEMT     : constant := 7; --  EMT instruction
+   SIGFPE     : constant := 8; --  floating point exception
+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)
+   SIGBUS     : constant := 10; --  bus error
+   SIGSEGV    : constant := 11; --  segmentation violation
+   SIGSYS     : constant := 12; --  bad argument to system call
+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it
+   SIGALRM    : constant := 14; --  alarm clock
+   SIGTERM    : constant := 15; --  software termination signal from kill
+   SIGURG     : constant := 16; --  urgent condition on IO channel
+   SIGSTOP    : constant := 17; --  stop (cannot be caught or ignored)
+   SIGTSTP    : constant := 18; --  user stop requested from tty
+   SIGCONT    : constant := 19; --  stopped process has been continued
+   SIGCLD     : constant := 20; --  alias for SIGCHLD
+   SIGCHLD    : constant := 20; --  child status change
+   SIGTTIN    : constant := 21; --  background tty read attempted
+   SIGTTOU    : constant := 22; --  background tty write attempted
+   SIGIO      : constant := 23; --  I/O possible (Solaris SIGPOLL alias)
+   SIGXCPU    : constant := 24; --  CPU time limit exceeded
+   SIGXFSZ    : constant := 25; --  filesize limit exceeded
+   SIGVTALRM  : constant := 26; --  virtual timer expired
+   SIGPROF    : constant := 27; --  profiling timer expired
+   SIGWINCH   : constant := 28; --  window size change
+   SIGINFO    : constant := 29; --  information request (BSD)
+   SIGUSR1    : constant := 30; --  user defined signal 1
+   SIGUSR2    : constant := 31; --  user defined signal 2
+
+   SIGADAABORT : constant := SIGABRT;
+   --  Change this if you want to use another signal for task abort.
+   --  SIGTERM might be a good one.
+
+   type Signal_Set is array (Natural range <>) of Signal;
+
+   --  Interrupts that must be unmasked at all times.  OpenBSD
+   --  pthreads will not allow an application to mask out any
+   --  interrupt needed by the threads library.
+   Unmasked : constant Signal_Set :=
+     (SIGTRAP, SIGBUS, SIGTTIN, SIGTTOU, SIGTSTP);
+
+   --  OpenBSD will uses SIGPROF for timing.  Do not allow a
+   --  handler to attach to this signal.
+   Reserved : constant Signal_Set := (0 .. 0 => SIGPROF);
+
+   type sigset_t is private;
+
+   function sigaddset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigaddset, "sigaddset");
+
+   function sigdelset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigdelset, "sigdelset");
+
+   function sigfillset (set : access sigset_t) return int;
+   pragma Import (C, sigfillset, "sigfillset");
+
+   function sigismember
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigismember, "sigismember");
+
+   function sigemptyset (set : access sigset_t) return int;
+   pragma Import (C, sigemptyset, "sigemptyset");
+
+   --  sigcontext is architecture dependent, so define it private
+   type struct_sigcontext is private;
+
+   type old_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_mask    : sigset_t;
+      sa_flags   : int;
+   end record;
+   pragma Convention (C, old_struct_sigaction);
+
+   type new_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_flags   : int;
+      sa_mask    : sigset_t;
+   end record;
+   pragma Convention (C, new_struct_sigaction);
+
+   subtype struct_sigaction is new_struct_sigaction;
+   type struct_sigaction_ptr is access all struct_sigaction;
+
+   SIG_BLOCK   : constant := 1;
+   SIG_UNBLOCK : constant := 2;
+   SIG_SETMASK : constant := 3;
+
+   SIG_DFL : constant := 0;
+   SIG_IGN : constant := 1;
+
+   SA_SIGINFO : constant := 16#0040#;
+   SA_ONSTACK : constant := 16#0001#;
+
+   function sigaction
+     (sig  : Signal;
+      act  : struct_sigaction_ptr;
+      oact : struct_sigaction_ptr) return int;
+   pragma Import (C, sigaction, "sigaction");
+
+   ----------
+   -- Time --
+   ----------
+
+   Time_Slice_Supported : constant Boolean := True;
+   --  Indicates whether time slicing is supported (i.e SCHED_RR is supported)
+
+   type timespec is private;
+
+   function nanosleep (rqtp, rmtp : access timespec)  return int;
+   pragma Import (C, nanosleep, "nanosleep");
+
+   type clockid_t is new int;
+
+   function clock_gettime
+     (clock_id : clockid_t;
+      tp       : access timespec)
+      return int;
+   pragma Import (C, clock_gettime, "clock_gettime");
+
+   function To_Duration (TS : timespec) return Duration;
+   pragma Inline (To_Duration);
+
+   function To_Timespec (D : Duration) return timespec;
+   pragma Inline (To_Timespec);
+
+   type struct_timezone is record
+      tz_minuteswest : int;
+      tz_dsttime     : int;
+   end record;
+   pragma Convention (C, struct_timezone);
+
+   procedure usleep (useconds : unsigned_long);
+   pragma Import (C, usleep, "usleep");
+
+   -------------------------
+   -- Priority Scheduling --
+   -------------------------
+
+   SCHED_FIFO  : constant := 1;
+   SCHED_OTHER : constant := 2;
+   SCHED_RR    : constant := 3;
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int;
+   --  Maps System.Any_Priority to a POSIX priority
+
+   -------------
+   -- Process --
+   -------------
+
+   type pid_t is private;
+
+   function kill (pid : pid_t; sig : Signal) return int;
+   pragma Import (C, kill, "kill");
+
+   function getpid return pid_t;
+   pragma Import (C, getpid, "getpid");
+
+   ---------
+   -- LWP --
+   ---------
+
+   function lwp_self return System.Address;
+   --  lwp_self does not exist on this thread library, revert to pthread_self
+   --  which is the closest approximation (with getpid). This function is
+   --  needed to share 7staprop.adb across POSIX-like targets.
+   pragma Import (C, lwp_self, "pthread_self");
+
+   -------------
+   -- Threads --
+   -------------
+
+   type Thread_Body is access
+     function (arg : System.Address) return System.Address;
+   pragma Convention (C, Thread_Body);
+
+   function Thread_Body_Access is new
+     Ada.Unchecked_Conversion (System.Address, Thread_Body);
+
+   type pthread_t           is private;
+   subtype Thread_Id        is pthread_t;
+
+   type pthread_mutex_t     is limited private;
+   type pthread_cond_t      is limited private;
+   type pthread_attr_t      is limited private;
+   type pthread_mutexattr_t is limited private;
+   type pthread_condattr_t  is limited private;
+   type pthread_key_t       is private;
+
+   PTHREAD_CREATE_DETACHED : constant := 1;
+   PTHREAD_CREATE_JOINABLE : constant := 0;
+
+   PTHREAD_SCOPE_PROCESS : constant := 0;
+   PTHREAD_SCOPE_SYSTEM  : constant := 2;
+
+   --  Read/Write lock not supported on freebsd. To add support both types
+   --  pthread_rwlock_t and pthread_rwlockattr_t must properly be defined
+   --  with the associated routines pthread_rwlock_[init/destroy] and
+   --  pthread_rwlock_[rdlock/wrlock/unlock].
+
+   subtype pthread_rwlock_t     is pthread_mutex_t;
+   subtype pthread_rwlockattr_t is pthread_mutexattr_t;
+
+   -----------
+   -- Stack --
+   -----------
+
+   type stack_t is record
+      ss_sp    : System.Address;
+      ss_size  : size_t;
+      ss_flags : int;
+   end record;
+   pragma Convention (C, stack_t);
+
+   function sigaltstack
+     (ss  : not null access stack_t;
+      oss : access stack_t) return int;
+   pragma Import (C, sigaltstack, "sigaltstack");
+
+   Alternate_Stack : aliased System.Address;
+   --  This is a dummy definition, never used (Alternate_Stack_Size is null)
+
+   Alternate_Stack_Size : constant := 0;
+   --  No alternate signal stack is used on this platform
+
+   Stack_Base_Available : constant Boolean := False;
+   --  Indicates whether the stack base is available on this target. This
+   --  allows us to share s-osinte.adb between all the FSU run time. Note that
+   --  this value can only be true if pthread_t has a complete definition that
+   --  corresponds exactly to the C header files.
+
+   function Get_Stack_Base (thread : pthread_t) return Address;
+   pragma Inline (Get_Stack_Base);
+   --  returns the stack base of the specified thread. Only call this function
+   --  when Stack_Base_Available is True.
+
+   function Get_Page_Size return size_t;
+   function Get_Page_Size return Address;
+   pragma Import (C, Get_Page_Size, "getpagesize");
+   --  Returns the size of a page
+
+   PROT_NONE  : constant := 0;
+   PROT_READ  : constant := 1;
+   PROT_WRITE : constant := 2;
+   PROT_EXEC  : constant := 4;
+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;
+   PROT_ON    : constant := PROT_NONE;
+   PROT_OFF   : constant := PROT_ALL;
+
+   function mprotect (addr : Address; len : size_t; prot : int) return int;
+   pragma Import (C, mprotect);
+
+   ---------------------------------------
+   -- Nonstandard Thread Initialization --
+   ---------------------------------------
+
+   --  FSU_THREADS requires pthread_init, which is nonstandard and this should
+   --  be invoked during the elaboration of s-taprop.adb.
+
+   --  OpenBSD does not require this so we provide an empty Ada body
+
+   procedure pthread_init;
+
+   -------------------------
+   -- POSIX.1c  Section 3 --
+   -------------------------
+
+   function sigwait
+     (set : access sigset_t;
+      sig : access Signal) return int;
+   pragma Import (C, sigwait, "sigwait");
+
+   function pthread_kill
+     (thread : pthread_t;
+      sig    : Signal) return int;
+   pragma Import (C, pthread_kill, "pthread_kill");
+
+   function pthread_sigmask
+     (how  : int;
+      set  : access sigset_t;
+      oset : access sigset_t) return int;
+   pragma Import (C, pthread_sigmask, "pthread_sigmask");
+
+   --------------------------
+   -- POSIX.1c  Section 11 --
+   --------------------------
+
+   function pthread_mutexattr_init
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_init, "pthread_mutexattr_init");
+
+   function pthread_mutexattr_destroy
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_destroy, "pthread_mutexattr_destroy");
+
+   function pthread_mutex_init
+     (mutex : access pthread_mutex_t;
+      attr  : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutex_init, "pthread_mutex_init");
+
+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_destroy, "pthread_mutex_destroy");
+
+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_lock, "pthread_mutex_lock");
+
+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_unlock, "pthread_mutex_unlock");
+
+   function pthread_condattr_init
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_init, "pthread_condattr_init");
+
+   function pthread_condattr_destroy
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_destroy, "pthread_condattr_destroy");
+
+   function pthread_cond_init
+     (cond : access pthread_cond_t;
+      attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_cond_init, "pthread_cond_init");
+
+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_destroy, "pthread_cond_destroy");
+
+   function pthread_cond_signal (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_signal, "pthread_cond_signal");
+
+   function pthread_cond_wait
+     (cond  : access pthread_cond_t;
+      mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_cond_wait, "pthread_cond_wait");
+
+   function pthread_cond_timedwait
+     (cond    : access pthread_cond_t;
+      mutex   : access pthread_mutex_t;
+      abstime : access timespec) return int;
+   pragma Import (C, pthread_cond_timedwait, "pthread_cond_timedwait");
+
+   Relative_Timed_Wait : constant Boolean := False;
+   --  pthread_cond_timedwait requires an absolute delay time
+
+   --------------------------
+   -- POSIX.1c  Section 13 --
+   --------------------------
+
+   PTHREAD_PRIO_NONE    : constant := 0;
+   PTHREAD_PRIO_PROTECT : constant := 2;
+   PTHREAD_PRIO_INHERIT : constant := 1;
+
+   function pthread_mutexattr_setprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : int) return int;
+   pragma Import
+      (C, pthread_mutexattr_setprotocol, "pthread_mutexattr_setprotocol");
+
+   function pthread_mutexattr_getprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprotocol, "pthread_mutexattr_getprotocol");
+
+   function pthread_mutexattr_setprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : int) return int;
+   pragma Import
+     (C, pthread_mutexattr_setprioceiling,
+      "pthread_mutexattr_setprioceiling");
+
+   function pthread_mutexattr_getprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprioceiling,
+      "pthread_mutexattr_getprioceiling");
+
+   type struct_sched_param is record
+      sched_priority : int;
+   end record;
+   pragma Convention (C, struct_sched_param);
+
+   function pthread_getschedparam
+     (thread : pthread_t;
+      policy : access int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_getschedparam, "pthread_getschedparam");
+
+   function pthread_setschedparam
+     (thread : pthread_t;
+      policy : int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
+
+   function pthread_attr_setscope
+     (attr            : access pthread_attr_t;
+      contentionscope : int) return int;
+   pragma Import (C, pthread_attr_setscope, "pthread_attr_setscope");
+
+   function pthread_attr_getscope
+     (attr            : access pthread_attr_t;
+      contentionscope : access int) return int;
+   pragma Import (C, pthread_attr_getscope, "pthread_attr_getscope");
+
+   function pthread_attr_setinheritsched
+     (attr            : access pthread_attr_t;
+      inheritsched : int) return int;
+   pragma Import
+     (C, pthread_attr_setinheritsched, "pthread_attr_setinheritsched");
+
+   function pthread_attr_getinheritsched
+     (attr         : access pthread_attr_t;
+      inheritsched : access int) return int;
+   pragma Import
+     (C, pthread_attr_getinheritsched, "pthread_attr_getinheritsched");
+
+   function pthread_attr_setschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : int) return int;
+   pragma Import (C, pthread_attr_setschedpolicy,
+     "pthread_attr_setschedpolicy");
+
+   function pthread_attr_getschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : access int) return int;
+   pragma Import (C, pthread_attr_getschedpolicy,
+     "pthread_attr_getschedpolicy");
+
+   function pthread_attr_setschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : int) return int;
+   pragma Import (C, pthread_attr_setschedparam, "pthread_attr_setschedparam");
+
+   function pthread_attr_getschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : access int) return int;
+   pragma Import (C, pthread_attr_getschedparam, "pthread_attr_getschedparam");
+
+   function sched_yield return int;
+   pragma Import (C, sched_yield, "pthread_yield");
+
+   --------------------------
+   -- P1003.1c  Section 16 --
+   --------------------------
+
+   function pthread_attr_init (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_init, "pthread_attr_init");
+
+   function pthread_attr_destroy
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_destroy, "pthread_attr_destroy");
+
+   function pthread_attr_setdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : int) return int;
+   pragma Import
+     (C, pthread_attr_setdetachstate, "pthread_attr_setdetachstate");
+
+   function pthread_attr_getdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : access int) return int;
+   pragma Import
+     (C, pthread_attr_getdetachstate, "pthread_attr_getdetachstate");
+
+   function pthread_attr_getstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : access size_t) return int;
+   pragma Import
+     (C, pthread_attr_getstacksize, "pthread_attr_getstacksize");
+
+   function pthread_attr_setstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : size_t) return int;
+   pragma Import
+     (C, pthread_attr_setstacksize, "pthread_attr_setstacksize");
+
+   function pthread_create
+     (thread        : access pthread_t;
+      attributes    : access pthread_attr_t;
+      start_routine : Thread_Body;
+      arg           : System.Address) return int;
+   pragma Import (C, pthread_create, "pthread_create");
+
+   function pthread_detach (thread : pthread_t) return int;
+   pragma Import (C, pthread_detach, "pthread_detach");
+
+   procedure pthread_exit (status : System.Address);
+   pragma Import (C, pthread_exit, "pthread_exit");
+
+   function pthread_self return pthread_t;
+   pragma Import (C, pthread_self, "pthread_self");
+
+   --------------------------
+   -- POSIX.1c  Section 17 --
+   --------------------------
+
+   function pthread_setspecific
+     (key   : pthread_key_t;
+      value : System.Address) return  int;
+   pragma Import (C, pthread_setspecific, "pthread_setspecific");
+
+   function pthread_getspecific (key : pthread_key_t) return System.Address;
+   pragma Import (C, pthread_getspecific, "pthread_getspecific");
+
+   type destructor_pointer is access procedure (arg : System.Address);
+   pragma Convention (C, destructor_pointer);
+
+   function pthread_key_create
+     (key        : access pthread_key_t;
+      destructor : destructor_pointer) return int;
+   pragma Import (C, pthread_key_create, "pthread_key_create");
+
+   ------------------------------------
+   -- Non-portable Pthread Functions --
+   ------------------------------------
+
+   function pthread_set_name_np
+     (thread : pthread_t;
+      name   : System.Address) return int;
+   pragma Import (C, pthread_set_name_np, "pthread_set_name_np");
+
+private
+
+   type sigset_t is array (1 .. 4) of unsigned;
+
+   --  In OpenBSD the component sa_handler turns out to
+   --  be one a union type, and the selector is a macro:
+   --  #define sa_handler __sigaction_u._handler
+   --  #define sa_sigaction __sigaction_u._sigaction
+
+   --  Should we add a signal_context type here ???
+   --  How could it be done independent of the CPU architecture ???
+   --  sigcontext type is opaque, so it is architecturally neutral.
+   --  It is always passed as an access type, so define it as an empty record
+   --  since the contents are not used anywhere.
+
+   type struct_sigcontext is null record;
+   pragma Convention (C, struct_sigcontext);
+
+   type pid_t is new int;
+
+   type time_t is new int;
+
+   type timespec is record
+      tv_sec  : time_t;
+      tv_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type pthread_t           is new System.Address;
+   type pthread_attr_t      is new System.Address;
+   type pthread_mutex_t     is new System.Address;
+   type pthread_mutexattr_t is new System.Address;
+   type pthread_cond_t      is new System.Address;
+   type pthread_condattr_t  is new System.Address;
+   type pthread_key_t       is new int;
+
+end System.OS_Interface;
--- /dev/null
+++ gcc/ada/s-osprim-bsd32.adb
@@ -0,0 +1,186 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --
+--                                                                          --
+--                  S Y S T E M . O S _ P R I M I T I V E S                 --
+--                                                                          --
+--                                  B o d y                                 --
+--                                                                          --
+--          Copyright (C) 1998-2009, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+-- Copyright (C) 2010, 2011 John Marino <www.dragonlace.net>                --
+------------------------------------------------------------------------------
+
+--  This version is for BSD operating systems using 32-bit time types.
+
+with Interfaces.C;
+
+package body System.OS_Primitives is
+
+   --  ??? These definitions are duplicated from System.OS_Interface
+   --  because we don't want to depend on any package. Consider removing
+   --  these declarations in System.OS_Interface and move these ones in
+   --  the spec.
+
+   subtype int  is Interfaces.C.int;
+   subtype long is Interfaces.C.long;
+
+   type time_t is new int;
+
+   type timespec is record
+      tv_sec  : time_t;
+      tv_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type timezone is record
+      tz_minuteswest : int;
+      tz_dsttime     : int;
+   end record;
+   pragma Convention (C, timezone);
+
+   function nanosleep (rqtp, rmtp : access timespec)  return int;
+   pragma Import (C, nanosleep, "nanosleep");
+
+   -----------
+   -- Clock --
+   -----------
+
+   function Clock return Duration is
+      type timeval is array (1 .. 2) of Long_Integer;
+      tzresult : aliased timezone;
+
+      procedure timeval_to_duration
+        (T    : not null access timeval;
+         sec  : not null access Long_Integer;
+         usec : not null access Long_Integer);
+      pragma Import (C, timeval_to_duration, "__gnat_timeval_to_duration");
+
+      Micro  : constant := 10**6;
+      sec    : aliased Long_Integer;
+      usec   : aliased Long_Integer;
+      TV     : aliased timeval;
+      Result : int;
+
+      function gettimeofday
+        (Tv : access timeval;
+         Tz : access timezone) return int;
+      pragma Import (C, gettimeofday, "gettimeofday");
+
+      pragma Unreferenced (Result);
+   begin
+      --  The return codes for gettimeofday are as follows (from man pages):
+      --    EPERM  settimeofday is called by someone other than the superuser
+      --    EINVAL Timezone (or something else) is invalid
+      --    EFAULT One of tv or tz pointed outside accessible address space
+
+      --  None of these codes signal a potential clock skew, hence the return
+      --  value is never checked.
+
+      Result := gettimeofday (TV'Access, tzresult'Access);
+      timeval_to_duration (TV'Access, sec'Access, usec'Access);
+      return Duration (sec) + Duration (usec) / Micro;
+   end Clock;
+
+   ---------------------
+   -- Monotonic_Clock --
+   ---------------------
+
+   function Monotonic_Clock return Duration renames Clock;
+
+   -----------------
+   -- To_Timespec --
+   -----------------
+
+   function To_Timespec (D : Duration) return timespec;
+
+   function To_Timespec (D : Duration) return timespec is
+      S : time_t;
+      F : Duration;
+
+   begin
+      S := time_t (Long_Long_Integer (D));
+      F := D - Duration (S);
+
+      --  If F has negative value due to a round-up, adjust for positive F
+      --  value.
+
+      if F < 0.0 then
+         S := S - 1;
+         F := F + 1.0;
+      end if;
+
+      return
+        timespec'(tv_sec  => S,
+                  tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));
+   end To_Timespec;
+
+   -----------------
+   -- Timed_Delay --
+   -----------------
+
+   procedure Timed_Delay
+     (Time : Duration;
+      Mode : Integer)
+   is
+      Request    : aliased timespec;
+      Remaind    : aliased timespec;
+      Rel_Time   : Duration;
+      Abs_Time   : Duration;
+      Base_Time  : constant Duration := Clock;
+      Check_Time : Duration := Base_Time;
+
+      Result     : int;
+      pragma Unreferenced (Result);
+
+   begin
+      if Mode = Relative then
+         Rel_Time := Time;
+         Abs_Time := Time + Check_Time;
+      else
+         Rel_Time := Time - Check_Time;
+         Abs_Time := Time;
+      end if;
+
+      if Rel_Time > 0.0 then
+         loop
+            Request := To_Timespec (Rel_Time);
+            Result := nanosleep (Request'Access, Remaind'Access);
+            Check_Time := Clock;
+
+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;
+
+            Rel_Time := Abs_Time - Check_Time;
+         end loop;
+      end if;
+   end Timed_Delay;
+
+   ----------------
+   -- Initialize --
+   ----------------
+
+   procedure Initialize is
+   begin
+      null;
+   end Initialize;
+
+end System.OS_Primitives;
--- /dev/null
+++ gcc/ada/s-osprim-bsd64.adb
@@ -0,0 +1,192 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --
+--                                                                          --
+--                  S Y S T E M . O S _ P R I M I T I V E S                 --
+--                                                                          --
+--                                  B o d y                                 --
+--                                                                          --
+--          Copyright (C) 1998-2009, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+-- Copyright (C) 2010, 2011 John Marino <www.dragonlace.net>                --
+------------------------------------------------------------------------------
+
+--  This version is for BSD operating systems using 64-bit time types.
+
+with Interfaces.C;
+
+package body System.OS_Primitives is
+
+   --  ??? These definitions are duplicated from System.OS_Interface
+   --  because we don't want to depend on any package. Consider removing
+   --  these declarations in System.OS_Interface and move these ones in
+   --  the spec.
+
+   subtype int     is Interfaces.C.int;
+   subtype long    is Interfaces.C.long;
+   subtype int64_t is Interfaces.Integer_64;
+
+   type time_t is new int64_t;
+
+   type timespec is record
+      tv_sec  : time_t;
+      tv_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type timezone is record
+      tz_minuteswest : int;
+      tz_dsttime     : int;
+   end record;
+   pragma Convention (C, timezone);
+
+   type timeval is record
+      tv_sec  : time_t;
+      tv_usec : long;   --  Not for NetBSD! FreeBSD/DragonFly
+   end record;
+   pragma Convention (C, timeval);
+
+   function nanosleep (rqtp, rmtp : access timespec)  return int;
+   pragma Import (C, nanosleep, "nanosleep");
+
+   -----------
+   -- Clock --
+   -----------
+
+   function Clock return Duration is
+
+      procedure timeval_to_duration
+        (T    : not null access timeval;
+         sec  : not null access Long_Integer;
+         usec : not null access Long_Integer);
+      pragma Import (C, timeval_to_duration, "__gnat_timeval_to_duration");
+
+      Micro    : constant := 10**6;
+      sec      : aliased Long_Integer;
+      usec     : aliased Long_Integer;
+      TV       : aliased timeval;
+      tzresult : aliased timezone;
+      Result   : int;
+
+      function gettimeofday
+        (Tv : access timeval;
+         Tz : access timezone) return int;
+      pragma Import (C, gettimeofday, "gettimeofday");
+
+      pragma Unreferenced (Result);
+   begin
+      --  The return codes for gettimeofday are as follows (from man pages):
+      --    EPERM  settimeofday is called by someone other than the superuser
+      --    EINVAL Timezone (or something else) is invalid
+      --    EFAULT One of tv or tz pointed outside accessible address space
+
+      --  None of these codes signal a potential clock skew, hence the return
+      --  value is never checked.
+
+      Result := gettimeofday (TV'Access, tzresult'Access);
+      timeval_to_duration (TV'Access, sec'Access, usec'Access);
+      return Duration (sec) + Duration (usec) / Micro;
+   end Clock;
+
+   ---------------------
+   -- Monotonic_Clock --
+   ---------------------
+
+   function Monotonic_Clock return Duration renames Clock;
+
+   -----------------
+   -- To_Timespec --
+   -----------------
+
+   function To_Timespec (D : Duration) return timespec;
+
+   function To_Timespec (D : Duration) return timespec is
+      S : time_t;
+      F : Duration;
+
+   begin
+      S := time_t (Long_Long_Integer (D));
+      F := D - Duration (S);
+
+      --  If F has negative value due to a round-up, adjust for positive F
+      --  value.
+
+      if F < 0.0 then
+         S := S - 1;
+         F := F + 1.0;
+      end if;
+
+      return
+        timespec'(tv_sec  => S,
+                  tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));
+   end To_Timespec;
+
+   -----------------
+   -- Timed_Delay --
+   -----------------
+
+   procedure Timed_Delay
+     (Time : Duration;
+      Mode : Integer)
+   is
+      Request    : aliased timespec;
+      Remaind    : aliased timespec;
+      Rel_Time   : Duration;
+      Abs_Time   : Duration;
+      Base_Time  : constant Duration := Clock;
+      Check_Time : Duration := Base_Time;
+
+      Result     : int;
+      pragma Unreferenced (Result);
+
+   begin
+      if Mode = Relative then
+         Rel_Time := Time;
+         Abs_Time := Time + Check_Time;
+      else
+         Rel_Time := Time - Check_Time;
+         Abs_Time := Time;
+      end if;
+
+      if Rel_Time > 0.0 then
+         loop
+            Request := To_Timespec (Rel_Time);
+            Result := nanosleep (Request'Access, Remaind'Access);
+            Check_Time := Clock;
+
+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;
+
+            Rel_Time := Abs_Time - Check_Time;
+         end loop;
+      end if;
+   end Timed_Delay;
+
+   ----------------
+   -- Initialize --
+   ----------------
+
+   procedure Initialize is
+   begin
+      null;
+   end Initialize;
+
+end System.OS_Primitives;
--- /dev/null
+++ gcc/ada/s-osprim-bsdn6.adb
@@ -0,0 +1,193 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --
+--                                                                          --
+--                  S Y S T E M . O S _ P R I M I T I V E S                 --
+--                                                                          --
+--                                  B o d y                                 --
+--                                                                          --
+--          Copyright (C) 1998-2009, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University.       --
+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --
+--                                                                          --
+-- Copyright (C) 2010, 2011 John Marino <www.dragonlace.net>                --
+------------------------------------------------------------------------------
+
+--  This version is for NetBSD 6.0+
+--  It switches time type to 64 bits and uses compatibility functions
+
+with Interfaces.C;
+
+package body System.OS_Primitives is
+
+   --  ??? These definitions are duplicated from System.OS_Interface
+   --  because we don't want to depend on any package. Consider removing
+   --  these declarations in System.OS_Interface and move these ones in
+   --  the spec.
+
+   subtype int     is Interfaces.C.int;
+   subtype long    is Interfaces.C.long;
+   subtype int64_t is Interfaces.Integer_64;
+
+   type time_t is new int64_t;
+
+   type timespec is record
+      tv_sec  : time_t;
+      tv_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type timezone is record
+      tz_minuteswest : int;
+      tz_dsttime     : int;
+   end record;
+   pragma Convention (C, timezone);
+
+   type timeval is record
+      tv_sec  : time_t;
+      tv_usec : int;
+   end record;
+   pragma Convention (C, timeval);
+
+   function nanosleep (rqtp, rmtp : access timespec)  return int;
+   pragma Import (C, nanosleep, "__nanosleep50");
+
+   -----------
+   -- Clock --
+   -----------
+
+   function Clock return Duration is
+
+      procedure timeval_to_duration
+        (T    : not null access timeval;
+         sec  : not null access Long_Integer;
+         usec : not null access Long_Integer);
+      pragma Import (C, timeval_to_duration, "__gnat_timeval_to_duration");
+
+      Micro    : constant := 10**6;
+      sec      : aliased Long_Integer;
+      usec     : aliased Long_Integer;
+      TV       : aliased timeval;
+      tzresult : aliased timezone;
+      Result   : int;
+
+      function gettimeofday
+        (Tv : access timeval;
+         Tz : access timezone) return int;
+      pragma Import (C, gettimeofday, "__gettimeofday50");
+
+      pragma Unreferenced (Result);
+   begin
+      --  The return codes for gettimeofday are as follows (from man pages):
+      --    EPERM  settimeofday is called by someone other than the superuser
+      --    EINVAL Timezone (or something else) is invalid
+      --    EFAULT One of tv or tz pointed outside accessible address space
+
+      --  None of these codes signal a potential clock skew, hence the return
+      --  value is never checked.
+
+      Result := gettimeofday (TV'Access, tzresult'Access);
+      timeval_to_duration (TV'Access, sec'Access, usec'Access);
+      return Duration (sec) + Duration (usec) / Micro;
+   end Clock;
+
+   ---------------------
+   -- Monotonic_Clock --
+   ---------------------
+
+   function Monotonic_Clock return Duration renames Clock;
+
+   -----------------
+   -- To_Timespec --
+   -----------------
+
+   function To_Timespec (D : Duration) return timespec;
+
+   function To_Timespec (D : Duration) return timespec is
+      S : time_t;
+      F : Duration;
+
+   begin
+      S := time_t (Long_Long_Integer (D));
+      F := D - Duration (S);
+
+      --  If F has negative value due to a round-up, adjust for positive F
+      --  value.
+
+      if F < 0.0 then
+         S := S - 1;
+         F := F + 1.0;
+      end if;
+
+      return
+        timespec'(tv_sec  => S,
+                  tv_nsec => long (Long_Long_Integer (F * 10#1#E9)));
+   end To_Timespec;
+
+   -----------------
+   -- Timed_Delay --
+   -----------------
+
+   procedure Timed_Delay
+     (Time : Duration;
+      Mode : Integer)
+   is
+      Request    : aliased timespec;
+      Remaind    : aliased timespec;
+      Rel_Time   : Duration;
+      Abs_Time   : Duration;
+      Base_Time  : constant Duration := Clock;
+      Check_Time : Duration := Base_Time;
+
+      Result     : int;
+      pragma Unreferenced (Result);
+
+   begin
+      if Mode = Relative then
+         Rel_Time := Time;
+         Abs_Time := Time + Check_Time;
+      else
+         Rel_Time := Time - Check_Time;
+         Abs_Time := Time;
+      end if;
+
+      if Rel_Time > 0.0 then
+         loop
+            Request := To_Timespec (Rel_Time);
+            Result := nanosleep (Request'Access, Remaind'Access);
+            Check_Time := Clock;
+
+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;
+
+            Rel_Time := Abs_Time - Check_Time;
+         end loop;
+      end if;
+   end Timed_Delay;
+
+   ----------------
+   -- Initialize --
+   ----------------
+
+   procedure Initialize is
+   begin
+      null;
+   end Initialize;
+
+end System.OS_Primitives;
--- gcc/ada/s-rannum.adb.orig
+++ gcc/ada/s-rannum.adb
@@ -290,7 +290,7 @@
             X      : Real;            --  Scaled mantissa
             R      : Unsigned_32;     --  Supply of random bits
             R_Bits : Natural;         --  Number of bits left in R
-            K      : Bit_Count;       --  Next decrement to exponent
+            K      : Bit_Count := 0;  --  Next decrement to exponent
 
          begin
             Mantissa := Random (Gen) / 2**Extra_Bits;
--- /dev/null
+++ gcc/ada/signal_android.c
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *  * Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+#include <limits.h>		/* For LONG_BIT */
+#include <string.h>		/* For memset() */
+
+typedef unsigned long sigset_t;
+
+
+int
+sigismember(sigset_t *set, int signum)
+{
+    unsigned long *local_set = (unsigned long *)set;
+    signum--;
+    return (int)((local_set[signum/LONG_BIT] >> (signum%LONG_BIT)) & 1);
+}
+
+
+int
+sigaddset(sigset_t *set, int signum)
+{
+    unsigned long *local_set = (unsigned long *)set;
+    signum--;
+    local_set[signum/LONG_BIT] |= 1UL << (signum%LONG_BIT);
+    return 0;
+}
+
+
+int
+sigdelset(sigset_t *set, int signum)
+{
+    unsigned long *local_set = (unsigned long *)set;
+    signum--;
+    local_set[signum/LONG_BIT] &= ~(1UL << (signum%LONG_BIT));
+    return 0;
+}
+
+
+int
+sigemptyset(sigset_t *set)
+{
+    memset(set, 0, sizeof *set);
+    return 0;
+}
+
+
+int
+sigfillset(sigset_t *set)
+{
+    memset(set, ~0, sizeof *set);
+    return 0;
+}
+
--- gcc/ada/sysdep.c.orig
+++ gcc/ada/sysdep.c
@@ -256,6 +256,7 @@
   || defined (__MACHTEN__) || defined (__hpux__) || defined (_AIX) \
   || (defined (__svr4__) && defined (i386)) || defined (__Lynx__) \
   || defined (__CYGWIN__) || defined (__FreeBSD__) || defined (__OpenBSD__) \
+  || defined (__DragonFly__) \
   || defined (__GLIBC__) || defined (__APPLE__)
 
 #ifdef __MINGW32__
@@ -314,6 +315,7 @@
     || defined (__CYGWIN32__) || defined (__MACHTEN__) || defined (__hpux__) \
     || defined (_AIX) || (defined (__svr4__) && defined (i386)) \
     || defined (__Lynx__) || defined (__FreeBSD__) || defined (__OpenBSD__) \
+    || defined (__DragonFly__) \
     || defined (__GLIBC__) || defined (__APPLE__)
   char c;
   int nread;
@@ -334,6 +336,7 @@
     || defined (__osf__) || defined (__MACHTEN__) || defined (__hpux__) \
     || defined (_AIX) || (defined (__svr4__) && defined (i386)) \
     || defined (__Lynx__) || defined (__FreeBSD__) || defined (__OpenBSD__) \
+    || defined (__DragonFly__) \
     || defined (__GLIBC__) || defined (__APPLE__)
       eof_ch = termios_rec.c_cc[VEOF];
 
@@ -845,8 +848,12 @@
 /* Darwin, Free BSD, Linux, Tru64, where component tm_gmtoff is present in
    struct tm */
 
-#elif defined (__APPLE__) || defined (__FreeBSD__) || defined (linux) ||\
-     (defined (__alpha__) && defined (__osf__)) || defined (__GLIBC__)
+#elif defined (__APPLE__) \
+   || defined (__FreeBSD__) \
+   || defined (__DragonFly__) \
+   || defined (linux) \
+   || (defined (__alpha__) && defined (__osf__)) \
+   || defined (__GLIBC__)
 {
   localtime_r (timer, &tp);
   *off = tp.tm_gmtoff;
--- /dev/null
+++ gcc/ada/system-dragonfly-x86.ads
@@ -0,0 +1,143 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                        GNAT RUN-TIME COMPONENTS                          --
+--                                                                          --
+--                               S Y S T E M                                --
+--                                                                          --
+--                                 S p e c                                  --
+--                       (DragonFly BSD/x86 Version)                        --
+--                                                                          --
+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- This specification is derived from the Ada Reference Manual for use with --
+-- GNAT. The copyright notice above, and the license provisions that follow --
+-- apply solely to the  contents of the part following the private keyword. --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+package System is
+   pragma Pure;
+   --  Note that we take advantage of the implementation permission to make
+   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
+   --  2005, this is Pure in any case (AI-362).
+
+   type Name is (SYSTEM_NAME_GNAT);
+   System_Name : constant Name := SYSTEM_NAME_GNAT;
+
+   --  System-Dependent Named Numbers
+
+   Min_Int               : constant := Long_Long_Integer'First;
+   Max_Int               : constant := Long_Long_Integer'Last;
+
+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;
+   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;
+
+   Max_Base_Digits       : constant := Long_Long_Float'Digits;
+   Max_Digits            : constant := Long_Long_Float'Digits;
+
+   Max_Mantissa          : constant := 63;
+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);
+
+   Tick                  : constant := 0.000_001;
+
+   --  Storage-related Declarations
+
+   type Address is private;
+   pragma Preelaborable_Initialization (Address);
+   Null_Address : constant Address;
+
+   Storage_Unit : constant := 8;
+   Word_Size    : constant := 32;
+   Memory_Size  : constant := 2 ** 32;
+
+   --  Address comparison
+
+   function "<"  (Left, Right : Address) return Boolean;
+   function "<=" (Left, Right : Address) return Boolean;
+   function ">"  (Left, Right : Address) return Boolean;
+   function ">=" (Left, Right : Address) return Boolean;
+   function "="  (Left, Right : Address) return Boolean;
+
+   pragma Import (Intrinsic, "<");
+   pragma Import (Intrinsic, "<=");
+   pragma Import (Intrinsic, ">");
+   pragma Import (Intrinsic, ">=");
+   pragma Import (Intrinsic, "=");
+
+   --  Other System-Dependent Declarations
+
+   type Bit_Order is (High_Order_First, Low_Order_First);
+   Default_Bit_Order : constant Bit_Order := Low_Order_First;
+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning
+
+   --  Priority-related Declarations (RM D.1)
+
+   Max_Priority           : constant Positive := 30;
+   Max_Interrupt_Priority : constant Positive := 31;
+
+   subtype Any_Priority       is Integer      range  0 .. 31;
+   subtype Priority           is Any_Priority range  0 .. 30;
+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;
+
+   Default_Priority : constant Priority := 15;
+
+private
+
+   type Address is mod Memory_Size;
+   Null_Address : constant Address := 0;
+
+   --------------------------------------
+   -- System Implementation Parameters --
+   --------------------------------------
+
+   --  These parameters provide information about the target that is used
+   --  by the compiler. They are in the private part of System, where they
+   --  can be accessed using the special circuitry in the Targparm unit
+   --  whose source should be consulted for more detailed descriptions
+   --  of the individual switch values.
+
+   Backend_Divide_Checks     : constant Boolean := False;
+   Backend_Overflow_Checks   : constant Boolean := True;
+   Command_Line_Args         : constant Boolean := True;
+   Configurable_Run_Time     : constant Boolean := False;
+   Denorm                    : constant Boolean := True;
+   Duration_32_Bits          : constant Boolean := False;
+   Exit_Status_Supported     : constant Boolean := True;
+   Fractional_Fixed_Ops      : constant Boolean := False;
+   Frontend_Layout           : constant Boolean := False;
+   Machine_Overflows         : constant Boolean := False;
+   Machine_Rounds            : constant Boolean := True;
+   Preallocated_Stacks       : constant Boolean := False;
+   Signed_Zeros              : constant Boolean := True;
+   Stack_Check_Default       : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := True;
+   Stack_Check_Limits        : constant Boolean := False;
+   Support_Aggregates        : constant Boolean := True;
+   Support_Composite_Assign  : constant Boolean := True;
+   Support_Composite_Compare : constant Boolean := True;
+   Support_Long_Shifts       : constant Boolean := True;
+   Always_Compatible_Rep     : constant Boolean := False;
+   Suppress_Standard_Library : constant Boolean := False;
+   Use_Ada_Main_Program_Name : constant Boolean := False;
+   ZCX_By_Default            : constant Boolean := True;
+
+end System;
--- /dev/null
+++ gcc/ada/system-dragonfly-x86_64.ads
@@ -0,0 +1,143 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                        GNAT RUN-TIME COMPONENTS                          --
+--                                                                          --
+--                               S Y S T E M                                --
+--                                                                          --
+--                                 S p e c                                  --
+--                     (DragonFly BSD/x86_64 Version)                       --
+--                                                                          --
+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- This specification is derived from the Ada Reference Manual for use with --
+-- GNAT. The copyright notice above, and the license provisions that follow --
+-- apply solely to the  contents of the part following the private keyword. --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+package System is
+   pragma Pure;
+   --  Note that we take advantage of the implementation permission to make
+   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
+   --  2005, this is Pure in any case (AI-362).
+
+   type Name is (SYSTEM_NAME_GNAT);
+   System_Name : constant Name := SYSTEM_NAME_GNAT;
+
+   --  System-Dependent Named Numbers
+
+   Min_Int               : constant := Long_Long_Integer'First;
+   Max_Int               : constant := Long_Long_Integer'Last;
+
+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;
+   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;
+
+   Max_Base_Digits       : constant := Long_Long_Float'Digits;
+   Max_Digits            : constant := Long_Long_Float'Digits;
+
+   Max_Mantissa          : constant := 63;
+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);
+
+   Tick                  : constant := 0.000_001;
+
+   --  Storage-related Declarations
+
+   type Address is private;
+   pragma Preelaborable_Initialization (Address);
+   Null_Address : constant Address;
+
+   Storage_Unit : constant := 8;
+   Word_Size    : constant := 64;
+   Memory_Size  : constant := 2 ** 64;
+
+   --  Address comparison
+
+   function "<"  (Left, Right : Address) return Boolean;
+   function "<=" (Left, Right : Address) return Boolean;
+   function ">"  (Left, Right : Address) return Boolean;
+   function ">=" (Left, Right : Address) return Boolean;
+   function "="  (Left, Right : Address) return Boolean;
+
+   pragma Import (Intrinsic, "<");
+   pragma Import (Intrinsic, "<=");
+   pragma Import (Intrinsic, ">");
+   pragma Import (Intrinsic, ">=");
+   pragma Import (Intrinsic, "=");
+
+   --  Other System-Dependent Declarations
+
+   type Bit_Order is (High_Order_First, Low_Order_First);
+   Default_Bit_Order : constant Bit_Order := Low_Order_First;
+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning
+
+   --  Priority-related Declarations (RM D.1)
+
+   Max_Priority           : constant Positive := 30;
+   Max_Interrupt_Priority : constant Positive := 31;
+
+   subtype Any_Priority       is Integer      range  0 .. 31;
+   subtype Priority           is Any_Priority range  0 .. 30;
+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;
+
+   Default_Priority : constant Priority := 15;
+
+private
+
+   type Address is mod Memory_Size;
+   Null_Address : constant Address := 0;
+
+   --------------------------------------
+   -- System Implementation Parameters --
+   --------------------------------------
+
+   --  These parameters provide information about the target that is used
+   --  by the compiler. They are in the private part of System, where they
+   --  can be accessed using the special circuitry in the Targparm unit
+   --  whose source should be consulted for more detailed descriptions
+   --  of the individual switch values.
+
+   Backend_Divide_Checks     : constant Boolean := False;
+   Backend_Overflow_Checks   : constant Boolean := True;
+   Command_Line_Args         : constant Boolean := True;
+   Configurable_Run_Time     : constant Boolean := False;
+   Denorm                    : constant Boolean := True;
+   Duration_32_Bits          : constant Boolean := False;
+   Exit_Status_Supported     : constant Boolean := True;
+   Fractional_Fixed_Ops      : constant Boolean := False;
+   Frontend_Layout           : constant Boolean := False;
+   Machine_Overflows         : constant Boolean := False;
+   Machine_Rounds            : constant Boolean := True;
+   Preallocated_Stacks       : constant Boolean := False;
+   Signed_Zeros              : constant Boolean := True;
+   Stack_Check_Default       : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := True;
+   Stack_Check_Limits        : constant Boolean := False;
+   Support_Aggregates        : constant Boolean := True;
+   Support_Composite_Assign  : constant Boolean := True;
+   Support_Composite_Compare : constant Boolean := True;
+   Support_Long_Shifts       : constant Boolean := True;
+   Always_Compatible_Rep     : constant Boolean := False;
+   Suppress_Standard_Library : constant Boolean := False;
+   Use_Ada_Main_Program_Name : constant Boolean := False;
+   ZCX_By_Default            : constant Boolean := True;
+
+end System;
--- /dev/null
+++ gcc/ada/system-netbsd-x86.ads
@@ -0,0 +1,143 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                        GNAT RUN-TIME COMPONENTS                          --
+--                                                                          --
+--                               S Y S T E M                                --
+--                                                                          --
+--                                 S p e c                                  --
+--                           (NetBSD/x86 Version)                           --
+--                                                                          --
+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- This specification is derived from the Ada Reference Manual for use with --
+-- GNAT. The copyright notice above, and the license provisions that follow --
+-- apply solely to the  contents of the part following the private keyword. --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+package System is
+   pragma Pure;
+   --  Note that we take advantage of the implementation permission to make
+   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
+   --  2005, this is Pure in any case (AI-362).
+
+   type Name is (SYSTEM_NAME_GNAT);
+   System_Name : constant Name := SYSTEM_NAME_GNAT;
+
+   --  System-Dependent Named Numbers
+
+   Min_Int               : constant := Long_Long_Integer'First;
+   Max_Int               : constant := Long_Long_Integer'Last;
+
+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;
+   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;
+
+   Max_Base_Digits       : constant := Long_Long_Float'Digits;
+   Max_Digits            : constant := Long_Long_Float'Digits;
+
+   Max_Mantissa          : constant := 63;
+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);
+
+   Tick                  : constant := 0.000_001;
+
+   --  Storage-related Declarations
+
+   type Address is private;
+   pragma Preelaborable_Initialization (Address);
+   Null_Address : constant Address;
+
+   Storage_Unit : constant := 8;
+   Word_Size    : constant := 32;
+   Memory_Size  : constant := 2 ** 32;
+
+   --  Address comparison
+
+   function "<"  (Left, Right : Address) return Boolean;
+   function "<=" (Left, Right : Address) return Boolean;
+   function ">"  (Left, Right : Address) return Boolean;
+   function ">=" (Left, Right : Address) return Boolean;
+   function "="  (Left, Right : Address) return Boolean;
+
+   pragma Import (Intrinsic, "<");
+   pragma Import (Intrinsic, "<=");
+   pragma Import (Intrinsic, ">");
+   pragma Import (Intrinsic, ">=");
+   pragma Import (Intrinsic, "=");
+
+   --  Other System-Dependent Declarations
+
+   type Bit_Order is (High_Order_First, Low_Order_First);
+   Default_Bit_Order : constant Bit_Order := Low_Order_First;
+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning
+
+   --  Priority-related Declarations (RM D.1)
+
+   Max_Priority           : constant Positive := 30;
+   Max_Interrupt_Priority : constant Positive := 31;
+
+   subtype Any_Priority       is Integer      range  0 .. 31;
+   subtype Priority           is Any_Priority range  0 .. 30;
+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;
+
+   Default_Priority : constant Priority := 15;
+
+private
+
+   type Address is mod Memory_Size;
+   Null_Address : constant Address := 0;
+
+   --------------------------------------
+   -- System Implementation Parameters --
+   --------------------------------------
+
+   --  These parameters provide information about the target that is used
+   --  by the compiler. They are in the private part of System, where they
+   --  can be accessed using the special circuitry in the Targparm unit
+   --  whose source should be consulted for more detailed descriptions
+   --  of the individual switch values.
+
+   Backend_Divide_Checks     : constant Boolean := False;
+   Backend_Overflow_Checks   : constant Boolean := True;
+   Command_Line_Args         : constant Boolean := True;
+   Configurable_Run_Time     : constant Boolean := False;
+   Denorm                    : constant Boolean := True;
+   Duration_32_Bits          : constant Boolean := False;
+   Exit_Status_Supported     : constant Boolean := True;
+   Fractional_Fixed_Ops      : constant Boolean := False;
+   Frontend_Layout           : constant Boolean := False;
+   Machine_Overflows         : constant Boolean := False;
+   Machine_Rounds            : constant Boolean := True;
+   Preallocated_Stacks       : constant Boolean := False;
+   Signed_Zeros              : constant Boolean := True;
+   Stack_Check_Default       : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := True;
+   Stack_Check_Limits        : constant Boolean := False;
+   Support_Aggregates        : constant Boolean := True;
+   Support_Composite_Assign  : constant Boolean := True;
+   Support_Composite_Compare : constant Boolean := True;
+   Support_Long_Shifts       : constant Boolean := True;
+   Always_Compatible_Rep     : constant Boolean := False;
+   Suppress_Standard_Library : constant Boolean := False;
+   Use_Ada_Main_Program_Name : constant Boolean := False;
+   ZCX_By_Default            : constant Boolean := True;
+
+end System;
--- /dev/null
+++ gcc/ada/system-netbsd-x86_64.ads
@@ -0,0 +1,143 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                        GNAT RUN-TIME COMPONENTS                          --
+--                                                                          --
+--                               S Y S T E M                                --
+--                                                                          --
+--                                 S p e c                                  --
+--                         (NetBSD/x86_64 Version)                          --
+--                                                                          --
+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- This specification is derived from the Ada Reference Manual for use with --
+-- GNAT. The copyright notice above, and the license provisions that follow --
+-- apply solely to the  contents of the part following the private keyword. --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+package System is
+   pragma Pure;
+   --  Note that we take advantage of the implementation permission to make
+   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
+   --  2005, this is Pure in any case (AI-362).
+
+   type Name is (SYSTEM_NAME_GNAT);
+   System_Name : constant Name := SYSTEM_NAME_GNAT;
+
+   --  System-Dependent Named Numbers
+
+   Min_Int               : constant := Long_Long_Integer'First;
+   Max_Int               : constant := Long_Long_Integer'Last;
+
+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;
+   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;
+
+   Max_Base_Digits       : constant := Long_Long_Float'Digits;
+   Max_Digits            : constant := Long_Long_Float'Digits;
+
+   Max_Mantissa          : constant := 63;
+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);
+
+   Tick                  : constant := 0.000_001;
+
+   --  Storage-related Declarations
+
+   type Address is private;
+   pragma Preelaborable_Initialization (Address);
+   Null_Address : constant Address;
+
+   Storage_Unit : constant := 8;
+   Word_Size    : constant := 64;
+   Memory_Size  : constant := 2 ** 64;
+
+   --  Address comparison
+
+   function "<"  (Left, Right : Address) return Boolean;
+   function "<=" (Left, Right : Address) return Boolean;
+   function ">"  (Left, Right : Address) return Boolean;
+   function ">=" (Left, Right : Address) return Boolean;
+   function "="  (Left, Right : Address) return Boolean;
+
+   pragma Import (Intrinsic, "<");
+   pragma Import (Intrinsic, "<=");
+   pragma Import (Intrinsic, ">");
+   pragma Import (Intrinsic, ">=");
+   pragma Import (Intrinsic, "=");
+
+   --  Other System-Dependent Declarations
+
+   type Bit_Order is (High_Order_First, Low_Order_First);
+   Default_Bit_Order : constant Bit_Order := Low_Order_First;
+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning
+
+   --  Priority-related Declarations (RM D.1)
+
+   Max_Priority           : constant Positive := 30;
+   Max_Interrupt_Priority : constant Positive := 31;
+
+   subtype Any_Priority       is Integer      range  0 .. 31;
+   subtype Priority           is Any_Priority range  0 .. 30;
+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;
+
+   Default_Priority : constant Priority := 15;
+
+private
+
+   type Address is mod Memory_Size;
+   Null_Address : constant Address := 0;
+
+   --------------------------------------
+   -- System Implementation Parameters --
+   --------------------------------------
+
+   --  These parameters provide information about the target that is used
+   --  by the compiler. They are in the private part of System, where they
+   --  can be accessed using the special circuitry in the Targparm unit
+   --  whose source should be consulted for more detailed descriptions
+   --  of the individual switch values.
+
+   Backend_Divide_Checks     : constant Boolean := False;
+   Backend_Overflow_Checks   : constant Boolean := True;
+   Command_Line_Args         : constant Boolean := True;
+   Configurable_Run_Time     : constant Boolean := False;
+   Denorm                    : constant Boolean := True;
+   Duration_32_Bits          : constant Boolean := False;
+   Exit_Status_Supported     : constant Boolean := True;
+   Fractional_Fixed_Ops      : constant Boolean := False;
+   Frontend_Layout           : constant Boolean := False;
+   Machine_Overflows         : constant Boolean := False;
+   Machine_Rounds            : constant Boolean := True;
+   Preallocated_Stacks       : constant Boolean := False;
+   Signed_Zeros              : constant Boolean := True;
+   Stack_Check_Default       : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := True;
+   Stack_Check_Limits        : constant Boolean := False;
+   Support_Aggregates        : constant Boolean := True;
+   Support_Composite_Assign  : constant Boolean := True;
+   Support_Composite_Compare : constant Boolean := True;
+   Support_Long_Shifts       : constant Boolean := True;
+   Always_Compatible_Rep     : constant Boolean := False;
+   Suppress_Standard_Library : constant Boolean := False;
+   Use_Ada_Main_Program_Name : constant Boolean := False;
+   ZCX_By_Default            : constant Boolean := True;
+
+end System;
--- /dev/null
+++ gcc/ada/system-openbsd-x86.ads
@@ -0,0 +1,143 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                        GNAT RUN-TIME COMPONENTS                          --
+--                                                                          --
+--                               S Y S T E M                                --
+--                                                                          --
+--                                 S p e c                                  --
+--                          (OpenBSD/x86 Version)                        --
+--                                                                          --
+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- This specification is derived from the Ada Reference Manual for use with --
+-- GNAT. The copyright notice above, and the license provisions that follow --
+-- apply solely to the  contents of the part following the private keyword. --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+package System is
+   pragma Pure;
+   --  Note that we take advantage of the implementation permission to make
+   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
+   --  2005, this is Pure in any case (AI-362).
+
+   type Name is (SYSTEM_NAME_GNAT);
+   System_Name : constant Name := SYSTEM_NAME_GNAT;
+
+   --  System-Dependent Named Numbers
+
+   Min_Int               : constant := Long_Long_Integer'First;
+   Max_Int               : constant := Long_Long_Integer'Last;
+
+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;
+   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;
+
+   Max_Base_Digits       : constant := Long_Long_Float'Digits;
+   Max_Digits            : constant := Long_Long_Float'Digits;
+
+   Max_Mantissa          : constant := 63;
+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);
+
+   Tick                  : constant := 0.000_001;
+
+   --  Storage-related Declarations
+
+   type Address is private;
+   pragma Preelaborable_Initialization (Address);
+   Null_Address : constant Address;
+
+   Storage_Unit : constant := 8;
+   Word_Size    : constant := 32;
+   Memory_Size  : constant := 2 ** 32;
+
+   --  Address comparison
+
+   function "<"  (Left, Right : Address) return Boolean;
+   function "<=" (Left, Right : Address) return Boolean;
+   function ">"  (Left, Right : Address) return Boolean;
+   function ">=" (Left, Right : Address) return Boolean;
+   function "="  (Left, Right : Address) return Boolean;
+
+   pragma Import (Intrinsic, "<");
+   pragma Import (Intrinsic, "<=");
+   pragma Import (Intrinsic, ">");
+   pragma Import (Intrinsic, ">=");
+   pragma Import (Intrinsic, "=");
+
+   --  Other System-Dependent Declarations
+
+   type Bit_Order is (High_Order_First, Low_Order_First);
+   Default_Bit_Order : constant Bit_Order := Low_Order_First;
+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning
+
+   --  Priority-related Declarations (RM D.1)
+
+   Max_Priority           : constant Positive := 30;
+   Max_Interrupt_Priority : constant Positive := 31;
+
+   subtype Any_Priority       is Integer      range  0 .. 31;
+   subtype Priority           is Any_Priority range  0 .. 30;
+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;
+
+   Default_Priority : constant Priority := 15;
+
+private
+
+   type Address is mod Memory_Size;
+   Null_Address : constant Address := 0;
+
+   --------------------------------------
+   -- System Implementation Parameters --
+   --------------------------------------
+
+   --  These parameters provide information about the target that is used
+   --  by the compiler. They are in the private part of System, where they
+   --  can be accessed using the special circuitry in the Targparm unit
+   --  whose source should be consulted for more detailed descriptions
+   --  of the individual switch values.
+
+   Backend_Divide_Checks     : constant Boolean := False;
+   Backend_Overflow_Checks   : constant Boolean := True;
+   Command_Line_Args         : constant Boolean := True;
+   Configurable_Run_Time     : constant Boolean := False;
+   Denorm                    : constant Boolean := True;
+   Duration_32_Bits          : constant Boolean := False;
+   Exit_Status_Supported     : constant Boolean := True;
+   Fractional_Fixed_Ops      : constant Boolean := False;
+   Frontend_Layout           : constant Boolean := False;
+   Machine_Overflows         : constant Boolean := False;
+   Machine_Rounds            : constant Boolean := True;
+   Preallocated_Stacks       : constant Boolean := False;
+   Signed_Zeros              : constant Boolean := True;
+   Stack_Check_Default       : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := True;
+   Stack_Check_Limits        : constant Boolean := False;
+   Support_Aggregates        : constant Boolean := True;
+   Support_Composite_Assign  : constant Boolean := True;
+   Support_Composite_Compare : constant Boolean := True;
+   Support_Long_Shifts       : constant Boolean := True;
+   Always_Compatible_Rep     : constant Boolean := True;
+   Suppress_Standard_Library : constant Boolean := False;
+   Use_Ada_Main_Program_Name : constant Boolean := False;
+   ZCX_By_Default            : constant Boolean := False;
+
+end System;
--- /dev/null
+++ gcc/ada/system-openbsd-x86_64.ads
@@ -0,0 +1,143 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                        GNAT RUN-TIME COMPONENTS                          --
+--                                                                          --
+--                               S Y S T E M                                --
+--                                                                          --
+--                                 S p e c                                  --
+--                        (OpenBSD/x86_64 Version)                       --
+--                                                                          --
+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --
+--                                                                          --
+-- This specification is derived from the Ada Reference Manual for use with --
+-- GNAT. The copyright notice above, and the license provisions that follow --
+-- apply solely to the  contents of the part following the private keyword. --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+package System is
+   pragma Pure;
+   --  Note that we take advantage of the implementation permission to make
+   --  this unit Pure instead of Preelaborable; see RM 13.7.1(15). In Ada
+   --  2005, this is Pure in any case (AI-362).
+
+   type Name is (SYSTEM_NAME_GNAT);
+   System_Name : constant Name := SYSTEM_NAME_GNAT;
+
+   --  System-Dependent Named Numbers
+
+   Min_Int               : constant := Long_Long_Integer'First;
+   Max_Int               : constant := Long_Long_Integer'Last;
+
+   Max_Binary_Modulus    : constant := 2 ** Long_Long_Integer'Size;
+   Max_Nonbinary_Modulus : constant := 2 ** Integer'Size - 1;
+
+   Max_Base_Digits       : constant := Long_Long_Float'Digits;
+   Max_Digits            : constant := Long_Long_Float'Digits;
+
+   Max_Mantissa          : constant := 63;
+   Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);
+
+   Tick                  : constant := 0.000_001;
+
+   --  Storage-related Declarations
+
+   type Address is private;
+   pragma Preelaborable_Initialization (Address);
+   Null_Address : constant Address;
+
+   Storage_Unit : constant := 8;
+   Word_Size    : constant := 64;
+   Memory_Size  : constant := 2 ** 64;
+
+   --  Address comparison
+
+   function "<"  (Left, Right : Address) return Boolean;
+   function "<=" (Left, Right : Address) return Boolean;
+   function ">"  (Left, Right : Address) return Boolean;
+   function ">=" (Left, Right : Address) return Boolean;
+   function "="  (Left, Right : Address) return Boolean;
+
+   pragma Import (Intrinsic, "<");
+   pragma Import (Intrinsic, "<=");
+   pragma Import (Intrinsic, ">");
+   pragma Import (Intrinsic, ">=");
+   pragma Import (Intrinsic, "=");
+
+   --  Other System-Dependent Declarations
+
+   type Bit_Order is (High_Order_First, Low_Order_First);
+   Default_Bit_Order : constant Bit_Order := Low_Order_First;
+   pragma Warnings (Off, Default_Bit_Order); -- kill constant condition warning
+
+   --  Priority-related Declarations (RM D.1)
+
+   Max_Priority           : constant Positive := 30;
+   Max_Interrupt_Priority : constant Positive := 31;
+
+   subtype Any_Priority       is Integer      range  0 .. 31;
+   subtype Priority           is Any_Priority range  0 .. 30;
+   subtype Interrupt_Priority is Any_Priority range 31 .. 31;
+
+   Default_Priority : constant Priority := 15;
+
+private
+
+   type Address is mod Memory_Size;
+   Null_Address : constant Address := 0;
+
+   --------------------------------------
+   -- System Implementation Parameters --
+   --------------------------------------
+
+   --  These parameters provide information about the target that is used
+   --  by the compiler. They are in the private part of System, where they
+   --  can be accessed using the special circuitry in the Targparm unit
+   --  whose source should be consulted for more detailed descriptions
+   --  of the individual switch values.
+
+   Backend_Divide_Checks     : constant Boolean := False;
+   Backend_Overflow_Checks   : constant Boolean := True;
+   Command_Line_Args         : constant Boolean := True;
+   Configurable_Run_Time     : constant Boolean := False;
+   Denorm                    : constant Boolean := True;
+   Duration_32_Bits          : constant Boolean := False;
+   Exit_Status_Supported     : constant Boolean := True;
+   Fractional_Fixed_Ops      : constant Boolean := False;
+   Frontend_Layout           : constant Boolean := False;
+   Machine_Overflows         : constant Boolean := False;
+   Machine_Rounds            : constant Boolean := True;
+   Preallocated_Stacks       : constant Boolean := False;
+   Signed_Zeros              : constant Boolean := True;
+   Stack_Check_Default       : constant Boolean := False;
+   Stack_Check_Probes        : constant Boolean := True;
+   Stack_Check_Limits        : constant Boolean := False;
+   Support_Aggregates        : constant Boolean := True;
+   Support_Composite_Assign  : constant Boolean := True;
+   Support_Composite_Compare : constant Boolean := True;
+   Support_Long_Shifts       : constant Boolean := True;
+   Always_Compatible_Rep     : constant Boolean := True;
+   Suppress_Standard_Library : constant Boolean := False;
+   Use_Ada_Main_Program_Name : constant Boolean := False;
+   ZCX_By_Default            : constant Boolean := False;
+
+end System;
--- gcc/ada/tracebak.c.orig
+++ gcc/ada/tracebak.c
@@ -217,6 +217,23 @@
 #error Unhandled darwin architecture.
 #endif
 
+/*---------------------------- x86 *BSD --------------------------------*/
+
+#elif defined (__i386__) &&   \
+    ( defined (__NetBSD__)    \
+   || defined (__FreeBSD__)   \
+   || defined (__OpenBSD__)   \
+   || defined (__DragonFly__) )
+  
+#define USE_GCC_UNWINDER
+/* The generic unwinder is not used for this target because the default
+   implementation doesn't unwind on the BSD platforms.  AMD64 targets use the
+   gcc unwinder for all platforms, so let's keep i386 consistent with that.
+*/
+
+#define PC_ADJUST -2
+/* The minimum size of call instructions on this architecture is 2 bytes */
+
 /*------------------------ PPC AIX/Older Darwin -------------------------*/
 #elif ((defined (_POWER) && defined (_AIX)) || \
 (defined (__ppc__) && defined (__APPLE__)))
--- gcc/ada/gcc-interface/Makefile.in.orig
+++ gcc/ada/gcc-interface/Makefile.in
@@ -1037,6 +1037,7 @@
 ifeq ($(strip $(filter-out %86 %x86_64 solaris2%,$(arch) $(osys))),)
   LIBGNAT_TARGET_PAIRS_COMMON = \
   a-intnam.ads<a-intnam-solaris.ads \
+  g-trasym.adb<g-trasym-bsd.adb \
   s-inmaop.adb<s-inmaop-posix.adb \
   s-intman.adb<s-intman-solaris.adb \
   s-mudido.adb<s-mudido-affinity.adb \
@@ -1205,14 +1206,21 @@
   LIBRARY_VERSION := $(LIB_VERSION)
 endif
 
+
+# FREEBSD i386
 ifeq ($(strip $(filter-out %86 freebsd%,$(arch) $(osys))),)
   LIBGNAT_TARGET_PAIRS = \
+  a-exetim.adb<a-exetim-posix.adb \
+  a-exetim.ads<a-exetim-default.ads \
   a-intnam.ads<a-intnam-freebsd.ads \
+  g-socthi.adb<g-socthi-bsd.adb \
+  g-trasym.adb<g-trasym-bsd.adb \
   s-inmaop.adb<s-inmaop-posix.adb \
   s-intman.adb<s-intman-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
   s-osinte.adb<s-osinte-freebsd.adb \
-  s-osinte.ads<s-osinte-freebsd.ads \
-  s-osprim.adb<s-osprim-posix.adb \
+  s-osinte.ads<s-osinte-freebsd32.ads \
+  s-osprim.adb<s-osprim-bsd32.adb \
   s-taprop.adb<s-taprop-posix.adb \
   s-taspri.ads<s-taspri-posix.ads \
   s-tpopsp.adb<s-tpopsp-posix.adb \
@@ -1220,10 +1228,11 @@
   $(X86_TARGET_PAIRS) \
   system.ads<system-freebsd-x86.ads
 
-  TOOLS_TARGET_PAIRS = \
-  mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb
   GNATLIB_SHARED = gnatlib-shared-dual
 
+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o
+  EXTRA_GNATRTL_TASKING_OBJS=a-exetim.o
+
   EH_MECHANISM=-gcc
   THREADSLIB= -lpthread
   GMEM_LIB = gmemlib
@@ -1231,26 +1240,101 @@
   MISCLIB = -lutil
 endif
 
-ifeq ($(strip $(filter-out %86_64 freebsd%,$(arch) $(osys))),)
+
+# FREEBSD AMD64
+ifeq ($(strip $(filter-out x86_64 freebsd%,$(arch) $(osys))),)
   LIBGNAT_TARGET_PAIRS = \
+  a-exetim.adb<a-exetim-posix.adb \
+  a-exetim.ads<a-exetim-default.ads \
   a-intnam.ads<a-intnam-freebsd.ads \
+  g-socthi.adb<g-socthi-bsd.adb \
+  g-trasym.adb<g-trasym-bsd.adb \
   s-inmaop.adb<s-inmaop-posix.adb \
   s-intman.adb<s-intman-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
   s-osinte.adb<s-osinte-freebsd.adb \
-  s-osinte.ads<s-osinte-freebsd.ads \
-  s-osprim.adb<s-osprim-posix.adb \
+  s-osinte.ads<s-osinte-freebsd64.ads \
+  s-osprim.adb<s-osprim-bsd64.adb \
   s-taprop.adb<s-taprop-posix.adb \
   s-taspri.ads<s-taspri-posix.ads \
   s-tpopsp.adb<s-tpopsp-posix.adb \
-  g-trasym.adb<g-trasym-dwarf.adb \
   $(ATOMICS_TARGET_PAIRS) \
   $(X86_64_TARGET_PAIRS) \
   system.ads<system-freebsd-x86_64.ads
 
-  TOOLS_TARGET_PAIRS = \
-  mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb
   GNATLIB_SHARED = gnatlib-shared-dual
 
+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o
+  EXTRA_GNATRTL_TASKING_OBJS=a-exetim.o
+
+  EH_MECHANISM=-gcc
+  THREADSLIB= -lpthread
+  GMEM_LIB = gmemlib
+  LIBRARY_VERSION := $(LIB_VERSION)
+  MISCLIB = -lutil
+endif
+
+
+# DRAGONFLY i386
+ifeq ($(strip $(filter-out %86 dragonfly%,$(arch) $(osys))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-exetim.adb<a-exetim-posix.adb \
+  a-exetim.ads<a-exetim-default.ads \
+  a-intnam.ads<a-intnam-dragonfly.ads \
+  g-socthi.adb<g-socthi-bsd.adb \
+  g-trasym.adb<g-trasym-bsd.adb \
+  s-inmaop.adb<s-inmaop-posix.adb \
+  s-intman.adb<s-intman-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
+  s-osinte.adb<s-osinte-dragonfly.adb \
+  s-osinte.ads<s-osinte-dragonfly.ads \
+  s-osprim.adb<s-osprim-posix.adb \
+  s-taprop.adb<s-taprop-posix.adb \
+  s-taspri.ads<s-taspri-posix.ads \
+  s-tpopsp.adb<s-tpopsp-posix.adb \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(X86_TARGET_PAIRS) \
+  system.ads<system-dragonfly-x86.ads
+
+  GNATLIB_SHARED = gnatlib-shared-dual
+
+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o
+  EXTRA_GNATRTL_TASKING_OBJS=a-exetim.o
+
+  EH_MECHANISM=-gcc
+  THREADSLIB= -lpthread
+  GMEM_LIB = gmemlib
+  LIBRARY_VERSION := $(LIB_VERSION)
+  MISCLIB = -lutil
+endif
+
+
+# DRAGONFLY AMD64
+ifeq ($(strip $(filter-out x86_64 dragonfly%,$(arch) $(osys))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-exetim.adb<a-exetim-posix.adb \
+  a-exetim.ads<a-exetim-default.ads \
+  a-intnam.ads<a-intnam-dragonfly.ads \
+  g-socthi.adb<g-socthi-bsd.adb \
+  g-trasym.adb<g-trasym-bsd.adb \
+  s-inmaop.adb<s-inmaop-posix.adb \
+  s-intman.adb<s-intman-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
+  s-osinte.adb<s-osinte-dragonfly.adb \
+  s-osinte.ads<s-osinte-dragonfly.ads \
+  s-osprim.adb<s-osprim-posix.adb \
+  s-taprop.adb<s-taprop-posix.adb \
+  s-taspri.ads<s-taspri-posix.ads \
+  s-tpopsp.adb<s-tpopsp-posix.adb \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(X86_64_TARGET_PAIRS) \
+  system.ads<system-dragonfly-x86_64.ads
+
+  GNATLIB_SHARED = gnatlib-shared-dual
+
+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o
+  EXTRA_GNATRTL_TASKING_OBJS=a-exetim.o
+
   EH_MECHANISM=-gcc
   THREADSLIB= -lpthread
   GMEM_LIB = gmemlib
@@ -1258,6 +1342,200 @@
   MISCLIB = -lutil
 endif
 
+
+# OPENBSD i386
+ifeq ($(strip $(filter-out %86 openbsd%,$(arch) $(osys))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-exetim.adb<a-exetim-posix.adb \
+  a-exetim.ads<a-exetim-default.ads \
+  a-intnam.ads<a-intnam-openbsd.ads \
+  g-socthi.adb<g-socthi-bsd.adb \
+  g-trasym.adb<g-trasym-bsd.adb \
+  s-inmaop.adb<s-inmaop-posix.adb \
+  s-intman.adb<s-intman-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
+  s-osinte.adb<s-osinte-openbsd.adb \
+  s-osinte.ads<s-osinte-openbsd.ads \
+  s-osprim.adb<s-osprim-bsd32.adb \
+  s-taprop.adb<s-taprop-posix.adb \
+  s-taspri.ads<s-taspri-posix.ads \
+  s-tpopsp.adb<s-tpopsp-posix.adb \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(X86_TARGET_PAIRS) \
+  system.ads<system-openbsd-x86.ads
+
+  GNATLIB_SHARED = gnatlib-shared-dual
+
+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o
+  EXTRA_GNATRTL_TASKING_OBJS=a-exetim.o
+
+  EH_MECHANISM=
+  THREADSLIB= -lpthread
+  GMEM_LIB =
+  LIBRARY_VERSION := $(LIB_VERSION)
+  MISCLIB = -lutil
+endif
+
+
+# OPENBSD AMD64
+ifeq ($(strip $(filter-out x86_64 openbsd%,$(arch) $(osys))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-exetim.adb<a-exetim-posix.adb \
+  a-exetim.ads<a-exetim-default.ads \
+  a-intnam.ads<a-intnam-openbsd.ads \
+  g-socthi.adb<g-socthi-bsd.adb \
+  g-trasym.adb<g-trasym-bsd.adb \
+  s-inmaop.adb<s-inmaop-posix.adb \
+  s-intman.adb<s-intman-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
+  s-osinte.adb<s-osinte-openbsd.adb \
+  s-osinte.ads<s-osinte-openbsd.ads \
+  s-osprim.adb<s-osprim-bsd32.adb \
+  s-taprop.adb<s-taprop-posix.adb \
+  s-taspri.ads<s-taspri-posix.ads \
+  s-tpopsp.adb<s-tpopsp-posix.adb \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(X86_64_TARGET_PAIRS) \
+  system.ads<system-openbsd-x86_64.ads
+
+  GNATLIB_SHARED = gnatlib-shared-dual
+
+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o
+  EXTRA_GNATRTL_TASKING_OBJS=a-exetim.o
+
+  EH_MECHANISM=-gcc
+  THREADSLIB= -lpthread
+  GMEM_LIB = gmemlib
+  LIBRARY_VERSION := $(LIB_VERSION)
+  MISCLIB = -lutil
+endif
+
+
+# NETBSD i386 (5+ only)
+ifeq ($(strip $(filter-out %86 netbsd%,$(arch) $(osys))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-exetim.adb<a-exetim-posix.adb \
+  a-exetim.ads<a-exetim-default.ads \
+  a-intnam.ads<a-intnam-netbsd.ads \
+  g-socthi.adb<g-socthi-netbsd.adb \
+  g-trasym.adb<g-trasym-bsd.adb \
+  s-inmaop.adb<s-inmaop-posix.adb \
+  s-intman.adb<s-intman-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
+  s-osinte.adb<s-osinte-netbsd.adb \
+  s-taprop.adb<s-taprop-posix.adb \
+  s-taspri.ads<s-taspri-posix.ads \
+  s-tpopsp.adb<s-tpopsp-posix.adb \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(X86_TARGET_PAIRS) \
+  system.ads<system-netbsd-x86.ads
+
+  ifeq ($(strip $(filter-out %86 netbsdelf5%,$(arch) $(osys))),)
+    LIBGNAT_TARGET_PAIRS+= \
+    s-osinte.ads<s-osinte-netbsd.ads \
+    s-osprim.adb<s-osprim-bsd32.adb
+  else
+    LIBGNAT_TARGET_PAIRS+= \
+    g-socthi.ads<g-socthi-netbsd6.ads \
+    s-osinte.ads<s-osinte-netbsd6.ads \
+    s-osprim.adb<s-osprim-bsdn6.adb
+  endif
+
+  GNATLIB_SHARED = gnatlib-shared-dual
+
+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o
+  EXTRA_GNATRTL_TASKING_OBJS=a-exetim.o
+
+  EH_MECHANISM=-gcc
+  THREADSLIB= -lpthread
+  GMEM_LIB = gmemlib
+  LIBRARY_VERSION := $(LIB_VERSION)
+  MISCLIB = -lutil
+endif
+
+
+# NETBSD AMD64 (5+ only)
+ifeq ($(strip $(filter-out x86_64 netbsd%,$(arch) $(osys))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-exetim.adb<a-exetim-posix.adb \
+  a-exetim.ads<a-exetim-default.ads \
+  a-intnam.ads<a-intnam-netbsd.ads \
+  g-socthi.adb<g-socthi-netbsd.adb \
+  g-trasym.adb<g-trasym-bsd.adb \
+  s-inmaop.adb<s-inmaop-posix.adb \
+  s-intman.adb<s-intman-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
+  s-osinte.adb<s-osinte-netbsd.adb \
+  s-taprop.adb<s-taprop-posix.adb \
+  s-taspri.ads<s-taspri-posix.ads \
+  s-tpopsp.adb<s-tpopsp-posix.adb \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(X86_64_TARGET_PAIRS) \
+  system.ads<system-netbsd-x86_64.ads
+
+  ifeq ($(strip $(filter-out x86_64 netbsd5%,$(arch) $(osys))),)
+    LIBGNAT_TARGET_PAIRS+= \
+    s-osinte.ads<s-osinte-netbsd.ads \
+    s-osprim.adb<s-osprim-bsd32.adb
+  else
+    LIBGNAT_TARGET_PAIRS+= \
+    g-socthi.ads<g-socthi-netbsd6.ads \
+    s-osinte.ads<s-osinte-netbsd6.ads \
+    s-osprim.adb<s-osprim-bsdn6.adb
+  endif
+
+  GNATLIB_SHARED = gnatlib-shared-dual
+
+  EXTRA_GNATRTL_NONTASKING_OBJS=g-sse.o g-ssvety.o
+  EXTRA_GNATRTL_TASKING_OBJS=a-exetim.o
+
+  EH_MECHANISM=-gcc
+  THREADSLIB= -lpthread
+  GMEM_LIB = gmemlib
+  LIBRARY_VERSION := $(LIB_VERSION)
+  MISCLIB = -lutil
+endif
+
+
+# ANDROID (ARM)
+ifeq ($(strip $(filter-out arm% android eabi,$(targ))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-intnam.ads<a-intnam-linux.ads \
+  g-trasym.ads<g-trasym-unimplemented.ads \
+  g-trasym.adb<g-trasym-unimplemented.adb \
+  s-inmaop.adb<s-inmaop-posix.adb \
+  s-intman.adb<s-intman-posix.adb \
+  s-linux.ads<s-linux.ads \
+  s-osinte.adb<s-osinte-posix.adb \
+  s-mudido.adb<s-mudido-affinity.adb \
+  s-osinte.ads<s-osinte-android.ads \
+  s-osprim.adb<s-osprim-posix.adb \
+  s-taprop.adb<s-taprop-linux.adb \
+  s-tasinf.ads<s-tasinf-linux.ads \
+  s-tasinf.adb<s-tasinf-linux.adb \
+  s-taspri.ads<s-taspri-posix-noaltstack.ads \
+  s-tpopsp.adb<s-tpopsp-posix-foreign.adb
+
+  ifeq ($(strip $(filter-out arm%b,$(arch))),)
+    LIBGNAT_TARGET_PAIRS += \
+    system.ads<system-linux-armeb.ads
+  else
+    LIBGNAT_TARGET_PAIRS += \
+    system.ads<system-linux-armel.ads
+  endif
+
+  EXTRA_LIBGNAT_SRCS+=		signal_android.c
+  EXTRA_LIBGNAT_OBJS+=		signal_android.o
+  EXTRA_GNATRTL_TASKING_OBJS=	s-linux.o
+  EH_MECHANISM=
+  THREADSLIB=
+  MISCLIB=
+  GNATLIB_SHARED=		gnatlib-shared-dual
+  GMEM_LIB=			gmemlib
+  LIBRARY_VERSION:=		$(LIB_VERSION)
+endif
+
+
 ifeq ($(strip $(filter-out s390% linux%,$(arch) $(osys))),)
   LIBGNAT_TARGET_PAIRS_COMMON = \
   a-intnam.ads<a-intnam-linux.ads \
@@ -2597,7 +2875,7 @@
 	$(MAKE) $(FLAGS_TO_PASS) \
              GNATLIBFLAGS="$(GNATLIBFLAGS)" \
 	     GNATLIBCFLAGS="$(GNATLIBCFLAGS) $(PICFLAG_FOR_TARGET)" \
-	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C)" \
+	     GNATLIBCFLAGS_FOR_C="$(GNATLIBCFLAGS_FOR_C) $(PICFLAG_FOR_TARGET)" \
 	     MULTISUBDIR="$(MULTISUBDIR)" \
 	     THREAD_KIND="$(THREAD_KIND)" \
              gnatlib
--- gnattools/configure.orig
+++ gnattools/configure
@@ -2058,7 +2058,27 @@
   s390*-*-linux*)
     TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb"
     ;;
-  *86-*-freebsd*)
+  *86-*-freebsd* | x86_64-*-freebsd*)
+    TOOLS_TARGET_PAIRS="\
+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+    indepsw.adb<indepsw-gnu.adb"
+    ;;
+  *86-*-dragonfly* | x86_64-*-dragonfly*)
+    TOOLS_TARGET_PAIRS="\
+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+    indepsw.adb<indepsw-gnu.adb"
+    ;;
+  *86-*-openbsd* | x86_64-*-openbsd*)
+    TOOLS_TARGET_PAIRS="\
+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+    indepsw.adb<indepsw-gnu.adb"
+    ;;
+  *86-*-netbsdelf* | x86_64-*-netbsd*)
+    TOOLS_TARGET_PAIRS="\
+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+    indepsw.adb<indepsw-gnu.adb"
+    ;;
+  arm*-android-eabi)
     TOOLS_TARGET_PAIRS="\
     mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
     indepsw.adb<indepsw-gnu.adb"
--- gnattools/configure.ac.orig
+++ gnattools/configure.ac
@@ -98,11 +98,31 @@
   s390*-*-linux*)
     TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb"
     ;;
-  *86-*-freebsd*)
+  *86-*-freebsd* | x86_64-*-freebsd*)
     TOOLS_TARGET_PAIRS="\
     mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
     indepsw.adb<indepsw-gnu.adb"
     ;;
+  *86-*-dragonfly* | x86_64-*-dragonfly*)
+    TOOLS_TARGET_PAIRS="\
+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+    indepsw.adb<indepsw-gnu.adb"
+    ;;
+  *86-*-openbsd* | x86_64-*-openbsd*)
+    TOOLS_TARGET_PAIRS="\
+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+    indepsw.adb<indepsw-gnu.adb"
+    ;;
+  *86-*-netbsdelf* | x86_64-*-netbsd*)
+    TOOLS_TARGET_PAIRS="\
+    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+    indepsw.adb<indepsw-gnu.adb"
+    ;;
+  arm*-android-eabi)
+     TOOLS_TARGET_PAIRS="\
+     mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
+     indepsw.adb<indepsw-gnu.adb"
+    ;;
   mips-sgi-irix*)
     TOOLS_TARGET_PAIRS="mlib-tgt-specific.adb<mlib-tgt-specific-irix.adb"
     ;;
--- gcc/ada/gcc-interface/Make-lang.in.orig
+++ gcc/ada/gcc-interface/Make-lang.in
@@ -541,7 +541,7 @@
  ada/widechar.o
 
 # Language-independent object files.
-ADA_BACKEND = $(BACKEND) attribs.o
+ADA_BACKEND = $(BACKEND2) attribs.o
 
 # List of target dependent sources, overridden below as necessary
 TARGET_ADA_SRCS =
