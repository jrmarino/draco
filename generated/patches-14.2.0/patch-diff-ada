--- gcc/ada/adaint.c.orig
+++ gcc/ada/adaint.c
@@ -846,6 +846,7 @@
 }
 
 #if defined (_WIN32) || defined (__linux__) || defined (__sun__) \
+  || defined (__NetBSD__) \
   || defined (__FreeBSD__) || defined(__DragonFly__) || defined (__QNX__)
 #define HAS_TARGET_WCHAR_T
 #endif
@@ -1256,6 +1257,47 @@
     free (pname);
   }
 
+#elif defined (__ANDROID__)
+
+  /*
+   * ext2 /ext3/ext4/fat16/fat32 have no path limits
+   * /data/local/tmp normally requires rooted devices, if it even exists
+   * /sdcard is the standard location for external storage.  Nativeactivity
+   * manifest needs to authorize its use, otherwise it might not have the
+   * proper permissions.
+   */
+
+  int testfd;
+  char *datadir = getenv ("ANDROID_DATA");
+
+  if (datadir == NULL)
+    strncpy (tmp_filename, "/data/local/tmp/gnat-XXXXXX", L_tmpnam);
+  else
+    snprintf (tmp_filename, L_tmpnam, "%s/local/tmp/gnat-XXXXXX", datadir);
+
+  testfd = mkstemp (tmp_filename);
+  if (testfd != -1)
+    {
+      close (testfd);
+      return;
+    }
+
+  char *sdcard = getenv ("EXTERNAL_STORAGE");
+
+  if (sdcard == NULL)
+    strncpy (tmp_filename, "/sdcard/gnat-XXXXXX", L_tmpnam);
+  else
+    snprintf (tmp_filename, L_tmpnam, "%s/gnat-XXXXXX", sdcard);
+
+  testfd = mkstemp (tmp_filename);
+  if (testfd != -1)
+    {
+      close (testfd);
+      return;
+    }
+
+  tmpnam (tmp_filename);
+
 #elif defined (__linux__) || defined (__FreeBSD__) || defined (__NetBSD__) \
   || defined (__OpenBSD__) || defined (__GLIBC__) || defined (__ANDROID__) \
   || defined (__DragonFly__) || defined (__QNX__)
@@ -3703,6 +3745,68 @@
   */
 }
 
+#if defined(__NetBSD__)
+/* It's 2021, and NetBSD still doesn't use symbol versioning in their
+ * libraries.  They mimic this by having header macros rename the function
+ * at compile time.  If we don't wrap the functions, the osinte specification
+ * for NetBSD would need to import e.g. __sigaltstack14 instead of sigaltstack.
+ * By wrapping, new versions won't break gnat.
+ */
+int
+__gnat_sigemptyset (sigset_t *set) {
+   return sigemptyset (set);
+}
+int
+__gnat_sigfillset (sigset_t *set) {
+   return sigfillset (set);
+}
+int
+__gnat_sigaddset (sigset_t *set, int signo) {
+   return sigaddset (set, signo);
+}
+int
+__gnat_sigdelset (sigset_t *set, int signo) {
+   return sigdelset (set, signo);
+}
+int
+__gnat_sigismember (sigset_t *set, int signo) {
+   return sigismember (set, signo);
+}
+int
+__gnat_sigaltstack (const stack_t *ss, stack_t *oss) {
+   return sigaltstack (ss, oss);
+}
+int
+__gnat_sigaction (int sig, const struct sigaction *act, struct sigaction *oact) {
+   return sigaction (sig, act, oact);
+}
+int
+__gnat_clock_getres (clockid_t clock_id, struct timespec *res) {
+   return clock_getres (clock_id, res);
+}
+int
+__gnat_clock_gettime (clockid_t clock_id, struct timespec *tp) {
+   return clock_gettime (clock_id, tp);
+}
+#endif
+int
+__gnat_nanosleep (const struct timespec *rqtp, struct timespec *rmtp) {
+   return nanosleep (rqtp, rmtp);
+}
+int
+__gnat_gettimeofday (struct timeval * tp, struct timezone * tzp) {
+   return gettimeofday (tp, tzp);
+}
+int
+__gnat_select(int nfds, fd_set * readfds, fd_set * writefds,
+              fd_set * exceptfds, struct timeval * timeout) {
+   return select (nfds, readfds, writefds, exceptfds, timeout);
+}
+int
+__gnat_socket (int domain, int type, int protocol) {
+   return socket (domain, type, protocol);
+}
+
 #ifdef __cplusplus
 }
 #endif
--- gcc/ada/adaint.h.orig
+++ gcc/ada/adaint.h
@@ -348,6 +348,29 @@
 
 extern const void * __gnat_get_executable_load_address  (void);
 
+#if defined(__NetBSD__)
+#include <signal.h>
+extern int    __gnat_sigemptyset (sigset_t *);
+extern int    __gnat_sigfillset  (sigset_t *);
+extern int    __gnat_sigaddset   (sigset_t *, int);
+extern int    __gnat_sigdelset   (sigset_t *, int);
+extern int    __gnat_sigismember (sigset_t *, int);
+extern int    __gnat_sigaltstack (const stack_t *, stack_t *);
+extern int    __gnat_sigaction   (int, const struct sigaction *, struct sigaction *);
+#endif
+#include <time.h>
+#include <sys/time.h>
+extern int    __gnat_nanosleep     (const struct timespec *, struct timespec *);
+extern int    __gnat_gettimeofday  (struct timeval *, struct timezone *);
+#include <sys/select.h>
+extern int    __gnat_select        (int, fd_set *, fd_set *, fd_set *, struct timeval *);
+#include <sys/socket.h>
+extern int    __gnat_socket        (int, int, int);
+#if defined(__NetBSD__)
+extern int    __gnat_clock_getres  (clockid_t, struct timespec *);
+extern int    __gnat_clock_gettime (clockid_t, struct timespec *);
+#endif
+
 #ifdef __cplusplus
 }
 #endif
--- gcc/ada/gnatls.adb.orig
+++ gcc/ada/gnatls.adb
@@ -32,7 +32,6 @@
 with Csets;
 with Fname;       use Fname;
 with Gnatvsn;     use Gnatvsn;
-with Make_Util;   use Make_Util;
 with Namet;       use Namet;
 with Opt;         use Opt;
 with Osint;       use Osint;
@@ -1277,31 +1276,10 @@
          --  The path name(s) of directories where project files may reside.
          --  May be empty.
 
-         Prefix  : String_Ptr;
-         Runtime : String_Ptr;
-
-         procedure Add_Target (Suffix : String);
-         --  Add :<prefix>/<target>/Suffix to the project path
-
          FD  : File_Descriptor;
          Len : Integer;
 
-         ----------------
-         -- Add_Target --
-         ----------------
-
-         procedure Add_Target (Suffix : String) is
-            Extra_Sep : constant String :=
-               (if Target_Name (Target_Name'Last) = '/' then
-                  ""
-                else
-                  (1 => Directory_Separator));
-            --  Note: Target_Name has a trailing / when it comes from Sdefault
-
-         begin
-            Add_Str_To_Name_Buffer
-              (Path_Separator & Prefix.all & Target_Name & Extra_Sep & Suffix);
-         end Add_Target;
+         pragma Unreferenced (Runtime_Name);
 
       --  Start of processing for Initialize_Default_Project_Path
 
@@ -1481,81 +1459,14 @@
          --  Set the initial value of Current_Project_Path
 
          if Add_Default_Dir then
-            if Sdefault.Search_Dir_Prefix = null then
-
-               --  gprbuild case
-
-               Prefix := new String'(Executable_Prefix_Path);
-
-            else
-               Prefix := new String'(Sdefault.Search_Dir_Prefix.all
-                                     & ".." & Dir_Separator
-                                     & ".." & Dir_Separator
-                                     & ".." & Dir_Separator
-                                     & ".." & Dir_Separator);
-            end if;
-
-            if Prefix.all /= "" then
-               if Target_Name /= "" then
-
-                  if Runtime_Name /= "" then
-                     if Base_Name (Runtime_Name) = Runtime_Name then
-
-                        --  $prefix/$target/$runtime/lib/gnat
-
-                        Add_Target
-                          (Runtime_Name & Directory_Separator &
-                           "lib" & Directory_Separator & "gnat");
-
-                        --  $prefix/$target/$runtime/share/gpr
-
-                        Add_Target
-                          (Runtime_Name & Directory_Separator &
-                             "share" & Directory_Separator & "gpr");
-
-                     else
-                        Runtime :=
-                          new String'(Normalize_Pathname (Runtime_Name));
-
-                        --  $runtime_dir/lib/gnat
-
-                        Add_Str_To_Name_Buffer
-                          (Path_Separator & Runtime.all & Directory_Separator &
-                           "lib" & Directory_Separator & "gnat");
-
-                        --  $runtime_dir/share/gpr
-
-                        Add_Str_To_Name_Buffer
-                          (Path_Separator & Runtime.all & Directory_Separator &
-                           "share" & Directory_Separator & "gpr");
-                     end if;
-                  end if;
-
-                  --  $prefix/$target/lib/gnat
-
-                  Add_Target
-                    ("lib" & Directory_Separator & "gnat");
-
-                  --  $prefix/$target/share/gpr
-
-                  Add_Target
-                    ("share" & Directory_Separator & "gpr");
-               end if;
-
-               --  $prefix/share/gpr
-
-               Add_Str_To_Name_Buffer
-                 (Path_Separator & Prefix.all & "share"
-                  & Directory_Separator & "gpr");
-
-               --  $prefix/lib/gnat
-
-               Add_Str_To_Name_Buffer
-                 (Path_Separator & Prefix.all & "lib"
-                  & Directory_Separator & "gnat");
-            end if;
+            --  /raven/share/gpr
+            Add_Str_To_Name_Buffer (Path_Separator &
+              "@LOCALBASE@/share/gpr");
+
+            --  /raven/lib/gnat
+            Add_Str_To_Name_Buffer (Path_Separator &
+              "@LOCALBASE@/lib/gnat");
 
-            Free (Prefix);
          end if;
 
          Self := new String'(Name_Buffer (1 .. Name_Len));
--- gcc/ada/Makefile.rtl.orig
+++ gcc/ada/Makefile.rtl
@@ -1386,6 +1386,7 @@
   s-linux.ads<libgnarl/s-linux__android.ads \
   s-osinte.adb<libgnarl/s-osinte__android.adb \
   s-osinte.ads<libgnarl/s-osinte__android.ads \
+  g-socthi.adb<libgnat/g-socthi__bsd.adb \
   s-osprim.adb<libgnat/s-osprim__posix.adb \
   s-taprop.adb<libgnarl/s-taprop__posix.adb \
   s-taspri.ads<libgnarl/s-taspri__posix.ads \
@@ -1462,6 +1463,7 @@
   s-osinte.adb<libgnarl/s-osinte__solaris.adb \
   s-osinte.ads<libgnarl/s-osinte__solaris.ads \
   s-osprim.adb<libgnat/s-osprim__solaris.adb \
+  s-trasym.adb<libgnat/s-trasym__bsd.adb \
   s-taprop.adb<libgnarl/s-taprop__solaris.adb \
   s-tasinf.adb<libgnarl/s-tasinf__solaris.adb \
   s-tasinf.ads<libgnarl/s-tasinf__solaris.ads \
@@ -1541,6 +1543,8 @@
   EXTRA_GNATRTL_NONTASKING_OBJS += $(TRASYM_DWARF_UNIX_OBJS)
 
   EH_MECHANISM=-gcc
+  EXTRA_LIBGNAT_SRCS+= traceback_symbolic.c
+  EXTRA_LIBGNAT_OBJS+= traceback_symbolic.o
   MISCLIB = -lnsl -lsocket
   SO_OPTS = -Wl,-h,
   GNATLIB_SHARED = gnatlib-shared-dual
@@ -1683,6 +1687,34 @@
   LIBRARY_VERSION := $(LIB_VERSION)
 endif
 
+# x86 android
+ifeq ($(strip $(filter-out %86 linux-android,$(target_cpu) $(target_os))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-intnam.ads<libgnarl/a-intnam__linux.ads \
+  s-inmaop.adb<libgnarl/s-inmaop__posix.adb \
+  s-intman.adb<libgnarl/s-intman__posix.adb \
+  s-linux.ads<libgnarl/s-linux__android.ads \
+  s-osinte.adb<libgnarl/s-osinte__android.adb \
+  s-osinte.ads<libgnarl/s-osinte__android.ads \
+  g-socthi.adb<libgnat/g-socthi__bsd.adb \
+  s-osprim.adb<libgnat/s-osprim__posix.adb \
+  s-taprop.adb<libgnarl/s-taprop__posix.adb \
+  s-taspri.ads<libgnarl/s-taspri__posix.ads \
+  s-tpopsp.adb<libgnarl/s-tpopsp__posix-foreign.adb \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(ATOMICS_BUILTINS_TARGET_PAIRS) \
+  system.ads<libgnat/system-linux-x86.ads
+
+  TOOLS_TARGET_PAIRS = indepsw.adb<indepsw-gnu.adb
+
+  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o
+  EH_MECHANISM=-gcc
+  THREADSLIB =
+  MISCLIB =
+  GNATLIB_SHARED = gnatlib-shared-dual
+  LIBRARY_VERSION := $(LIB_VERSION)
+endif
+
 # aarch64 FreeBSD
 ifeq ($(strip $(filter-out %aarch64 freebsd%,$(target_cpu) $(target_os))),)
   LIBGNAT_TARGET_PAIRS = \
@@ -1694,7 +1726,9 @@
   s-mudido.adb<libgnarl/s-mudido__affinity.adb \
   s-osinte.adb<libgnarl/s-osinte__freebsd.adb \
   s-osinte.ads<libgnarl/s-osinte__freebsd.ads \
+  g-socthi.adb<libgnat/g-socthi__bsd.adb \
   s-osprim.adb<libgnat/s-osprim__posix.adb \
+  s-trasym.adb<libgnat/s-trasym__bsd.adb \
   s-taprop.adb<libgnarl/s-taprop__posix.adb \
   s-taspri.ads<libgnarl/s-taspri__posix.ads \
   s-tpopsp.adb<libgnarl/s-tpopsp__posix.adb \
@@ -1707,6 +1741,9 @@
 
   GNATLIB_SHARED = gnatlib-shared-dual
 
+  EXTRA_LIBGNAT_SRCS+= traceback_symbolic.c
+  EXTRA_LIBGNAT_OBJS+= traceback_symbolic.o
+
   EH_MECHANISM=-gcc
   THREADSLIB= -lpthread
   GMEM_LIB = gmemlib
@@ -1723,7 +1760,9 @@
   s-mudido.adb<libgnarl/s-mudido__affinity.adb \
   s-osinte.adb<libgnarl/s-osinte__freebsd.adb \
   s-osinte.ads<libgnarl/s-osinte__freebsd.ads \
+  g-socthi.adb<libgnat/g-socthi__bsd.adb \
   s-osprim.adb<libgnat/s-osprim__posix.adb \
+  s-trasym.adb<libgnat/s-trasym__bsd.adb \
   s-taprop.adb<libgnarl/s-taprop__posix.adb \
   s-taspri.ads<libgnarl/s-taspri__posix.ads \
   s-tpopsp.adb<libgnarl/s-tpopsp__posix.adb \
@@ -1737,6 +1776,9 @@
   EXTRA_GNATRTL_NONTASKING_OBJS += g-sse.o g-ssvety.o
   EXTRA_GNATRTL_NONTASKING_OBJS += $(TRASYM_DWARF_UNIX_OBJS)
 
+  EXTRA_LIBGNAT_SRCS+= traceback_symbolic.c
+  EXTRA_LIBGNAT_OBJS+= traceback_symbolic.o
+
   EH_MECHANISM=-gcc
   THREADSLIB= -lpthread
   GMEM_LIB = gmemlib
@@ -1753,7 +1795,9 @@
   s-mudido.adb<libgnarl/s-mudido__affinity.adb \
   s-osinte.adb<libgnarl/s-osinte__freebsd.adb \
   s-osinte.ads<libgnarl/s-osinte__freebsd.ads \
+  g-socthi.adb<libgnat/g-socthi__bsd.adb \
   s-osprim.adb<libgnat/s-osprim__posix.adb \
+  s-trasym.adb<libgnat/s-trasym__bsd.adb \
   s-taprop.adb<libgnarl/s-taprop__posix.adb \
   s-taspri.ads<libgnarl/s-taspri__posix.ads \
   s-tpopsp.adb<libgnarl/s-tpopsp__posix.adb \
@@ -1769,6 +1813,9 @@
   EXTRA_GNATRTL_NONTASKING_OBJS += $(TRASYM_DWARF_UNIX_OBJS)
   EXTRA_GNATRTL_NONTASKING_OBJS += $(GNATRTL_128BIT_OBJS)
 
+  EXTRA_LIBGNAT_SRCS+= traceback_symbolic.c
+  EXTRA_LIBGNAT_OBJS+= traceback_symbolic.o
+
   EH_MECHANISM=-gcc
   THREADSLIB= -lpthread
   GMEM_LIB = gmemlib
@@ -1785,10 +1832,13 @@
   s-mudido.adb<libgnarl/s-mudido__affinity.adb \
   s-osinte.adb<libgnarl/s-osinte__dragonfly.adb \
   s-osinte.ads<libgnarl/s-osinte__dragonfly.ads \
+  g-socthi.adb<libgnat/g-socthi__bsd.adb \
   s-osprim.adb<libgnat/s-osprim__posix.adb \
+  s-trasym.adb<libgnat/s-trasym__bsd.adb \
   s-taprop.adb<libgnarl/s-taprop__posix.adb \
   s-taspri.ads<libgnarl/s-taspri__posix.ads \
   s-tpopsp.adb<libgnarl/s-tpopsp__posix.adb \
+  $(TRASYM_DWARF_UNIX_PAIRS) \
   $(ATOMICS_TARGET_PAIRS) \
   $(X86_64_TARGET_PAIRS) \
   $(GNATRTL_128BIT_PAIRS) \
@@ -1797,13 +1847,54 @@
   GNATLIB_SHARED = gnatlib-shared-dual
 
   EXTRA_GNATRTL_NONTASKING_OBJS += g-sse.o g-ssvety.o
+  EXTRA_GNATRTL_NONTASKING_OBJS += $(TRASYM_DWARF_UNIX_OBJS)
   EXTRA_GNATRTL_NONTASKING_OBJS += $(GNATRTL_128BIT_OBJS)
 
+  EXTRA_LIBGNAT_SRCS+= traceback_symbolic.c
+  EXTRA_LIBGNAT_OBJS+= traceback_symbolic.o
+
   EH_MECHANISM=-gcc
   THREADSLIB= -lpthread
   GMEM_LIB = gmemlib
   LIBRARY_VERSION := $(LIB_VERSION)
   MISCLIB = -lutil
+endif
+
+# x86-64 NetBSD
+ifeq ($(strip $(filter-out %86_64 netbsd%,$(target_cpu) $(target_os))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-intnam.ads<libgnarl/a-intnam__dragonfly.ads \
+  s-inmaop.adb<libgnarl/s-inmaop__posix.adb \
+  s-intman.adb<libgnarl/s-intman__posix.adb \
+  s-mudido.adb<libgnarl/s-mudido__affinity.adb \
+  s-osinte.adb<libgnarl/s-osinte__netbsd.adb \
+  s-osinte.ads<libgnarl/s-osinte__netbsd.ads \
+  g-socthi.adb<libgnat/g-socthi__bsd.adb \
+  s-osprim.adb<libgnat/s-osprim__posix.adb \
+  s-trasym.adb<libgnat/s-trasym__bsd.adb \
+  s-taprop.adb<libgnarl/s-taprop__posix.adb \
+  s-taspri.ads<libgnarl/s-taspri__posix.ads \
+  s-tpopsp.adb<libgnarl/s-tpopsp__posix.adb \
+  $(TRASYM_DWARF_UNIX_PAIRS) \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(X86_64_TARGET_PAIRS) \
+  $(GNATRTL_128BIT_PAIRS) \
+  system.ads<libgnat/system-dragonfly-x86_64.ads
+
+  GNATLIB_SHARED = gnatlib-shared-dual
+
+  EXTRA_GNATRTL_NONTASKING_OBJS += g-sse.o g-ssvety.o
+  EXTRA_GNATRTL_NONTASKING_OBJS += $(TRASYM_DWARF_UNIX_OBJS)
+  EXTRA_GNATRTL_NONTASKING_OBJS += $(GNATRTL_128BIT_OBJS)
+
+  EXTRA_LIBGNAT_SRCS+= traceback_symbolic.c
+  EXTRA_LIBGNAT_OBJS+= traceback_symbolic.o
+
+  EH_MECHANISM=-gcc
+  THREADSLIB= -lpthread -lrt
+  GMEM_LIB = gmemlib
+  LIBRARY_VERSION := $(LIB_VERSION)
+  MISCLIB = -lutil
 endif
 
 # S390 Linux
--- gcc/ada/terminals.c.orig
+++ gcc/ada/terminals.c
@@ -34,7 +34,7 @@
 /* First all unsupported platforms. Add stubs for exported routines. */
 
 #if defined (VMS) || defined (__vxworks) || defined (__Lynx__) \
-  || defined (__ANDROID__) || defined (__PikeOS__) || defined(__DJGPP__)
+  || defined (__PikeOS__) || defined(__DJGPP__)
 
 void *
 __gnat_new_tty (void)
@@ -1096,7 +1096,7 @@
  || defined (__OpenBSD__) \
  || defined (__NetBSD__)  \
  || defined (__DragonFly__)
-#   define BSD
+#   define FREEBSD
 #endif
 
 /* Include every system header we need */
@@ -1113,10 +1113,10 @@
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <unistd.h>
-#if defined (__sun__)
+#if defined (sun)
 #   include <sys/stropts.h>
 #endif
-#if defined (BSD) || defined (__sun__)
+#if defined (FREEBSD) || defined (sun)
 #   include <sys/signal.h>
 #endif
 #if defined (__hpux__)
@@ -1129,7 +1129,11 @@
 #   include <libutil.h>
 #endif
 
+#ifdef __ANDROID__
+#define CDISABLE _PC_VDISABLE
+#else
 #define CDISABLE _POSIX_VDISABLE
+#endif
 
 /* POSIX does not specify how to open the master side of a terminal.Several
    methods are available (system specific):
@@ -1145,11 +1149,11 @@
 */
 
 /* Configurable part */
-#if defined (__APPLE__) || defined (BSD)
+#if defined (__APPLE__) || defined (FREEBSD)
 #define USE_OPENPTY
-#elif defined (__linux__)
+#elif defined (linux)
 #define USE_GETPT
-#elif defined (__sun__)
+#elif defined (sun)
 #define USE_CLONE_DEVICE "/dev/ptmx"
 #elif defined (_AIX)
 #define USE_CLONE_DEVICE "/dev/ptc"
@@ -1444,7 +1448,7 @@
     desc->slave_fd = open (desc->slave_name, O_RDWR, 0);
 #endif
 
-#if defined (__sun__) || defined (__hpux__)
+#if defined (sun) || defined (__hpux__)
   /* On systems such as Solaris we are using stream. We need to push the right
      "modules" in order to get the expected terminal behaviors. Otherwise
      functionalities such as termios are not available.  */
--- /dev/null
+++ gcc/ada/traceback_symbolic.c
@@ -0,0 +1,201 @@
+/*
+  Copyright (C) 1999 by Juergen Pfeifer <juergen.pfeifer@gmx.net>
+  Ada for Linux Team (ALT)
+  Heavily modified by John Marino <http://www.dragonlace.net>
+
+  Permission is hereby granted, free of charge, to any person obtaining a
+  copy of this software and associated documentation files (the
+  "Software"), to deal in the Software without restriction, including
+  without limitation the rights to use, copy, modify, merge, publish,
+  distribute, distribute with modifications, sublicense, and/or sell
+  copies of the Software, and to permit persons to whom the Software is
+  furnished to do so, subject to the following conditions:
+
+  The above copyright notice and this permission notice shall be included
+  in all copies or substantial portions of the Software.
+
+  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+  IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+  OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+  THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+  Except as contained in this notice, the name(s) of the above copyright
+  holders shall not be used in advertising or otherwise to promote the
+  sale, use or other dealings in this Software without prior written
+  authorization.
+*/
+
+#ifdef IS_CROSS
+
+
+/*
+ * Running addr2line doesn't make sense for cross-compiled objects.
+ * Create a dummy function to satisfy g-trasym.o
+ */
+
+void
+convert_addresses (const char *file_name ATTRIBUTE_UNUSED,
+                   void *addrs ATTRIBUTE_UNUSED,
+                   int n_addr ATTRIBUTE_UNUSED,
+                   void *buf ATTRIBUTE_UNUSED,
+                   int *len ATTRIBUTE_UNUSED)
+{
+  *len = 0;
+}
+
+#else
+
+
+/*
+ * use the external program /usr/bin/addr2line to convert addresses
+ * into file names and line numbers
+ */
+
+#include <sys/types.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <signal.h>
+
+#define CLOSE_SENDPIPE close(sendpipe[0]); close(sendpipe[1])
+#define CLOSE_READPIPE close(readpipe[0]); close(readpipe[1])
+#define DUP2CLOSE(oldfd, newfd) dup2(oldfd, newfd); close(oldfd);
+#define RESTSIG sigaction(SIGPIPE,&oact,NULL)
+
+#define MAX_LINE     1024
+#define PARENT_READ  readpipe[0]
+#define CHILD_WRITE  readpipe[1]
+#define CHILD_READ   sendpipe[0]
+#define PARENT_WRITE sendpipe[1]
+
+#if defined (__sun__)
+#define ADDR2LINE_PROG        "/usr/gnu/bin/addr2line"
+#else
+#define ADDR2LINE_PROG        "/usr/bin/addr2line"
+#endif
+
+void
+convert_addresses (const char *file_name,
+                   void *addrs,
+                   int   n_addr,
+                   void *buf,
+                   int  *len)
+{
+  int max_len = *len;
+  pid_t childpid;
+
+  struct sigaction act, oact;
+
+  int sendpipe[2] = {-1,-1},        /* parent -> child */
+      readpipe[2] = {-1,-1};        /* parent <- child */
+
+  *len = 0;
+  act.sa_handler = SIG_IGN;
+  sigemptyset(&act.sa_mask);
+  act.sa_flags = 0;
+  if (sigaction(SIGPIPE,&act,&oact) < 0)
+    return;
+
+  if (pipe(sendpipe) < 0) { RESTSIG; return; }
+  if (pipe(readpipe) < 0) { CLOSE_SENDPIPE; RESTSIG; return; }
+  if ((childpid = fork()) < 0) {
+    CLOSE_READPIPE;
+    CLOSE_SENDPIPE;
+    RESTSIG;
+    return;
+  }
+
+  if (childpid == 0) {    /* child process */
+    close(PARENT_WRITE);
+    close(PARENT_READ);
+    if ((CHILD_READ != STDIN_FILENO) && (CHILD_WRITE != STDOUT_FILENO)) {
+      if ((CHILD_READ == STDOUT_FILENO) && (CHILD_WRITE == STDIN_FILENO)) {
+        const int temp_fd = dup(CHILD_WRITE);
+        close (CHILD_WRITE);
+        DUP2CLOSE (CHILD_READ, STDIN_FILENO);
+        DUP2CLOSE (temp_fd,    STDOUT_FILENO);
+      }
+      else if ((CHILD_READ == STDIN_FILENO) && (CHILD_WRITE > 1)) {
+        DUP2CLOSE (CHILD_WRITE, STDOUT_FILENO);
+      }
+      else if ((CHILD_READ > 1) && (CHILD_WRITE == STDOUT_FILENO)) {
+        DUP2CLOSE (CHILD_READ, STDIN_FILENO);
+      }
+      else if ((CHILD_READ > 1) && (CHILD_WRITE == STDIN_FILENO)) {
+        DUP2CLOSE (CHILD_WRITE, STDOUT_FILENO);
+        DUP2CLOSE (CHILD_READ,  STDIN_FILENO);
+      }
+      else {
+        /* CHILD_READ >= 1 and CHILD_WRITE > 1 */
+        DUP2CLOSE (CHILD_READ,  STDIN_FILENO);
+        DUP2CLOSE (CHILD_WRITE, STDOUT_FILENO);
+      }
+    }
+    /* As pointed out by Florian Weimer to JP, it is a security threat to call
+       the script with a user defined environment and using the path. That
+       would be Trojans pleasure.  Therefore the absolute path to addr2line
+       and an empty environment is used. That should be safe.
+    */
+    char *const argv[] = { "addr2line",
+                           "-e", file_name,
+                           "--demangle=gnat",
+                           "--functions",
+                           "--basenames",
+                           NULL };
+    char *const envp[] = { NULL };
+    if (execve(ADDR2LINE_PROG, argv, envp) < 0) {
+      close (CHILD_WRITE);
+      close (CHILD_READ);
+      RESTSIG;
+      exit (1);
+    }
+  }
+
+  /* Below this line is parent process */
+  int i, n;
+  char hex[16];
+  char line[MAX_LINE + 1];
+  char *p;
+  char *s = buf;
+  long *trace_address = addrs;
+
+  close(CHILD_WRITE);
+  close(CHILD_READ);
+
+  for(i=0; i < n_addr; i++) {
+    snprintf(hex,sizeof(hex),"%#lx\n",*trace_address);
+    write(PARENT_WRITE,hex,strlen(hex));
+    n = read(PARENT_READ,line,MAX_LINE);
+    if (n<=0)
+      break;
+
+    line[n]=0;
+    /* We have approx. 16 additional chars for "%#lx in " clause.
+       We use this info to prevent a buffer overrun. */
+    if (n + 16 + (*len) > max_len)
+      break;
+
+    p = strchr(line,'\n');
+    if (p) {
+      if (*(p+1)) {
+        *p = 0;
+        *len += snprintf(s, (max_len - (*len)), "%#lx in %s at %s",
+                         *trace_address, line, p+1);
+      }
+      else {
+        *len += snprintf(s, (max_len - (*len)), "%#lx at %s",
+                         *trace_address, line);
+      }
+      s = buf + (*len);
+    }
+    trace_address += 1;
+  }
+  close (PARENT_WRITE);
+  close (PARENT_READ);
+  RESTSIG;
+}
+
+#endif
--- /dev/null
+++ gcc/ada/libgnarl/s-osinte__netbsd.adb
@@ -0,0 +1,115 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                   B o d y                                --
+--                                                                          --
+--          Copyright (C) 1991-2020, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University. It is --
+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
+-- State University (http://www.gnat.com).                                  --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the NetBSD version of this package
+
+with Interfaces.C; use Interfaces.C;
+
+package body System.OS_Interface is
+
+   -----------
+   -- Errno --
+   -----------
+
+   function Errno return int is
+      type int_ptr is access all int;
+
+      function internal_errno return int_ptr;
+      pragma Import (C, internal_errno, "__get_errno");
+
+   begin
+      return (internal_errno.all);
+   end Errno;
+
+   --------------------
+   -- Get_Stack_Base --
+   --------------------
+
+   function Get_Stack_Base (thread : pthread_t) return Address is
+      pragma Unreferenced (thread);
+   begin
+      return Null_Address;
+   end Get_Stack_Base;
+
+   ------------------
+   -- pthread_init --
+   ------------------
+
+   procedure pthread_init is
+   begin
+      null;
+   end pthread_init;
+
+   -----------------
+   -- To_Duration --
+   -----------------
+
+   function To_Duration (TS : timespec) return Duration is
+   begin
+      return Duration (TS.ts_sec) + Duration (TS.ts_nsec) / 10#1#E9;
+   end To_Duration;
+
+   ------------------------
+   -- To_Target_Priority --
+   ------------------------
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int
+   is
+   begin
+      return Interfaces.C.int (Prio);
+   end To_Target_Priority;
+
+   -----------------
+   -- To_Timespec --
+   -----------------
+
+   function To_Timespec (D : Duration) return timespec is
+      S : time_t;
+      F : Duration;
+
+   begin
+      S := time_t (Long_Long_Integer (D));
+      F := D - Duration (S);
+
+      --  If F has negative value due to a round-up, adjust for positive F
+
+      if F < 0.0 then
+         S := S - 1;
+         F := F + 1.0;
+      end if;
+
+      return timespec'(ts_sec => S,
+                       ts_nsec => long (Long_Long_Integer (F * 10#1#E9)));
+   end To_Timespec;
+
+end System.OS_Interface;
--- /dev/null
+++ gcc/ada/libgnarl/s-osinte__netbsd.ads
@@ -0,0 +1,684 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                   S p e c                                --
+--                                                                          --
+--             Copyright (C) 1991-2017, Florida State University            --
+--          Copyright (C) 1995-2020, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University. It is --
+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
+-- State University (http://www.gnat.com).                                  --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the NetBSD (POSIX Threads) version of this package
+
+--  This package encapsulates all direct interfaces to OS services
+--  that are needed by the tasking run-time (libgnarl).
+
+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma
+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.
+
+with Ada.Unchecked_Conversion;
+
+with Interfaces.C;
+with System.OS_Constants;
+
+package System.OS_Interface is
+   pragma Preelaborate;
+
+   pragma Linker_Options ("-lrt");
+   pragma Linker_Options ("-pthread");
+
+   subtype int            is Interfaces.C.int;
+   subtype short          is Interfaces.C.short;
+   subtype long           is Interfaces.C.long;
+   subtype unsigned       is Interfaces.C.unsigned;
+   subtype unsigned_short is Interfaces.C.unsigned_short;
+   subtype unsigned_long  is Interfaces.C.unsigned_long;
+   subtype unsigned_char  is Interfaces.C.unsigned_char;
+   subtype plain_char     is Interfaces.C.plain_char;
+   subtype size_t         is Interfaces.C.size_t;
+   subtype char_array     is Interfaces.C.char_array;
+   subtype int64          is Interfaces.Integer_64;
+
+   -----------
+   -- Errno --
+   -----------
+
+   function Errno return int;
+   pragma Inline (Errno);
+
+   EAGAIN    : constant := 35;
+   EINTR     : constant := 4;
+   EINVAL    : constant := 22;
+   ENOMEM    : constant := 12;
+   ETIMEDOUT : constant := 60;
+
+   -------------
+   -- Signals --
+   -------------
+
+   Max_Interrupt : constant := 31;
+   type Signal is new int range 0 .. Max_Interrupt;
+   for Signal'Size use int'Size;
+
+   SIGHUP     : constant := 1; --  hangup
+   SIGINT     : constant := 2; --  interrupt (rubout)
+   SIGQUIT    : constant := 3; --  quit (ASCD FS)
+   SIGILL     : constant := 4; --  illegal instruction (not reset)
+   SIGTRAP    : constant := 5; --  trace trap (not reset)
+   SIGIOT     : constant := 6; --  IOT instruction
+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future
+   SIGEMT     : constant := 7; --  EMT instruction
+   SIGFPE     : constant := 8; --  floating point exception
+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)
+   SIGBUS     : constant := 10; --  bus error
+   SIGSEGV    : constant := 11; --  segmentation violation
+   SIGSYS     : constant := 12; --  bad argument to system call
+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it
+   SIGALRM    : constant := 14; --  alarm clock
+   SIGTERM    : constant := 15; --  software termination signal from kill
+   SIGURG     : constant := 16; --  urgent condition on IO channel
+   SIGSTOP    : constant := 17; --  stop (cannot be caught or ignored)
+   SIGTSTP    : constant := 18; --  user stop requested from tty
+   SIGCONT    : constant := 19; --  stopped process has been continued
+   SIGCLD     : constant := 20; --  alias for SIGCHLD
+   SIGCHLD    : constant := 20; --  child status change
+   SIGTTIN    : constant := 21; --  background tty read attempted
+   SIGTTOU    : constant := 22; --  background tty write attempted
+   SIGIO      : constant := 23; --  I/O possible (Solaris SIGPOLL alias)
+   SIGXCPU    : constant := 24; --  CPU time limit exceeded
+   SIGXFSZ    : constant := 25; --  filesize limit exceeded
+   SIGVTALRM  : constant := 26; --  virtual timer expired
+   SIGPROF    : constant := 27; --  profiling timer expired
+   SIGWINCH   : constant := 28; --  window size change
+   SIGINFO    : constant := 29; --  information request (NetBSD/FreeBSD)
+   SIGUSR1    : constant := 30; --  user defined signal 1
+   SIGUSR2    : constant := 31; --  user defined signal 2
+
+   SIGADAABORT : constant := SIGABRT;
+   --  Change this if you want to use another signal for task abort.
+   --  SIGTERM might be a good one.
+
+   type Signal_Set is array (Natural range <>) of Signal;
+
+   --  Interrupts that must be unmasked at all times.  FreeBSD
+   --  pthreads will not allow an application to mask out any
+   --  interrupt needed by the threads library.
+   Unmasked : constant Signal_Set :=
+     (SIGTRAP, SIGBUS, SIGTTIN, SIGTTOU, SIGTSTP);
+
+   --  FreeBSD will uses SIGPROF for timing.  Do not allow a
+   --  handler to attach to this signal.
+   Reserved : constant Signal_Set := (0 .. 0 => SIGPROF);
+
+   type sigset_t is private;
+
+   function sigaddset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigaddset, "__gnat_sigaddset");
+
+   function sigdelset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigdelset, "__gnat_sigdelset");
+
+   function sigfillset (set : access sigset_t) return int;
+   pragma Import (C, sigfillset, "__gnat_sigfillset");
+
+   function sigismember
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigismember, "__gnat_sigismember");
+
+   function sigemptyset (set : access sigset_t) return int;
+   pragma Import (C, sigemptyset, "__gnat_sigemptyset");
+
+   --  sigcontext is architecture dependent, so define it private
+   type struct_sigcontext is private;
+
+   type old_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_mask    : sigset_t;
+      sa_flags   : int;
+   end record;
+   pragma Convention (C, old_struct_sigaction);
+
+   type new_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_flags   : int;
+      sa_mask    : sigset_t;
+   end record;
+   pragma Convention (C, new_struct_sigaction);
+
+   subtype struct_sigaction is new_struct_sigaction;
+   type struct_sigaction_ptr is access all struct_sigaction;
+
+   SIG_BLOCK   : constant := 1;
+   SIG_UNBLOCK : constant := 2;
+   SIG_SETMASK : constant := 3;
+
+   SIG_DFL : constant := 0;
+   SIG_IGN : constant := 1;
+
+   SA_SIGINFO : constant := 16#0040#;
+   SA_ONSTACK : constant := 16#0001#;
+
+   function sigaction
+     (sig  : Signal;
+      act  : struct_sigaction_ptr;
+      oact : struct_sigaction_ptr) return int;
+   pragma Import (C, sigaction, "__gnat_sigaction");
+
+   ----------
+   -- Time --
+   ----------
+
+   Time_Slice_Supported : constant Boolean := True;
+   --  Indicates whether time slicing is supported (i.e SCHED_RR is supported)
+
+   type timespec is private;
+
+   function nanosleep (rqtp, rmtp : access timespec) return int;
+   pragma Import (C, nanosleep, "__gnat_nanosleep");
+
+   type clockid_t is new int;
+
+   function clock_getres
+     (clock_id : clockid_t;
+      res      : access timespec) return int;
+   pragma Import (C, clock_getres, "__gnat_clock_getres");
+
+   function clock_gettime
+     (clock_id : clockid_t;
+      tp       : access timespec)
+      return int;
+   pragma Import (C, clock_gettime, "__gnat_clock_gettime");
+
+   function To_Duration (TS : timespec) return Duration;
+   pragma Inline (To_Duration);
+
+   function To_Timespec (D : Duration) return timespec;
+   pragma Inline (To_Timespec);
+
+   type struct_timezone is record
+      tz_minuteswest : int;
+      tz_dsttime     : int;
+   end record;
+   pragma Convention (C, struct_timezone);
+
+   procedure usleep (useconds : unsigned_long);
+   pragma Import (C, usleep, "usleep");
+
+   -------------------------
+   -- Priority Scheduling --
+   -------------------------
+
+   SCHED_OTHER : constant := 0;
+   SCHED_FIFO  : constant := 1;
+   SCHED_RR    : constant := 2;
+
+   --  pthread_setschedparam is implementation-defined for SCHED_OTHER.
+   --  NetBSD only supports PRI_NONE (-1), see <sys/param.h>
+   STATIC_PRIORITY_FOR_SCHEDULER : constant Boolean := True;
+   DEFAULT_SCHEDULER_PRIORITY    : constant := -1;
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int;
+   --  Maps System.Any_Priority to a POSIX priority
+
+   -------------
+   -- Process --
+   -------------
+
+   type pid_t is private;
+
+   Self_PID : constant pid_t;
+
+   function kill (pid : pid_t; sig : Signal) return int;
+   pragma Import (C, kill, "kill");
+
+   function getpid return pid_t;
+   pragma Import (C, getpid, "getpid");
+
+   ---------
+   -- LWP --
+   ---------
+
+   function lwp_self return System.Address;
+   --  lwp_self does not exist on this thread library, revert to pthread_self
+   --  which is the closest approximation (with getpid). This function is
+   --  needed to share 7staprop.adb across POSIX-like targets.
+   pragma Import (C, lwp_self, "pthread_self");
+
+   -------------
+   -- Threads --
+   -------------
+
+   type Thread_Body is access
+     function (arg : System.Address) return System.Address;
+   pragma Convention (C, Thread_Body);
+
+   function Thread_Body_Access is new
+     Ada.Unchecked_Conversion (System.Address, Thread_Body);
+
+   type pthread_t           is private;
+   subtype Thread_Id        is pthread_t;
+
+   type pthread_mutex_t      is limited private;
+   type pthread_cond_t       is limited private;
+   type pthread_attr_t       is limited private;
+   type pthread_mutexattr_t  is limited private;
+   type pthread_condattr_t   is limited private;
+   type pthread_rwlock_t     is limited private;
+   type pthread_rwlockattr_t is limited private;
+   type pthread_key_t        is private;
+
+   PTHREAD_CREATE_DETACHED : constant := 1;
+   PTHREAD_CREATE_JOINABLE : constant := 0;
+
+   PTHREAD_SCOPE_PROCESS : constant := 0;
+   PTHREAD_SCOPE_SYSTEM  : constant := 2;
+
+   -----------
+   -- Stack --
+   -----------
+
+   type stack_t is record
+      ss_sp    : System.Address;
+      ss_size  : size_t;
+      ss_flags : int;
+   end record;
+   pragma Convention (C, stack_t);
+
+   function sigaltstack
+     (ss  : not null access stack_t;
+      oss : access stack_t) return int;
+   pragma Import (C, sigaltstack, "__gnat_sigaltstack");
+
+   Alternate_Stack : aliased System.Address;
+   --  This is a dummy definition, never used (Alternate_Stack_Size is null)
+
+   Alternate_Stack_Size : constant := 0;
+   --  No alternate signal stack is used on this platform
+
+   Stack_Base_Available : constant Boolean := False;
+   --  Indicates whether the stack base is available on this target
+
+   function Get_Stack_Base (thread : pthread_t) return Address;
+   pragma Inline (Get_Stack_Base);
+   --  returns the stack base of the specified thread. Only call this function
+   --  when Stack_Base_Available is True.
+
+   function Get_Page_Size return int;
+   pragma Import (C, Get_Page_Size, "getpagesize");
+   --  Returns the size of a page
+
+   PROT_NONE  : constant := 0;
+   PROT_READ  : constant := 1;
+   PROT_WRITE : constant := 2;
+   PROT_EXEC  : constant := 4;
+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;
+   PROT_ON    : constant := PROT_NONE;
+   PROT_OFF   : constant := PROT_ALL;
+
+   function mprotect (addr : Address; len : size_t; prot : int) return int;
+   pragma Import (C, mprotect);
+
+   ---------------------------------------
+   -- Nonstandard Thread Initialization --
+   ---------------------------------------
+
+   --  FSU_THREADS requires pthread_init, which is nonstandard and this should
+   --  be invoked during the elaboration of s-taprop.adb.
+
+   --  NetBSD does not require this so we provide an empty Ada body
+
+   procedure pthread_init;
+
+   -------------------------
+   -- POSIX.1c  Section 3 --
+   -------------------------
+
+   function sigwait
+     (set : access sigset_t;
+      sig : access Signal) return int;
+   pragma Import (C, sigwait, "sigwait");
+
+   function pthread_kill
+     (thread : pthread_t;
+      sig    : Signal) return int;
+   pragma Import (C, pthread_kill, "pthread_kill");
+
+   function pthread_sigmask
+     (how  : int;
+      set  : access sigset_t;
+      oset : access sigset_t) return int;
+   pragma Import (C, pthread_sigmask, "pthread_sigmask");
+
+   --------------------------
+   -- POSIX.1c  Section 11 --
+   --------------------------
+
+   function pthread_mutexattr_init
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_init, "pthread_mutexattr_init");
+
+   function pthread_mutexattr_destroy
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_destroy, "pthread_mutexattr_destroy");
+
+   function pthread_mutex_init
+     (mutex : access pthread_mutex_t;
+      attr  : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutex_init, "pthread_mutex_init");
+
+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_destroy, "pthread_mutex_destroy");
+
+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_lock, "pthread_mutex_lock");
+
+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_unlock, "pthread_mutex_unlock");
+
+   function pthread_condattr_init
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_init, "pthread_condattr_init");
+
+   function pthread_condattr_destroy
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_destroy, "pthread_condattr_destroy");
+
+   function pthread_cond_init
+     (cond : access pthread_cond_t;
+      attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_cond_init, "pthread_cond_init");
+
+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_destroy, "pthread_cond_destroy");
+
+   function pthread_cond_signal (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_signal, "pthread_cond_signal");
+
+   function pthread_cond_wait
+     (cond  : access pthread_cond_t;
+      mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_cond_wait, "pthread_cond_wait");
+
+   function pthread_cond_timedwait
+     (cond    : access pthread_cond_t;
+      mutex   : access pthread_mutex_t;
+      abstime : access timespec) return int;
+   pragma Import (C, pthread_cond_timedwait, "pthread_cond_timedwait");
+
+   --------------------------
+   -- POSIX.1c  Section 13 --
+   --------------------------
+
+   PTHREAD_PRIO_NONE    : constant := 0;
+   PTHREAD_PRIO_INHERIT : constant := 1;
+   PTHREAD_PRIO_PROTECT : constant := 2;
+
+   function pthread_mutexattr_setprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : int) return int;
+   pragma Import
+      (C, pthread_mutexattr_setprotocol, "pthread_mutexattr_setprotocol");
+
+   function pthread_mutexattr_getprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprotocol, "pthread_mutexattr_getprotocol");
+
+   function pthread_mutexattr_setprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : int) return int;
+   pragma Import
+     (C, pthread_mutexattr_setprioceiling,
+      "pthread_mutexattr_setprioceiling");
+
+   function pthread_mutexattr_getprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprioceiling,
+      "pthread_mutexattr_getprioceiling");
+
+   type struct_sched_param is record
+      sched_priority : int;
+   end record;
+   pragma Convention (C, struct_sched_param);
+
+   function pthread_getschedparam
+     (thread : pthread_t;
+      policy : access int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_getschedparam, "pthread_getschedparam");
+
+   function pthread_setschedparam
+     (thread : pthread_t;
+      policy : int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
+
+   function pthread_attr_setscope
+     (attr            : access pthread_attr_t;
+      contentionscope : int) return int;
+   pragma Import (C, pthread_attr_setscope, "pthread_attr_setscope");
+
+   function pthread_attr_getscope
+     (attr            : access pthread_attr_t;
+      contentionscope : access int) return int;
+   pragma Import (C, pthread_attr_getscope, "pthread_attr_getscope");
+
+   function pthread_attr_setinheritsched
+     (attr            : access pthread_attr_t;
+      inheritsched : int) return int;
+   pragma Import
+     (C, pthread_attr_setinheritsched, "pthread_attr_setinheritsched");
+
+   function pthread_attr_getinheritsched
+     (attr         : access pthread_attr_t;
+      inheritsched : access int) return int;
+   pragma Import
+     (C, pthread_attr_getinheritsched, "pthread_attr_getinheritsched");
+
+   function pthread_attr_setschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : int) return int;
+   pragma Import (C, pthread_attr_setschedpolicy,
+     "pthread_attr_setschedpolicy");
+
+   function pthread_attr_getschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : access int) return int;
+   pragma Import (C, pthread_attr_getschedpolicy,
+     "pthread_attr_getschedpolicy");
+
+   function pthread_attr_setschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : int) return int;
+   pragma Import (C, pthread_attr_setschedparam, "pthread_attr_setschedparam");
+
+   function pthread_attr_getschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : access int) return int;
+   pragma Import (C, pthread_attr_getschedparam, "pthread_attr_getschedparam");
+
+   function sched_yield return int;
+   pragma Import (C, sched_yield, "sched_yield");
+
+   --------------------------
+   -- P1003.1c  Section 16 --
+   --------------------------
+
+   function pthread_attr_init (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_init, "pthread_attr_init");
+
+   function pthread_attr_destroy
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_destroy, "pthread_attr_destroy");
+
+   function pthread_attr_setdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : int) return int;
+   pragma Import
+     (C, pthread_attr_setdetachstate, "pthread_attr_setdetachstate");
+
+   function pthread_attr_getdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : access int) return int;
+   pragma Import
+     (C, pthread_attr_getdetachstate, "pthread_attr_getdetachstate");
+
+   function pthread_attr_getstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : access size_t) return int;
+   pragma Import
+     (C, pthread_attr_getstacksize, "pthread_attr_getstacksize");
+
+   function pthread_attr_setstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : size_t) return int;
+   pragma Import
+     (C, pthread_attr_setstacksize, "pthread_attr_setstacksize");
+
+   function pthread_create
+     (thread        : access pthread_t;
+      attributes    : access pthread_attr_t;
+      start_routine : Thread_Body;
+      arg           : System.Address) return int;
+   pragma Import (C, pthread_create, "pthread_create");
+
+   function pthread_detach (thread : pthread_t) return int;
+   pragma Import (C, pthread_detach, "pthread_detach");
+
+   procedure pthread_exit (status : System.Address);
+   pragma Import (C, pthread_exit, "pthread_exit");
+
+   function pthread_self return pthread_t;
+   pragma Import (C, pthread_self, "pthread_self");
+
+   --------------------------
+   -- POSIX.1c  Section 17 --
+   --------------------------
+
+   function pthread_setspecific
+     (key   : pthread_key_t;
+      value : System.Address) return  int;
+   pragma Import (C, pthread_setspecific, "pthread_setspecific");
+
+   function pthread_getspecific (key : pthread_key_t) return System.Address;
+   pragma Import (C, pthread_getspecific, "pthread_getspecific");
+
+   type destructor_pointer is access procedure (arg : System.Address);
+   pragma Convention (C, destructor_pointer);
+
+   function pthread_key_create
+     (key        : access pthread_key_t;
+      destructor : destructor_pointer) return int;
+   pragma Import (C, pthread_key_create, "pthread_key_create");
+
+   ------------------------------------
+   -- Non-portable Pthread Functions --
+   ------------------------------------
+
+private
+
+   type sigset_t is array (1 .. 4) of unsigned;
+
+   --  In FreeBSD the component sa_handler turns out to
+   --  be one a union type, and the selector is a macro:
+   --  #define sa_handler __sigaction_u._handler
+   --  #define sa_sigaction __sigaction_u._sigaction
+
+   --  Should we add a signal_context type here ???
+   --  How could it be done independent of the CPU architecture ???
+   --  sigcontext type is opaque, so it is architecturally neutral.
+   --  It is always passed as an access type, so define it as an empty record
+   --  since the contents are not used anywhere.
+
+   type struct_sigcontext is null record;
+   pragma Convention (C, struct_sigcontext);
+
+   type pid_t is new int;
+   Self_PID : constant pid_t := 0;
+
+   type time_t is new int64;
+
+   type timespec is record
+      ts_sec  : time_t;
+      ts_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type pthread_t     is new System.Address;
+   type pthread_key_t is new int;
+
+   type pthread_attr_t is record
+      Data : char_array (1 .. System.OS_Constants.PTHREAD_ATTR_SIZE);
+   end record;
+   pragma Convention (C, pthread_attr_t);
+   for pthread_attr_t'Alignment use size_t'Alignment;
+
+   type pthread_mutex_t is record
+      Data : char_array (1 .. System.OS_Constants.PTHREAD_MUTEX_SIZE);
+   end record;
+   pragma Convention (C, pthread_mutex_t);
+   for pthread_mutex_t'Alignment use size_t'Alignment;
+
+   type pthread_mutexattr_t is record
+      Data : char_array (1 .. System.OS_Constants.PTHREAD_MUTEXATTR_SIZE);
+   end record;
+   pragma Convention (C, pthread_mutexattr_t);
+   for pthread_mutexattr_t'Alignment use size_t'Alignment;
+
+   type pthread_cond_t is record
+      Data : char_array (1 .. System.OS_Constants.PTHREAD_COND_SIZE);
+   end record;
+   pragma Convention (C, pthread_cond_t);
+   for pthread_cond_t'Alignment use size_t'Alignment;
+
+   type pthread_condattr_t is record
+      Data : char_array (1 .. System.OS_Constants.PTHREAD_CONDATTR_SIZE);
+   end record;
+   pragma Convention (C, pthread_condattr_t);
+   for pthread_condattr_t'Alignment use size_t'Alignment;
+
+   type pthread_rwlock_t is record
+      Data : char_array (1 .. System.OS_Constants.PTHREAD_RWLOCK_SIZE);
+   end record;
+   pragma Convention (C, pthread_rwlock_t);
+   for pthread_rwlock_t'Alignment use size_t'Alignment;
+
+   type pthread_rwlockattr_t is record
+      Data : char_array (1 .. System.OS_Constants.PTHREAD_RWLOCKATTR_SIZE);
+   end record;
+   pragma Convention (C, pthread_rwlockattr_t);
+   for pthread_rwlockattr_t'Alignment use size_t'Alignment;
+
+end System.OS_Interface;
--- /dev/null
+++ gcc/ada/libgnat/g-socthi__bsd.adb
@@ -0,0 +1,356 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT COMPILER COMPONENTS                         --
+--                                                                          --
+--                    G N A T . S O C K E T S . T H I N                     --
+--                                                                          --
+--                                 B o d y                                  --
+--                                                                          --
+--                     Copyright (C) 2001-2018, AdaCore                     --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This package provides a target dependent thin interface to the sockets
+--  layer for use by the GNAT.Sockets package (g-socket.ads). This package
+--  should not be directly with'ed by an applications program.
+
+--  This is the *BSD version which uses fcntl rather than ioctl
+--  The constant SCON.Thread_Blocking_IO is always true (for all platforms, not
+--  just *BSD), so this binding is significantly simpler than the standard
+--  one it replaces.
+
+with GNAT.OS_Lib; use GNAT.OS_Lib;
+
+with Interfaces.C; use Interfaces.C;
+
+package body GNAT.Sockets.Thin is
+
+   function Syscall_Accept
+     (S       : C.int;
+      Addr    : System.Address;
+      Addrlen : not null access C.int) return C.int;
+   pragma Import (C, Syscall_Accept, "accept");
+   --  The accept() function accepts a connection on a socket.  An incoming
+   --  connection is acknowledged and associated with an immediately created
+   --  socket.  The original socket is returned to the listening state.
+
+   function Syscall_Connect
+     (S       : C.int;
+      Name    : System.Address;
+      Namelen : C.int) return C.int;
+   pragma Import (C, Syscall_Connect, "connect");
+   --  The connect() system call initiates a connection on a socket.  If the
+   --  parameter S is of type SOCK_DGRAM then connect() permanently specifies
+   --  the peer to which datagrams are to be sent.  If S is type SOCK_STREAM
+   --  then connect() attempts to make a connection with another socket, which
+   --  is identified by the parameter Name.
+
+   function Syscall_Recv
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.size_t;
+      Flags : C.int) return C.int;
+   pragma Import (C, Syscall_Recv, "recv");
+   --  The recv() function receives a message from a socket.  The call can be
+   --  used on a connection mode socket or a bound, connectionless socket.  If
+   --  no messages are available at the socket, the recv() call waits for a
+   --  message to arrive unless the socket is non-blocking.  If a socket is
+   --  non-blocking, the call returns a -1 and ERRNO is set to EWOULDBLOCK.
+
+   function Syscall_Recvfrom
+     (S       : C.int;
+      Msg     : System.Address;
+      Len     : C.size_t;
+      Flags   : C.int;
+      From    : System.Address;
+      Fromlen : not null access C.int) return C.int;
+   pragma Import (C, Syscall_Recvfrom, "recvfrom");
+   --  The recvfrom() system call receives a message from a socket and captures
+   --  the address from which the data was sent.  It can be used to receive
+   --  data on an unconnected socket as well.  If no messages are available,
+   --  the call waits for a message to arrive on blocking sockets.  For
+   --  non-blocking sockets without messages, -1 is returned and ERRNO is set
+   --  to EAGAIN or EWOULDBLOCK.
+
+   function Syscall_Recvmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t;
+   pragma Import (C, Syscall_Recvmsg, "recvmsg");
+   --  The recvmsg call receives a message from a socket, and can be used to
+   --  receive data on an unconnected socket as well.  If no messages are
+   --  available, the call waits for a message to arrive on blocking sockets.
+   --  For non-blocking sockets without messages, -1 is returned and ERRNO is
+   --  set to EAGAIN or EWOULDBLOCK.
+
+   function Syscall_Sendmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t;
+   pragma Import (C, Syscall_Sendmsg, "sendmsg");
+   --  The sendmsg() function sends a message to a socket, and can be used with
+   --  unconnected sockets as well (the msg is ignored in this case).  The
+   --  function returns the number of bytes sent when successful, otherwise it
+   --  returns -1 and ERRNO is set (many possible values).
+
+   function Syscall_Sendto
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.size_t;
+      Flags : C.int;
+      To    : System.Address;
+      Tolen : C.int) return C.int;
+   pragma Import (C, Syscall_Sendto, "sendto");
+   --  The sendto() function only works for connected sockets and it initiates
+   --  the transmission of a message.  A successful call returns the numbers of
+   --  bytes sent, and a failure returns a -1 and ERRNO is set.
+
+   function Syscall_Socket
+     (Domain   : C.int;
+      Typ      : C.int;
+      Protocol : C.int) return C.int;
+   pragma Import (C, Syscall_Socket, "__gnat_socket");
+   --  The socket() function is used to create an unbound socket and returns a
+   --  file descriptor that can be used with other socket functions.  Upon
+   --  failure, a -1 is returned and ERRNO is set.
+
+   procedure Disable_SIGPIPE (S : C.int);
+   pragma Import (C, Disable_SIGPIPE, "__gnat_disable_sigpipe");
+
+   procedure Disable_All_SIGPIPEs;
+   pragma Import (C, Disable_All_SIGPIPEs, "__gnat_disable_all_sigpipes");
+   --  Sets the process to ignore all SIGPIPE signals on platforms that
+   --  don't support Disable_SIGPIPE for particular streams.
+
+   function C_Fcntl
+     (Fd  : C.int;
+      Cmd : C.int;
+      Val : C.int) return C.int;
+   pragma Import (C, C_Fcntl, "fcntl");
+   --  The ioctl of 64-bit DragonFlyBSD, OpenBSD, and NetBSD does not support
+   --  setting a socket in non-blocking mode.  fcntl must be used instead.
+
+   --------------
+   -- C_Accept --
+   --------------
+
+   function C_Accept
+     (S       : C.int;
+      Addr    : System.Address;
+      Addrlen : not null access C.int) return C.int
+   is
+      R : constant C.int := Syscall_Accept (S, Addr, Addrlen);
+   begin
+
+      Disable_SIGPIPE (R);
+      return R;
+   end C_Accept;
+
+   ---------------
+   -- C_Connect --
+   ---------------
+
+   function C_Connect
+     (S       : C.int;
+      Name    : System.Address;
+      Namelen : C.int) return C.int
+   is
+   begin
+      return Syscall_Connect (S, Name, Namelen);
+   end C_Connect;
+
+   ------------------
+   -- Socket_Ioctl --
+   ------------------
+
+   function Socket_Ioctl
+     (S   : C.int;
+      Req : SOSC.IOCTL_Req_T;
+      Arg : access C.int) return C.int
+   is
+   begin
+      if Req = SOSC.FIONBIO then
+         declare
+            use Interfaces;
+            flags    : constant Unsigned_32 :=
+                                Unsigned_32 (C_Fcntl (S, SOSC.F_GETFL, 0));
+            nonblock : constant Unsigned_32 := Unsigned_32 (SOSC.O_NDELAY);
+            enabled  : constant Boolean := Arg.all = 1;
+            newval   : C.int := C.int (flags);
+         begin
+            if enabled then
+               newval := C.int (flags or nonblock);
+            elsif (flags and nonblock) > 0 then
+               newval := C.int (flags - nonblock);
+            end if;
+            return C_Fcntl (Fd => S, Cmd => SOSC.F_SETFL, Val => newval);
+         end;
+      end if;
+
+      return C_Ioctl (S, Req, Arg);
+   end Socket_Ioctl;
+
+   ------------
+   -- C_Recv --
+   ------------
+
+   function C_Recv
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.size_t;
+      Flags : C.int) return C.int
+   is
+   begin
+      return Syscall_Recv (S, Msg, Len, Flags);
+   end C_Recv;
+
+   ----------------
+   -- C_Recvfrom --
+   ----------------
+
+   function C_Recvfrom
+     (S       : C.int;
+      Msg     : System.Address;
+      Len     : C.size_t;
+      Flags   : C.int;
+      From    : System.Address;
+      Fromlen : not null access C.int) return C.int
+   is
+   begin
+      return Syscall_Recvfrom (S, Msg, Len, Flags, From, Fromlen);
+   end C_Recvfrom;
+
+   ---------------
+   -- C_Recvmsg --
+   ---------------
+
+   function C_Recvmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t
+   is
+   begin
+      return Syscall_Recvmsg (S, Msg, Flags);
+   end C_Recvmsg;
+
+   ---------------
+   -- C_Sendmsg --
+   ---------------
+
+   function C_Sendmsg
+     (S     : C.int;
+      Msg   : System.Address;
+      Flags : C.int) return System.CRTL.ssize_t
+   is
+   begin
+      return Syscall_Sendmsg (S, Msg, Flags);
+   end C_Sendmsg;
+
+   --------------
+   -- C_Sendto --
+   --------------
+
+   function C_Sendto
+     (S     : C.int;
+      Msg   : System.Address;
+      Len   : C.size_t;
+      Flags : C.int;
+      To    : System.Address;
+      Tolen : C.int) return C.int
+   is
+   begin
+      return Syscall_Sendto (S, Msg, Len, Flags, To, Tolen);
+   end C_Sendto;
+
+   --------------
+   -- C_Socket --
+   --------------
+
+   function C_Socket
+     (Domain   : C.int;
+      Typ      : C.int;
+      Protocol : C.int) return C.int
+   is
+      R : constant C.int := Syscall_Socket (Domain, Typ, Protocol);
+   begin
+      Disable_SIGPIPE (R);
+      return R;
+   end C_Socket;
+
+   --------------
+   -- Finalize --
+   --------------
+
+   procedure Finalize is
+   begin
+      null;
+   end Finalize;
+
+   -------------------------
+   -- Host_Error_Messages --
+   -------------------------
+
+   package body Host_Error_Messages is separate;
+
+   ----------------
+   -- Initialize --
+   ----------------
+
+   procedure Initialize is
+   begin
+      Disable_All_SIGPIPEs;
+   end Initialize;
+
+   --------------------
+   -- Signalling_Fds --
+   --------------------
+
+   package body Signalling_Fds is
+
+      --  In this default implementation, we use a C version of these
+      --  subprograms provided by socket.c.
+
+      function C_Create (Fds : not null access Fd_Pair) return C.int;
+      function C_Read (Rsig : C.int) return C.int;
+      function C_Write (Wsig : C.int) return C.int;
+      procedure C_Close (Sig : C.int);
+
+      pragma Import (C, C_Create, "__gnat_create_signalling_fds");
+      pragma Import (C, C_Read,   "__gnat_read_signalling_fd");
+      pragma Import (C, C_Write,  "__gnat_write_signalling_fd");
+      pragma Import (C, C_Close,  "__gnat_close_signalling_fd");
+
+      function Create
+        (Fds : not null access Fd_Pair) return C.int renames C_Create;
+      function Read (Rsig : C.int) return C.int renames C_Read;
+      function Write (Wsig : C.int) return C.int renames C_Write;
+      procedure Close (Sig : C.int) renames C_Close;
+
+   end Signalling_Fds;
+
+   --------------------------
+   -- Socket_Error_Message --
+   --------------------------
+
+   function Socket_Error_Message (Errno : Integer) return String is separate;
+
+end GNAT.Sockets.Thin;
--- /dev/null
+++ gcc/ada/libgnat/s-trasym__bsd.adb
@@ -0,0 +1,171 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                         GNAT RUN-TIME COMPONENTS                         --
+--                                                                          --
+--           S Y S T E M . T R A C E B A C K . S Y M B O L I C              --
+--                                                                          --
+--                                 B o d y                                  --
+--                                                                          --
+--                     Copyright (C) 1999-2018, AdaCore                     --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNAT was originally developed  by the GNAT team at  New York University. --
+-- Extensive contributions were provided by Ada Core Technologies Inc.      --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  Run-time symbolic traceback support
+--  This file is based on the work by Juergen Pfiefer which is still used
+--  today to provide symbolic traceback support for gnu/kFreeBSD.
+--  Incorporated in GNAT-AUX by John Marino <http://www.dragonlace.net>
+
+with Ada.Exceptions.Traceback; use Ada.Exceptions.Traceback;
+with System.Soft_Links;
+
+package body System.Traceback.Symbolic is
+
+   --  Note that Suppress_Hex is ignored in this version of this package.
+
+   package TSL renames System.Soft_Links;
+
+   --  To perform the raw addresses to symbolic form translation we rely on a
+   --  libaddr2line symbolizer which examines debug info from a provided
+   --  executable file name, and an absolute path is needed to ensure the file
+   --  is always found. This is "__gnat_locate_exec_on_path (gnat_argv [0])"
+   --  for our executable file, a fairly heavy operation so we cache the
+   --  result.
+
+   Exename : System.Address;
+   --  Pointer to the name of the executable file to be used on all
+   --  invocations of the libaddr2line symbolization service.
+
+   Exename_Resolved : Boolean := False;
+   --  Flag to indicate whether we have performed the executable file name
+   --  resolution already. Relying on a not null Exename for this purpose
+   --  would be potentially inefficient as this is what we will get if the
+   --  resolution attempt fails.
+
+   ------------------------
+   -- Symbolic_Traceback --
+   ------------------------
+
+   function Symbolic_Traceback
+     (Traceback : System.Traceback_Entries.Tracebacks_Array) return String
+   is
+      procedure convert_addresses
+        (filename : System.Address;
+         addrs    : System.Address;
+         n_addrs  : Integer;
+         buf      : System.Address;
+         len      : System.Address);
+      pragma Import (C, convert_addresses, "convert_addresses");
+      --  This is the procedure version of the Ada-aware addr2line. It places
+      --  in BUF a string representing the symbolic translation of the N_ADDRS
+      --  raw addresses provided in ADDRS, looked up in debug information from
+      --  FILENAME. LEN points to an integer which contains the size of the
+      --  BUF buffer at input and the result length at output.
+      --
+      --  Note that this procedure is *not* thread-safe.
+
+      type Argv_Array is array (0 .. 0) of System.Address;
+      gnat_argv : access Argv_Array;
+      pragma Import (C, gnat_argv, "gnat_argv");
+
+      function locate_exec_on_path
+        (c_exename : System.Address) return System.Address;
+      pragma Import (C, locate_exec_on_path, "__gnat_locate_exec_on_path");
+
+      B_Size : constant Integer := 256 * Traceback'Length;
+      Len    : Integer := B_Size;
+      Res    : String (1 .. B_Size);
+
+   begin
+      if Traceback'Length = 0 then
+         return "";
+      end if;
+
+      --  If our input set of raw addresses is not empty, resort to the
+      --  libaddr2line service to symbolize it all.
+
+      --  Compute, cache and provide the absolute path to our executable file
+      --  name as the binary file where the relevant debug information is to be
+      --  found. If the executable file name resolution fails, we have no
+      --  sensible basis to invoke the symbolizer at all.
+
+      --  Protect all this against concurrent accesses explicitly, as the
+      --  underlying services are potentially thread unsafe.
+
+      TSL.Lock_Task.all;
+
+      if not Exename_Resolved then
+         Exename := locate_exec_on_path (gnat_argv (0));
+         Exename_Resolved := True;
+      end if;
+
+      if Exename /= System.Null_Address then
+         Len := Res'Length;
+         convert_addresses
+           (Exename, Traceback'Address, Traceback'Length,
+            Res (1)'Address, Len'Address);
+      end if;
+
+      TSL.Unlock_Task.all;
+
+      --  Return what the addr2line symbolizer has produced if we have called
+      --  it (the executable name resolution succeeded), or an empty string
+      --  otherwise.
+
+      if Exename /= System.Null_Address then
+         return Res (1 .. Len);
+      else
+         return "";
+      end if;
+   end Symbolic_Traceback;
+
+   --  "No_Hex" is ignored in this version, because otherwise we have nothing
+   --  at all to print.
+
+   function Symbolic_Traceback_No_Hex
+     (Traceback : System.Traceback_Entries.Tracebacks_Array) return String is
+   begin
+      return Symbolic_Traceback (Traceback);
+   end Symbolic_Traceback_No_Hex;
+
+   function Symbolic_Traceback
+     (E : Ada.Exceptions.Exception_Occurrence) return String
+   is
+   begin
+      return Symbolic_Traceback (Tracebacks (E));
+   end Symbolic_Traceback;
+
+   function Symbolic_Traceback_No_Hex
+     (E : Ada.Exceptions.Exception_Occurrence) return String is
+   begin
+      return Symbolic_Traceback (E);
+   end Symbolic_Traceback_No_Hex;
+
+   ------------------
+   -- Enable_Cache --
+   ------------------
+
+   procedure Enable_Cache (Include_Modules : Boolean := False) is
+   begin
+      null;
+   end Enable_Cache;
+
+end System.Traceback.Symbolic;
--- gcc/ada/gcc-interface/Make-lang.in.orig
+++ gcc/ada/gcc-interface/Make-lang.in
@@ -723,7 +723,7 @@
 endif
 
 # Language-independent object files.
-ADA_BACKEND = $(BACKEND) attribs.o
+ADA_BACKEND = $(BACKEND2) attribs.o
 
 # List of target dependent sources, overridden below as necessary
 TARGET_ADA_SRCS =
--- gcc/ada/init.c.orig
+++ gcc/ada/init.c
@@ -2778,8 +2778,15 @@
 {
   mcontext_t *mcontext = &((ucontext_t *) ucontext)->uc_mcontext;
 
+#if defined (__i386__)
+  unsigned long *pc = (unsigned long *)mcontext->gregs[REG_EIP];
+  /* The pattern is "orl $0x0,(%esp)" for a probe in 32-bit mode.  */
+  if (signo == SIGSEGV && pc && *pc == 0x00240c83)
+    mcontext->gregs[REG_ESP] += 4096 + 4 * sizeof (unsigned long);
+#elif defined (__ARMEL__)
   /* ARM Bump has to be an even number because of odd/even architecture.  */
-  ((mcontext_t *) mcontext)->arm_pc += 2;
+  mcontext->arm_pc += 2;
+#endif
 }
 
 static void
--- gcc/ada/libgnarl/s-taprop__posix.adb.orig
+++ gcc/ada/libgnarl/s-taprop__posix.adb
@@ -629,6 +629,9 @@
         or else Priority_Specific_Policy = 'F'
         or else Time_Slice_Val = 0
       then
+         if STATIC_PRIORITY_FOR_SCHEDULER then
+            Param.sched_priority := DEFAULT_SCHEDULER_PRIORITY;
+         end if;
          Result := pthread_setschedparam
            (T.Common.LL.Thread, SCHED_FIFO, Param'Access);
 
--- gcc/ada/libgnarl/s-osinte__android.ads.orig
+++ gcc/ada/libgnarl/s-osinte__android.ads
@@ -237,6 +237,11 @@
    SCHED_FIFO  : constant := 1;
    SCHED_RR    : constant := 2;
 
+   --  pthread_setschedparam is implementation-defined for SCHED_OTHER.
+   --  Android supports the full priority range.
+   STATIC_PRIORITY_FOR_SCHEDULER : constant Boolean := False;
+   DEFAULT_SCHEDULER_PRIORITY    : constant := 0;
+
    function To_Target_Priority
      (Prio : System.Any_Priority)
       return Interfaces.C.int is (Interfaces.C.int (Prio));
--- gcc/ada/libgnarl/s-osinte__dragonfly.ads.orig
+++ gcc/ada/libgnarl/s-osinte__dragonfly.ads
@@ -238,6 +238,11 @@
    SCHED_OTHER : constant := 2;
    SCHED_RR    : constant := 3;
 
+   --  pthread_setschedparam is implementation-defined for SCHED_OTHER.
+   --  DragonFly supports the full priority range.
+   STATIC_PRIORITY_FOR_SCHEDULER : constant Boolean := False;
+   DEFAULT_SCHEDULER_PRIORITY    : constant := 0;
+
    function To_Target_Priority
      (Prio : System.Any_Priority) return Interfaces.C.int;
    --  Maps System.Any_Priority to a POSIX priority
--- gcc/ada/libgnarl/s-osinte__freebsd.ads.orig
+++ gcc/ada/libgnarl/s-osinte__freebsd.ads
@@ -238,6 +238,11 @@
    SCHED_OTHER : constant := 2;
    SCHED_RR    : constant := 3;
 
+   --  pthread_setschedparam is implementation-defined for SCHED_OTHER.
+   --  FreeBSD supports the full priority range.
+   STATIC_PRIORITY_FOR_SCHEDULER : constant Boolean := False;
+   DEFAULT_SCHEDULER_PRIORITY    : constant := 0;
+
    function To_Target_Priority
      (Prio : System.Any_Priority) return Interfaces.C.int;
    --  Maps System.Any_Priority to a POSIX priority
--- gcc/ada/libgnat/g-socthi.ads.orig
+++ gcc/ada/libgnat/g-socthi.ads
@@ -53,8 +53,6 @@
 
    package C renames Interfaces.C;
 
-   use type System.CRTL.ssize_t;
-
    function Socket_Errno return Integer renames GNAT.OS_Lib.Errno;
    --  Returns last socket error number
 
@@ -256,7 +254,7 @@
    pragma Import (C, C_Getsockname, "getsockname");
    pragma Import (C, C_Getsockopt, "getsockopt");
    pragma Import (C, C_Listen, "listen");
-   pragma Import (C, C_Select, "select");
+   pragma Import (C, C_Select, "__gnat_select");
    pragma Import (C, C_Setsockopt, "setsockopt");
    pragma Import (C, C_Shutdown, "shutdown");
    pragma Import (C, C_Socketpair, "socketpair");
--- gcc/ada/libgnat/s-osprim__posix.adb.orig
+++ gcc/ada/libgnat/s-osprim__posix.adb
@@ -49,7 +49,7 @@
    pragma Convention (C, timespec);
 
    function nanosleep (rqtp, rmtp : not null access timespec) return Integer;
-   pragma Import (C, nanosleep, "nanosleep");
+   pragma Import (C, nanosleep, "__gnat_nanosleep");
 
    -----------
    -- Clock --
@@ -79,7 +79,7 @@
       function gettimeofday
         (Tv : access timeval;
          Tz : System.Address := System.Null_Address) return Integer;
-      pragma Import (C, gettimeofday, "gettimeofday");
+      pragma Import (C, gettimeofday, "__gnat_gettimeofday");
 
    begin
       --  The return codes for gettimeofday are as follows (from man pages):
--- gcc/ada/s-oscons-tmplt.c.orig
+++ gcc/ada/s-oscons-tmplt.c
@@ -407,7 +407,7 @@
 
 /* ioctl(2) requests are "int" in UNIX, but "unsigned long" on FreeBSD */
 
-#if defined (__FreeBSD__) || defined (__DragonFly__)
+#if defined (__FreeBSD__) || defined (__DragonFly__) || defined (__NetBSD__)
 # define CNI CNU
 # define IOCTL_Req_T "Interfaces.C.unsigned"
 #else
@@ -1054,7 +1054,7 @@
 
 */
 
-#if defined (__FreeBSD__) || defined (__linux__) || defined (__DragonFly__)
+#if defined (__FreeBSD__) || defined (__linux__) || defined (__DragonFly__) || defined (__NetBSD__)
 # define PTY_Library "-lutil"
 #else
 # define PTY_Library ""
@@ -1975,6 +1975,7 @@
 
 #if defined(__linux__) || defined(__FreeBSD__) \
  || (defined(_AIX) && defined(_AIXVERSION_530)) \
+ || defined(__NetBSD__) \
  || defined(__DragonFly__) || defined(__QNX__) \
  || defined (__vxworks)
 /** On these platforms use system provided monotonic clock instead of
@@ -1998,6 +1999,7 @@
 #endif
 
 #if defined (__APPLE__) || defined (__linux__) || defined (__ANDROID__) \
+  || defined (__NetBSD__) \
   || defined (__QNX__) || defined (__rtems__) || defined (DUMMY)
 /*
 
--- gcc/ada/sysdep.c.orig
+++ gcc/ada/sysdep.c
@@ -321,6 +321,7 @@
   || (defined (__svr4__) && defined (__i386__)) || defined (__Lynx__) \
   || defined (__CYGWIN__) || defined (__FreeBSD__) || defined (__OpenBSD__) \
   || defined (__GLIBC__) || defined (__APPLE__) || defined (__DragonFly__) \
+  || defined (__NetBSD__) \
   || defined (__QNX__)
 
 # ifdef __MINGW32__
@@ -370,6 +371,7 @@
     || defined (_AIX) || (defined (__svr4__) && defined (__i386__)) \
     || defined (__Lynx__) || defined (__FreeBSD__) || defined (__OpenBSD__) \
     || defined (__GLIBC__) || defined (__APPLE__) || defined (__DragonFly__) \
+    || defined (__NetBSD__) \
     || defined (__QNX__)
   char c;
   int nread;
@@ -391,6 +393,7 @@
     || defined (_AIX) || (defined (__svr4__) && defined (__i386__)) \
     || defined (__Lynx__) || defined (__FreeBSD__) || defined (__OpenBSD__) \
     || defined (__GLIBC__) || defined (__APPLE__) || defined (__DragonFly__) \
+    || defined (__NetBSD__) \
     || defined (__QNX__)
       eof_ch = termios_rec.c_cc[VEOF];
 
@@ -830,6 +833,7 @@
 
 #elif defined (__APPLE__) || defined (__FreeBSD__) || defined (__linux__) \
   || defined (__GLIBC__) || defined (__DragonFly__) || defined (__OpenBSD__) \
+  || defined (__NetBSD__) \
   || defined (__DJGPP__) || defined (__QNX__)
 {
   localtime_r (&time, &tp);
--- gnattools/configure.orig
+++ gnattools/configure
@@ -2069,6 +2069,9 @@
   *-*-freebsd*)
     TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
+  *-*-netbsd*)
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
+    ;;
   *-*-linux*)
     TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
