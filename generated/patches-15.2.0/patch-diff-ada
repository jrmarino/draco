--- gcc/ada/Makefile.rtl.orig
+++ gcc/ada/Makefile.rtl
@@ -1828,6 +1828,34 @@ endif
 endif
 endif
 
+# x86 android
+ifeq ($(strip $(filter-out %86 linux-android,$(target_cpu) $(target_os))),)
+  LIBGNAT_TARGET_PAIRS = \
+  a-intnam.ads<libgnarl/a-intnam__linux.ads \
+  s-inmaop.adb<libgnarl/s-inmaop__posix.adb \
+  s-intman.adb<libgnarl/s-intman__posix.adb \
+  s-linux.ads<libgnarl/s-linux__android.ads \
+  s-osinte.adb<libgnarl/s-osinte__android.adb \
+  s-osinte.ads<libgnarl/s-osinte__android.ads \
+  s-oslock.ads<libgnat/s-oslock__posix.ads \
+  s-osprim.adb<libgnat/s-osprim__posix.adb \
+  s-taprop.adb<libgnarl/s-taprop__posix.adb \
+  s-taspri.ads<libgnarl/s-taspri__posix.ads \
+  s-tpopsp.adb<libgnarl/s-tpopsp__posix-foreign.adb \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(ATOMICS_BUILTINS_TARGET_PAIRS) \
+  system.ads<libgnat/system-linux-x86.ads
+
+  TOOLS_TARGET_PAIRS = indepsw.adb<indepsw-gnu.adb
+
+  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o
+  EH_MECHANISM=-gcc
+  THREADSLIB =
+  MISCLIB =
+  GNATLIB_SHARED = gnatlib-shared-dual
+  LIBRARY_VERSION := $(LIB_VERSION)
+endif
+
 # aarch64 FreeBSD
 ifeq ($(SELECTED_PAIRS),PAIRS_NONE)
 ifeq ($(strip $(filter-out %aarch64 freebsd%,$(target_cpu) $(target_os))),)
@@ -1967,6 +1995,44 @@ ifeq ($(strip $(filter-out %86_64 dragonfly%,$(target_
   s-mudido.adb<libgnarl/s-mudido__affinity.adb \
   s-osinte.adb<libgnarl/s-osinte__dragonfly.adb \
   s-osinte.ads<libgnarl/s-osinte__dragonfly.ads \
+  s-oslock.ads<libgnat/s-oslock__posix.ads \
+  s-osprim.adb<libgnat/s-osprim__posix.adb \
+  s-taprop.adb<libgnarl/s-taprop__posix.adb \
+  s-taspri.ads<libgnarl/s-taspri__posix.ads \
+  s-tpopsp.adb<libgnarl/s-tpopsp__posix.adb \
+  $(TRASYM_DWARF_UNIX_PAIRS) \
+  $(ATOMICS_TARGET_PAIRS) \
+  $(X86_64_TARGET_PAIRS) \
+  $(GNATRTL_128BIT_PAIRS) \
+  system.ads<libgnat/system-dragonfly-x86_64.ads
+
+  GNATLIB_SHARED = gnatlib-shared-dual
+
+  EXTRA_GNATRTL_NONTASKING_OBJS += g-sse.o g-ssvety.o
+  EXTRA_GNATRTL_NONTASKING_OBJS += $(GNATRTL_128BIT_OBJS)
+  EXTRA_GNATRTL_NONTASKING_OBJS += $(TRASYM_DWARF_UNIX_OBJS)
+
+  EH_MECHANISM=-gcc
+  THREADSLIB= -lpthread
+  GMEM_LIB = gmemlib
+  LIBRARY_VERSION := $(LIB_VERSION)
+  MISCLIB = -lutil
+endif
+endif
+
+# x86-64 NetBSD
+ifeq ($(SELECTED_PAIRS),PAIRS_NONE)
+ifeq ($(strip $(filter-out %86_64 netbsd%,$(target_cpu) $(target_os))),)
+
+  SELECTED_PAIRS=x86_64-dragonfly
+
+  LIBGNAT_TARGET_PAIRS = \
+  a-intnam.ads<libgnarl/a-intnam__bsd.ads \
+  s-inmaop.adb<libgnarl/s-inmaop__posix.adb \
+  s-intman.adb<libgnarl/s-intman__posix.adb \
+  s-mudido.adb<libgnarl/s-mudido__affinity.adb \
+  s-osinte.adb<libgnarl/s-osinte__netbsd.adb \
+  s-osinte.ads<libgnarl/s-osinte__netbsd.ads \
   s-oslock.ads<libgnat/s-oslock__posix.ads \
   s-osprim.adb<libgnat/s-osprim__posix.adb \
   s-taprop.adb<libgnarl/s-taprop__posix.adb \
--- gcc/ada/adaint.c.orig
+++ gcc/ada/adaint.c
@@ -853,6 +853,7 @@ __gnat_rmdir (char *path)
 }
 
 #if defined (_WIN32) || defined (__linux__) || defined (__sun__) \
+  || defined (__NetBSD__) \
   || defined (__FreeBSD__) || defined(__DragonFly__) || defined (__QNX__)
 #define HAS_TARGET_WCHAR_T
 #endif
@@ -1263,6 +1264,47 @@ __gnat_tmp_name (char *tmp_filename)
     free (pname);
   }
 
+#elif defined (__ANDROID__)
+
+  /*
+   * ext2 /ext3/ext4/fat16/fat32 have no path limits
+   * /data/local/tmp normally requires rooted devices, if it even exists
+   * /sdcard is the standard location for external storage.  Nativeactivity
+   * manifest needs to authorize its use, otherwise it might not have the
+   * proper permissions.
+   */
+
+  int testfd;
+  char *datadir = getenv ("ANDROID_DATA");
+
+  if (datadir == NULL)
+    strncpy (tmp_filename, "/data/local/tmp/gnat-XXXXXX", L_tmpnam);
+  else
+    snprintf (tmp_filename, L_tmpnam, "%s/local/tmp/gnat-XXXXXX", datadir);
+
+  testfd = mkstemp (tmp_filename);
+  if (testfd != -1)
+    {
+      close (testfd);
+      return;
+    }
+
+  char *sdcard = getenv ("EXTERNAL_STORAGE");
+
+  if (sdcard == NULL)
+    strncpy (tmp_filename, "/sdcard/gnat-XXXXXX", L_tmpnam);
+  else
+    snprintf (tmp_filename, L_tmpnam, "%s/gnat-XXXXXX", sdcard);
+
+  testfd = mkstemp (tmp_filename);
+  if (testfd != -1)
+    {
+      close (testfd);
+      return;
+    }
+
+  tmpnam (tmp_filename);
+
 #elif defined (__linux__) || defined (__FreeBSD__) || defined (__NetBSD__) \
   || defined (__OpenBSD__) || defined (__GLIBC__) || defined (__ANDROID__) \
   || defined (__DragonFly__) || defined (__QNX__)
@@ -3713,6 +3755,70 @@ void __gnat_killprocesstree (int pid, int sig_num)
      See: /usr/include/sys/procfs.h (struct pstatus).
   */
 }
+
+#if defined(__NetBSD__)
+/* It's 2021, and NetBSD still doesn't use symbol versioning in their
+ * libraries.  They mimic this by having header macros rename the function
+ * at compile time.  If we don't wrap the functions, the osinte specification
+ * for NetBSD would need to import e.g. __sigaltstack14 instead of sigaltstack.
+ * By wrapping, new versions won't break gnat.
+ */
+int
+__gnat_sigemptyset (sigset_t *set) {
+   return sigemptyset (set);
+}
+int
+__gnat_sigfillset (sigset_t *set) {
+   return sigfillset (set);
+}
+int
+__gnat_sigaddset (sigset_t *set, int signo) {
+   return sigaddset (set, signo);
+}
+int
+__gnat_sigdelset (sigset_t *set, int signo) {
+   return sigdelset (set, signo);
+}
+int
+__gnat_sigismember (sigset_t *set, int signo) {
+   return sigismember (set, signo);
+}
+int
+__gnat_sigaltstack (const stack_t *ss, stack_t *oss) {
+   return sigaltstack (ss, oss);
+}
+int
+__gnat_sigaction (int sig, const struct sigaction *act, struct sigaction *oact) {
+   return sigaction (sig, act, oact);
+}
+int
+__gnat_clock_getres (clockid_t clock_id, struct timespec *res) {
+   return clock_getres (clock_id, res);
+}
+int
+__gnat_clock_gettime (clockid_t clock_id, struct timespec *tp) {
+   return clock_gettime (clock_id, tp);
+}
+#endif
+int
+__gnat_nanosleep (const struct timespec *rqtp, struct timespec *rmtp) {
+   return nanosleep (rqtp, rmtp);
+}
+int
+__gnat_gettimeofday (struct timeval * tp, struct timezone * tzp) {
+   return gettimeofday (tp, tzp);
+}
+int
+__gnat_select(int nfds, fd_set * readfds, fd_set * writefds,
+              fd_set * exceptfds, struct timeval * timeout) {
+   return select (nfds, readfds, writefds, exceptfds, timeout);
+}
+#if defined(__FreeBSD__) || defined(__DragonFly__) || defined(__NetBSD__)
+int
+__gnat_socket (int domain, int type, int protocol) {
+   return socket (domain, type, protocol);
+}
+#endif // __FreeBSD__ || __DragonFly__ || __NetBSD__
 
 #ifdef __cplusplus
 }
--- gcc/ada/adaint.h.orig
+++ gcc/ada/adaint.h
@@ -348,6 +348,31 @@ extern const void * __gnat_get_executable_load_address
 
 extern const void * __gnat_get_executable_load_address  (void);
 
+#if defined(__NetBSD__)
+#include <signal.h>
+extern int    __gnat_sigemptyset (sigset_t *);
+extern int    __gnat_sigfillset  (sigset_t *);
+extern int    __gnat_sigaddset   (sigset_t *, int);
+extern int    __gnat_sigdelset   (sigset_t *, int);
+extern int    __gnat_sigismember (sigset_t *, int);
+extern int    __gnat_sigaltstack (const stack_t *, stack_t *);
+extern int    __gnat_sigaction   (int, const struct sigaction *, struct sigaction *);
+#endif
+#include <time.h>
+#include <sys/time.h>
+extern int    __gnat_nanosleep     (const struct timespec *, struct timespec *);
+extern int    __gnat_gettimeofday  (struct timeval *, struct timezone *);
+#include <sys/select.h>
+extern int    __gnat_select        (int, fd_set *, fd_set *, fd_set *, struct timeval *);
+#if defined(__FreeBSD__) || defined(__DragonFly__) || defined(__NetBSD__)
+#include <sys/socket.h>
+extern int    __gnat_socket        (int, int, int);
+#endif
+#if defined(__NetBSD__)
+extern int    __gnat_clock_getres  (clockid_t, struct timespec *);
+extern int    __gnat_clock_gettime (clockid_t, struct timespec *);
+#endif
+
 #ifdef __cplusplus
 }
 #endif
--- gcc/ada/gnatls.adb.orig
+++ gcc/ada/gnatls.adb
@@ -32,7 +32,6 @@ with Gnatvsn;     use Gnatvsn;
 with Csets;
 with Fname;       use Fname;
 with Gnatvsn;     use Gnatvsn;
-with Make_Util;   use Make_Util;
 with Namet;       use Namet;
 with Opt;         use Opt;
 with Osint;       use Osint;
@@ -1277,32 +1276,11 @@ procedure Gnatls is
          --  The path name(s) of directories where project files may reside.
          --  May be empty.
 
-         Prefix  : String_Ptr;
-         Runtime : String_Ptr;
-
-         procedure Add_Target (Suffix : String);
-         --  Add :<prefix>/<target>/Suffix to the project path
-
          FD  : File_Descriptor;
          Len : Integer;
 
-         ----------------
-         -- Add_Target --
-         ----------------
+         pragma Unreferenced (Runtime_Name);
 
-         procedure Add_Target (Suffix : String) is
-            Extra_Sep : constant String :=
-               (if Target_Name (Target_Name'Last) = '/' then
-                  ""
-                else
-                  (1 => Directory_Separator));
-            --  Note: Target_Name has a trailing / when it comes from Sdefault
-
-         begin
-            Add_Str_To_Name_Buffer
-              (Path_Separator & Prefix.all & Target_Name & Extra_Sep & Suffix);
-         end Add_Target;
-
       --  Start of processing for Initialize_Default_Project_Path
 
       begin
@@ -1481,81 +1459,14 @@ procedure Gnatls is
          --  Set the initial value of Current_Project_Path
 
          if Add_Default_Dir then
-            if Sdefault.Search_Dir_Prefix = null then
+            --  /raven/share/gpr
+            Add_Str_To_Name_Buffer (Path_Separator &
+              "@LOCALBASE@/share/gpr");
 
-               --  gprbuild case
+            --  /raven/lib/gnat
+            Add_Str_To_Name_Buffer (Path_Separator &
+              "@LOCALBASE@/lib/gnat");
 
-               Prefix := new String'(Executable_Prefix_Path);
-
-            else
-               Prefix := new String'(Sdefault.Search_Dir_Prefix.all
-                                     & ".." & Dir_Separator
-                                     & ".." & Dir_Separator
-                                     & ".." & Dir_Separator
-                                     & ".." & Dir_Separator);
-            end if;
-
-            if Prefix.all /= "" then
-               if Target_Name /= "" then
-
-                  if Runtime_Name /= "" then
-                     if Base_Name (Runtime_Name) = Runtime_Name then
-
-                        --  $prefix/$target/$runtime/lib/gnat
-
-                        Add_Target
-                          (Runtime_Name & Directory_Separator &
-                           "lib" & Directory_Separator & "gnat");
-
-                        --  $prefix/$target/$runtime/share/gpr
-
-                        Add_Target
-                          (Runtime_Name & Directory_Separator &
-                             "share" & Directory_Separator & "gpr");
-
-                     else
-                        Runtime :=
-                          new String'(Normalize_Pathname (Runtime_Name));
-
-                        --  $runtime_dir/lib/gnat
-
-                        Add_Str_To_Name_Buffer
-                          (Path_Separator & Runtime.all & Directory_Separator &
-                           "lib" & Directory_Separator & "gnat");
-
-                        --  $runtime_dir/share/gpr
-
-                        Add_Str_To_Name_Buffer
-                          (Path_Separator & Runtime.all & Directory_Separator &
-                           "share" & Directory_Separator & "gpr");
-                     end if;
-                  end if;
-
-                  --  $prefix/$target/lib/gnat
-
-                  Add_Target
-                    ("lib" & Directory_Separator & "gnat");
-
-                  --  $prefix/$target/share/gpr
-
-                  Add_Target
-                    ("share" & Directory_Separator & "gpr");
-               end if;
-
-               --  $prefix/share/gpr
-
-               Add_Str_To_Name_Buffer
-                 (Path_Separator & Prefix.all & "share"
-                  & Directory_Separator & "gpr");
-
-               --  $prefix/lib/gnat
-
-               Add_Str_To_Name_Buffer
-                 (Path_Separator & Prefix.all & "lib"
-                  & Directory_Separator & "gnat");
-            end if;
-
-            Free (Prefix);
          end if;
 
          Self := new String'(Name_Buffer (1 .. Name_Len));
--- gcc/ada/terminals.c.orig
+++ gcc/ada/terminals.c
@@ -34,7 +34,7 @@
 /* First all unsupported platforms. Add stubs for exported routines. */
 
 #if defined (VMS) || defined (__vxworks) || defined (__Lynx__) \
-  || defined (__ANDROID__) || defined (__PikeOS__) || defined(__DJGPP__)
+  || defined (__PikeOS__) || defined(__DJGPP__)
 
 void *
 __gnat_new_tty (void)
@@ -1096,7 +1096,7 @@ __gnat_setup_winsize (void *desc ATTRIBUTE_UNUSED,
  || defined (__OpenBSD__) \
  || defined (__NetBSD__)  \
  || defined (__DragonFly__)
-#   define BSD
+#   define FREEBSD
 #endif
 
 /* Include every system header we need */
@@ -1113,23 +1113,27 @@ __gnat_setup_winsize (void *desc ATTRIBUTE_UNUSED,
 #include <sys/types.h>
 #include <sys/wait.h>
 #include <unistd.h>
-#if defined (__sun__)
+#if defined (sun)
 #   include <sys/stropts.h>
 #endif
-#if defined (BSD) || defined (__sun__)
+#if defined (FREEBSD) || defined (sun)
 #   include <sys/signal.h>
 #endif
 #if defined (__hpux__)
 #   include <sys/stropts.h>
 #endif
-#if defined (__APPLE__)
+#if defined (__APPLE__) || defined (__NetBSD__)
 #   include <util.h>
 #endif
-#if defined (__FreeBSD__)
+#if defined (__FreeBSD__) || defined(__DragonFly__)
 #   include <libutil.h>
 #endif
 
+#ifdef __ANDROID__
+#define CDISABLE _PC_VDISABLE
+#else
 #define CDISABLE _POSIX_VDISABLE
+#endif
 
 /* POSIX does not specify how to open the master side of a terminal.Several
    methods are available (system specific):
@@ -1145,11 +1149,11 @@ __gnat_setup_winsize (void *desc ATTRIBUTE_UNUSED,
 */
 
 /* Configurable part */
-#if defined (__APPLE__) || defined (BSD)
+#if defined (__APPLE__) || defined (FREEBSD)
 #define USE_OPENPTY
-#elif defined (__linux__)
+#elif defined (linux)
 #define USE_GETPT
-#elif defined (__sun__)
+#elif defined (sun)
 #define USE_CLONE_DEVICE "/dev/ptmx"
 #elif defined (_AIX)
 #define USE_CLONE_DEVICE "/dev/ptc"
@@ -1444,7 +1448,7 @@ __gnat_setup_child_communication
     desc->slave_fd = open (desc->slave_name, O_RDWR, 0);
 #endif
 
-#if defined (__sun__) || defined (__hpux__)
+#if defined (sun) || defined (__hpux__)
   /* On systems such as Solaris we are using stream. We need to push the right
      "modules" in order to get the expected terminal behaviors. Otherwise
      functionalities such as termios are not available.  */
--- /dev/null
+++ gcc/ada/libgnarl/s-osinte__netbsd.adb
@@ -0,0 +1,115 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                   B o d y                                --
+--                                                                          --
+--          Copyright (C) 1991-2020, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNARL is free software; you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University. It is --
+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
+-- State University (http://www.gnat.com).                                  --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the NetBSD version of this package
+
+with Interfaces.C; use Interfaces.C;
+
+package body System.OS_Interface is
+
+   -----------
+   -- Errno --
+   -----------
+
+   function Errno return int is
+      type int_ptr is access all int;
+
+      function internal_errno return int_ptr;
+      pragma Import (C, internal_errno, "__get_errno");
+
+   begin
+      return (internal_errno.all);
+   end Errno;
+
+   --------------------
+   -- Get_Stack_Base --
+   --------------------
+
+   function Get_Stack_Base (thread : pthread_t) return Address is
+      pragma Unreferenced (thread);
+   begin
+      return Null_Address;
+   end Get_Stack_Base;
+
+   ------------------
+   -- pthread_init --
+   ------------------
+
+   procedure pthread_init is
+   begin
+      null;
+   end pthread_init;
+
+   -----------------
+   -- To_Duration --
+   -----------------
+
+   function To_Duration (TS : timespec) return Duration is
+   begin
+      return Duration (TS.ts_sec) + Duration (TS.ts_nsec) / 10#1#E9;
+   end To_Duration;
+
+   ------------------------
+   -- To_Target_Priority --
+   ------------------------
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int
+   is
+   begin
+      return Interfaces.C.int (Prio);
+   end To_Target_Priority;
+
+   -----------------
+   -- To_Timespec --
+   -----------------
+
+   function To_Timespec (D : Duration) return timespec is
+      S : time_t;
+      F : Duration;
+
+   begin
+      S := time_t (Long_Long_Integer (D));
+      F := D - Duration (S);
+
+      --  If F has negative value due to a round-up, adjust for positive F
+
+      if F < 0.0 then
+         S := S - 1;
+         F := F + 1.0;
+      end if;
+
+      return timespec'(ts_sec => S,
+                       ts_nsec => long (Long_Long_Integer (F * 10#1#E9)));
+   end To_Timespec;
+
+end System.OS_Interface;
--- /dev/null
+++ gcc/ada/libgnarl/s-osinte__netbsd.ads
@@ -0,0 +1,684 @@
+------------------------------------------------------------------------------
+--                                                                          --
+--                  GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                --
+--                                                                          --
+--                   S Y S T E M . O S _ I N T E R F A C E                  --
+--                                                                          --
+--                                   S p e c                                --
+--                                                                          --
+--             Copyright (C) 1991-2017, Florida State University            --
+--          Copyright (C) 1995-2020, Free Software Foundation, Inc.         --
+--                                                                          --
+-- GNAT is free software;  you can  redistribute it  and/or modify it under --
+-- terms of the  GNU General Public License as published  by the Free Soft- --
+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --
+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --
+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --
+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --
+--                                                                          --
+-- As a special exception under Section 7 of GPL version 3, you are granted --
+-- additional permissions described in the GCC Runtime Library Exception,   --
+-- version 3.1, as published by the Free Software Foundation.               --
+--                                                                          --
+-- You should have received a copy of the GNU General Public License and    --
+-- a copy of the GCC Runtime Library Exception along with this program;     --
+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --
+-- <http://www.gnu.org/licenses/>.                                          --
+--                                                                          --
+-- GNARL was developed by the GNARL team at Florida State University. It is --
+-- now maintained by Ada Core Technologies Inc. in cooperation with Florida --
+-- State University (http://www.gnat.com).                                  --
+--                                                                          --
+------------------------------------------------------------------------------
+
+--  This is the NetBSD (POSIX Threads) version of this package
+
+--  This package encapsulates all direct interfaces to OS services
+--  that are needed by the tasking run-time (libgnarl).
+
+--  PLEASE DO NOT add any with-clauses to this package or remove the pragma
+--  Preelaborate. This package is designed to be a bottom-level (leaf) package.
+
+with Ada.Unchecked_Conversion;
+
+with Interfaces.C;
+with System.OS_Constants;
+
+package System.OS_Interface is
+   pragma Preelaborate;
+
+   pragma Linker_Options ("-lrt");
+   pragma Linker_Options ("-pthread");
+
+   subtype int            is Interfaces.C.int;
+   subtype short          is Interfaces.C.short;
+   subtype long           is Interfaces.C.long;
+   subtype unsigned       is Interfaces.C.unsigned;
+   subtype unsigned_short is Interfaces.C.unsigned_short;
+   subtype unsigned_long  is Interfaces.C.unsigned_long;
+   subtype unsigned_char  is Interfaces.C.unsigned_char;
+   subtype plain_char     is Interfaces.C.plain_char;
+   subtype size_t         is Interfaces.C.size_t;
+   subtype char_array     is Interfaces.C.char_array;
+   subtype int64          is Interfaces.Integer_64;
+
+   -----------
+   -- Errno --
+   -----------
+
+   function Errno return int;
+   pragma Inline (Errno);
+
+   EAGAIN    : constant := 35;
+   EINTR     : constant := 4;
+   EINVAL    : constant := 22;
+   ENOMEM    : constant := 12;
+   ETIMEDOUT : constant := 60;
+
+   -------------
+   -- Signals --
+   -------------
+
+   Max_Interrupt : constant := 31;
+   type Signal is new int range 0 .. Max_Interrupt;
+   for Signal'Size use int'Size;
+
+   SIGHUP     : constant := 1; --  hangup
+   SIGINT     : constant := 2; --  interrupt (rubout)
+   SIGQUIT    : constant := 3; --  quit (ASCD FS)
+   SIGILL     : constant := 4; --  illegal instruction (not reset)
+   SIGTRAP    : constant := 5; --  trace trap (not reset)
+   SIGIOT     : constant := 6; --  IOT instruction
+   SIGABRT    : constant := 6; --  used by abort, replace SIGIOT in the  future
+   SIGEMT     : constant := 7; --  EMT instruction
+   SIGFPE     : constant := 8; --  floating point exception
+   SIGKILL    : constant := 9; --  kill (cannot be caught or ignored)
+   SIGBUS     : constant := 10; --  bus error
+   SIGSEGV    : constant := 11; --  segmentation violation
+   SIGSYS     : constant := 12; --  bad argument to system call
+   SIGPIPE    : constant := 13; --  write on a pipe with no one to read it
+   SIGALRM    : constant := 14; --  alarm clock
+   SIGTERM    : constant := 15; --  software termination signal from kill
+   SIGURG     : constant := 16; --  urgent condition on IO channel
+   SIGSTOP    : constant := 17; --  stop (cannot be caught or ignored)
+   SIGTSTP    : constant := 18; --  user stop requested from tty
+   SIGCONT    : constant := 19; --  stopped process has been continued
+   SIGCLD     : constant := 20; --  alias for SIGCHLD
+   SIGCHLD    : constant := 20; --  child status change
+   SIGTTIN    : constant := 21; --  background tty read attempted
+   SIGTTOU    : constant := 22; --  background tty write attempted
+   SIGIO      : constant := 23; --  I/O possible (Solaris SIGPOLL alias)
+   SIGXCPU    : constant := 24; --  CPU time limit exceeded
+   SIGXFSZ    : constant := 25; --  filesize limit exceeded
+   SIGVTALRM  : constant := 26; --  virtual timer expired
+   SIGPROF    : constant := 27; --  profiling timer expired
+   SIGWINCH   : constant := 28; --  window size change
+   SIGINFO    : constant := 29; --  information request (NetBSD/FreeBSD)
+   SIGUSR1    : constant := 30; --  user defined signal 1
+   SIGUSR2    : constant := 31; --  user defined signal 2
+
+   SIGADAABORT : constant := SIGABRT;
+   --  Change this if you want to use another signal for task abort.
+   --  SIGTERM might be a good one.
+
+   type Signal_Set is array (Natural range <>) of Signal;
+
+   --  Interrupts that must be unmasked at all times.  FreeBSD
+   --  pthreads will not allow an application to mask out any
+   --  interrupt needed by the threads library.
+   Unmasked : constant Signal_Set :=
+     (SIGTRAP, SIGBUS, SIGTTIN, SIGTTOU, SIGTSTP);
+
+   --  FreeBSD will uses SIGPROF for timing.  Do not allow a
+   --  handler to attach to this signal.
+   Reserved : constant Signal_Set := (0 .. 0 => SIGPROF);
+
+   type sigset_t is private;
+
+   function sigaddset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigaddset, "__gnat_sigaddset");
+
+   function sigdelset
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigdelset, "__gnat_sigdelset");
+
+   function sigfillset (set : access sigset_t) return int;
+   pragma Import (C, sigfillset, "__gnat_sigfillset");
+
+   function sigismember
+     (set : access sigset_t;
+      sig : Signal) return int;
+   pragma Import (C, sigismember, "__gnat_sigismember");
+
+   function sigemptyset (set : access sigset_t) return int;
+   pragma Import (C, sigemptyset, "__gnat_sigemptyset");
+
+   --  sigcontext is architecture dependent, so define it private
+   type struct_sigcontext is private;
+
+   type old_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_mask    : sigset_t;
+      sa_flags   : int;
+   end record;
+   pragma Convention (C, old_struct_sigaction);
+
+   type new_struct_sigaction is record
+      sa_handler : System.Address;
+      sa_flags   : int;
+      sa_mask    : sigset_t;
+   end record;
+   pragma Convention (C, new_struct_sigaction);
+
+   subtype struct_sigaction is new_struct_sigaction;
+   type struct_sigaction_ptr is access all struct_sigaction;
+
+   SIG_BLOCK   : constant := 1;
+   SIG_UNBLOCK : constant := 2;
+   SIG_SETMASK : constant := 3;
+
+   SIG_DFL : constant := 0;
+   SIG_IGN : constant := 1;
+
+   SA_SIGINFO : constant := 16#0040#;
+   SA_ONSTACK : constant := 16#0001#;
+
+   function sigaction
+     (sig  : Signal;
+      act  : struct_sigaction_ptr;
+      oact : struct_sigaction_ptr) return int;
+   pragma Import (C, sigaction, "__gnat_sigaction");
+
+   ----------
+   -- Time --
+   ----------
+
+   Time_Slice_Supported : constant Boolean := True;
+   --  Indicates whether time slicing is supported (i.e SCHED_RR is supported)
+
+   type timespec is private;
+
+   function nanosleep (rqtp, rmtp : access timespec) return int;
+   pragma Import (C, nanosleep, "__gnat_nanosleep");
+
+   type clockid_t is new int;
+
+   function clock_getres
+     (clock_id : clockid_t;
+      res      : access timespec) return int;
+   pragma Import (C, clock_getres, "__gnat_clock_getres");
+
+   function clock_gettime
+     (clock_id : clockid_t;
+      tp       : access timespec)
+      return int;
+   pragma Import (C, clock_gettime, "__gnat_clock_gettime");
+
+   function To_Duration (TS : timespec) return Duration;
+   pragma Inline (To_Duration);
+
+   function To_Timespec (D : Duration) return timespec;
+   pragma Inline (To_Timespec);
+
+   type struct_timezone is record
+      tz_minuteswest : int;
+      tz_dsttime     : int;
+   end record;
+   pragma Convention (C, struct_timezone);
+
+   procedure usleep (useconds : unsigned_long);
+   pragma Import (C, usleep, "usleep");
+
+   -------------------------
+   -- Priority Scheduling --
+   -------------------------
+
+   SCHED_OTHER : constant := 0;
+   SCHED_FIFO  : constant := 1;
+   SCHED_RR    : constant := 2;
+
+   --  pthread_setschedparam is implementation-defined for SCHED_OTHER.
+   --  NetBSD only supports PRI_NONE (-1), see <sys/param.h>
+   STATIC_PRIORITY_FOR_SCHEDULER : constant Boolean := True;
+   DEFAULT_SCHEDULER_PRIORITY    : constant := -1;
+
+   function To_Target_Priority
+     (Prio : System.Any_Priority) return Interfaces.C.int;
+   --  Maps System.Any_Priority to a POSIX priority
+
+   -------------
+   -- Process --
+   -------------
+
+   type pid_t is private;
+
+   Self_PID : constant pid_t;
+
+   function kill (pid : pid_t; sig : Signal) return int;
+   pragma Import (C, kill, "kill");
+
+   function getpid return pid_t;
+   pragma Import (C, getpid, "getpid");
+
+   ---------
+   -- LWP --
+   ---------
+
+   function lwp_self return System.Address;
+   --  lwp_self does not exist on this thread library, revert to pthread_self
+   --  which is the closest approximation (with getpid). This function is
+   --  needed to share 7staprop.adb across POSIX-like targets.
+   pragma Import (C, lwp_self, "pthread_self");
+
+   -------------
+   -- Threads --
+   -------------
+
+   type Thread_Body is access
+     function (arg : System.Address) return System.Address;
+   pragma Convention (C, Thread_Body);
+
+   function Thread_Body_Access is new
+     Ada.Unchecked_Conversion (System.Address, Thread_Body);
+
+   type pthread_t           is private;
+   subtype Thread_Id        is pthread_t;
+
+   type pthread_mutex_t      is limited private;
+   type pthread_cond_t       is limited private;
+   type pthread_attr_t       is limited private;
+   type pthread_mutexattr_t  is limited private;
+   type pthread_condattr_t   is limited private;
+   type pthread_rwlock_t     is limited private;
+   type pthread_rwlockattr_t is limited private;
+   type pthread_key_t        is private;
+
+   PTHREAD_CREATE_DETACHED : constant := 1;
+   PTHREAD_CREATE_JOINABLE : constant := 0;
+
+   PTHREAD_SCOPE_PROCESS : constant := 0;
+   PTHREAD_SCOPE_SYSTEM  : constant := 2;
+
+   -----------
+   -- Stack --
+   -----------
+
+   type stack_t is record
+      ss_sp    : System.Address;
+      ss_size  : size_t;
+      ss_flags : int;
+   end record;
+   pragma Convention (C, stack_t);
+
+   function sigaltstack
+     (ss  : not null access stack_t;
+      oss : access stack_t) return int;
+   pragma Import (C, sigaltstack, "__gnat_sigaltstack");
+
+   Alternate_Stack : aliased System.Address;
+   --  This is a dummy definition, never used (Alternate_Stack_Size is null)
+
+   Alternate_Stack_Size : constant := 0;
+   --  No alternate signal stack is used on this platform
+
+   Stack_Base_Available : constant Boolean := False;
+   --  Indicates whether the stack base is available on this target
+
+   function Get_Stack_Base (thread : pthread_t) return Address;
+   pragma Inline (Get_Stack_Base);
+   --  returns the stack base of the specified thread. Only call this function
+   --  when Stack_Base_Available is True.
+
+   function Get_Page_Size return int;
+   pragma Import (C, Get_Page_Size, "getpagesize");
+   --  Returns the size of a page
+
+   PROT_NONE  : constant := 0;
+   PROT_READ  : constant := 1;
+   PROT_WRITE : constant := 2;
+   PROT_EXEC  : constant := 4;
+   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;
+   PROT_ON    : constant := PROT_NONE;
+   PROT_OFF   : constant := PROT_ALL;
+
+   function mprotect (addr : Address; len : size_t; prot : int) return int;
+   pragma Import (C, mprotect);
+
+   ---------------------------------------
+   -- Nonstandard Thread Initialization --
+   ---------------------------------------
+
+   --  FSU_THREADS requires pthread_init, which is nonstandard and this should
+   --  be invoked during the elaboration of s-taprop.adb.
+
+   --  NetBSD does not require this so we provide an empty Ada body
+
+   procedure pthread_init;
+
+   -------------------------
+   -- POSIX.1c  Section 3 --
+   -------------------------
+
+   function sigwait
+     (set : access sigset_t;
+      sig : access Signal) return int;
+   pragma Import (C, sigwait, "sigwait");
+
+   function pthread_kill
+     (thread : pthread_t;
+      sig    : Signal) return int;
+   pragma Import (C, pthread_kill, "pthread_kill");
+
+   function pthread_sigmask
+     (how  : int;
+      set  : access sigset_t;
+      oset : access sigset_t) return int;
+   pragma Import (C, pthread_sigmask, "pthread_sigmask");
+
+   --------------------------
+   -- POSIX.1c  Section 11 --
+   --------------------------
+
+   function pthread_mutexattr_init
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_init, "pthread_mutexattr_init");
+
+   function pthread_mutexattr_destroy
+     (attr : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutexattr_destroy, "pthread_mutexattr_destroy");
+
+   function pthread_mutex_init
+     (mutex : access pthread_mutex_t;
+      attr  : access pthread_mutexattr_t) return int;
+   pragma Import (C, pthread_mutex_init, "pthread_mutex_init");
+
+   function pthread_mutex_destroy (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_destroy, "pthread_mutex_destroy");
+
+   function pthread_mutex_lock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_lock, "pthread_mutex_lock");
+
+   function pthread_mutex_unlock (mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_mutex_unlock, "pthread_mutex_unlock");
+
+   function pthread_condattr_init
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_init, "pthread_condattr_init");
+
+   function pthread_condattr_destroy
+     (attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_condattr_destroy, "pthread_condattr_destroy");
+
+   function pthread_cond_init
+     (cond : access pthread_cond_t;
+      attr : access pthread_condattr_t) return int;
+   pragma Import (C, pthread_cond_init, "pthread_cond_init");
+
+   function pthread_cond_destroy (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_destroy, "pthread_cond_destroy");
+
+   function pthread_cond_signal (cond : access pthread_cond_t) return int;
+   pragma Import (C, pthread_cond_signal, "pthread_cond_signal");
+
+   function pthread_cond_wait
+     (cond  : access pthread_cond_t;
+      mutex : access pthread_mutex_t) return int;
+   pragma Import (C, pthread_cond_wait, "pthread_cond_wait");
+
+   function pthread_cond_timedwait
+     (cond    : access pthread_cond_t;
+      mutex   : access pthread_mutex_t;
+      abstime : access timespec) return int;
+   pragma Import (C, pthread_cond_timedwait, "pthread_cond_timedwait");
+
+   --------------------------
+   -- POSIX.1c  Section 13 --
+   --------------------------
+
+   PTHREAD_PRIO_NONE    : constant := 0;
+   PTHREAD_PRIO_INHERIT : constant := 1;
+   PTHREAD_PRIO_PROTECT : constant := 2;
+
+   function pthread_mutexattr_setprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : int) return int;
+   pragma Import
+      (C, pthread_mutexattr_setprotocol, "pthread_mutexattr_setprotocol");
+
+   function pthread_mutexattr_getprotocol
+     (attr     : access pthread_mutexattr_t;
+      protocol : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprotocol, "pthread_mutexattr_getprotocol");
+
+   function pthread_mutexattr_setprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : int) return int;
+   pragma Import
+     (C, pthread_mutexattr_setprioceiling,
+      "pthread_mutexattr_setprioceiling");
+
+   function pthread_mutexattr_getprioceiling
+     (attr     : access pthread_mutexattr_t;
+      prioceiling : access int) return int;
+   pragma Import
+     (C, pthread_mutexattr_getprioceiling,
+      "pthread_mutexattr_getprioceiling");
+
+   type struct_sched_param is record
+      sched_priority : int;
+   end record;
+   pragma Convention (C, struct_sched_param);
+
+   function pthread_getschedparam
+     (thread : pthread_t;
+      policy : access int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_getschedparam, "pthread_getschedparam");
+
+   function pthread_setschedparam
+     (thread : pthread_t;
+      policy : int;
+      param  : access struct_sched_param) return int;
+   pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
+
+   function pthread_attr_setscope
+     (attr            : access pthread_attr_t;
+      contentionscope : int) return int;
+   pragma Import (C, pthread_attr_setscope, "pthread_attr_setscope");
+
+   function pthread_attr_getscope
+     (attr            : access pthread_attr_t;
+      contentionscope : access int) return int;
+   pragma Import (C, pthread_attr_getscope, "pthread_attr_getscope");
+
+   function pthread_attr_setinheritsched
+     (attr            : access pthread_attr_t;
+      inheritsched : int) return int;
+   pragma Import
+     (C, pthread_attr_setinheritsched, "pthread_attr_setinheritsched");
+
+   function pthread_attr_getinheritsched
+     (attr         : access pthread_attr_t;
+      inheritsched : access int) return int;
+   pragma Import
+     (C, pthread_attr_getinheritsched, "pthread_attr_getinheritsched");
+
+   function pthread_attr_setschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : int) return int;
+   pragma Import (C, pthread_attr_setschedpolicy,
+     "pthread_attr_setschedpolicy");
+
+   function pthread_attr_getschedpolicy
+     (attr   : access pthread_attr_t;
+      policy : access int) return int;
+   pragma Import (C, pthread_attr_getschedpolicy,
+     "pthread_attr_getschedpolicy");
+
+   function pthread_attr_setschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : int) return int;
+   pragma Import (C, pthread_attr_setschedparam, "pthread_attr_setschedparam");
+
+   function pthread_attr_getschedparam
+     (attr        : access pthread_attr_t;
+      sched_param : access int) return int;
+   pragma Import (C, pthread_attr_getschedparam, "pthread_attr_getschedparam");
+
+   function sched_yield return int;
+   pragma Import (C, sched_yield, "sched_yield");
+
+   --------------------------
+   -- P1003.1c  Section 16 --
+   --------------------------
+
+   function pthread_attr_init (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_init, "pthread_attr_init");
+
+   function pthread_attr_destroy
+     (attributes : access pthread_attr_t) return int;
+   pragma Import (C, pthread_attr_destroy, "pthread_attr_destroy");
+
+   function pthread_attr_setdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : int) return int;
+   pragma Import
+     (C, pthread_attr_setdetachstate, "pthread_attr_setdetachstate");
+
+   function pthread_attr_getdetachstate
+     (attr        : access pthread_attr_t;
+      detachstate : access int) return int;
+   pragma Import
+     (C, pthread_attr_getdetachstate, "pthread_attr_getdetachstate");
+
+   function pthread_attr_getstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : access size_t) return int;
+   pragma Import
+     (C, pthread_attr_getstacksize, "pthread_attr_getstacksize");
+
+   function pthread_attr_setstacksize
+     (attr      : access pthread_attr_t;
+      stacksize : size_t) return int;
+   pragma Import
+     (C, pthread_attr_setstacksize, "pthread_attr_setstacksize");
+
+   function pthread_create
+     (thread        : access pthread_t;
+      attributes    : access pthread_attr_t;
+      start_routine : Thread_Body;
+      arg           : System.Address) return int;
+   pragma Import (C, pthread_create, "pthread_create");
+
+   function pthread_detach (thread : pthread_t) return int;
+   pragma Import (C, pthread_detach, "pthread_detach");
+
+   procedure pthread_exit (status : System.Address);
+   pragma Import (C, pthread_exit, "pthread_exit");
+
+   function pthread_self return pthread_t;
+   pragma Import (C, pthread_self, "pthread_self");
+
+   --------------------------
+   -- POSIX.1c  Section 17 --
+   --------------------------
+
+   function pthread_setspecific
+     (key   : pthread_key_t;
+      value : System.Address) return  int;
+   pragma Import (C, pthread_setspecific, "pthread_setspecific");
+
+   function pthread_getspecific (key : pthread_key_t) return System.Address;
+   pragma Import (C, pthread_getspecific, "pthread_getspecific");
+
+   type destructor_pointer is access procedure (arg : System.Address);
+   pragma Convention (C, destructor_pointer);
+
+   function pthread_key_create
+     (key        : access pthread_key_t;
+      destructor : destructor_pointer) return int;
+   pragma Import (C, pthread_key_create, "pthread_key_create");
+
+   ------------------------------------
+   -- Non-portable Pthread Functions --
+   ------------------------------------
+
+private
+
+   type sigset_t is array (1 .. 4) of unsigned;
+
+   --  In FreeBSD the component sa_handler turns out to
+   --  be one a union type, and the selector is a macro:
+   --  #define sa_handler __sigaction_u._handler
+   --  #define sa_sigaction __sigaction_u._sigaction
+
+   --  Should we add a signal_context type here ???
+   --  How could it be done independent of the CPU architecture ???
+   --  sigcontext type is opaque, so it is architecturally neutral.
+   --  It is always passed as an access type, so define it as an empty record
+   --  since the contents are not used anywhere.
+
+   type struct_sigcontext is null record;
+   pragma Convention (C, struct_sigcontext);
+
+   type pid_t is new int;
+   Self_PID : constant pid_t := 0;
+
+   type time_t is new int64;
+
+   type timespec is record
+      ts_sec  : time_t;
+      ts_nsec : long;
+   end record;
+   pragma Convention (C, timespec);
+
+   type pthread_t     is new System.Address;
+   type pthread_key_t is new int;
+
+   type pthread_attr_t is record
+      Data : char_array (1 .. System.OS_Constants.PTHREAD_ATTR_SIZE);
+   end record;
+   pragma Convention (C, pthread_attr_t);
+   for pthread_attr_t'Alignment use size_t'Alignment;
+
+   type pthread_mutex_t is record
+      Data : char_array (1 .. System.OS_Constants.PTHREAD_MUTEX_SIZE);
+   end record;
+   pragma Convention (C, pthread_mutex_t);
+   for pthread_mutex_t'Alignment use size_t'Alignment;
+
+   type pthread_mutexattr_t is record
+      Data : char_array (1 .. System.OS_Constants.PTHREAD_MUTEXATTR_SIZE);
+   end record;
+   pragma Convention (C, pthread_mutexattr_t);
+   for pthread_mutexattr_t'Alignment use size_t'Alignment;
+
+   type pthread_cond_t is record
+      Data : char_array (1 .. System.OS_Constants.PTHREAD_COND_SIZE);
+   end record;
+   pragma Convention (C, pthread_cond_t);
+   for pthread_cond_t'Alignment use size_t'Alignment;
+
+   type pthread_condattr_t is record
+      Data : char_array (1 .. System.OS_Constants.PTHREAD_CONDATTR_SIZE);
+   end record;
+   pragma Convention (C, pthread_condattr_t);
+   for pthread_condattr_t'Alignment use size_t'Alignment;
+
+   type pthread_rwlock_t is record
+      Data : char_array (1 .. System.OS_Constants.PTHREAD_RWLOCK_SIZE);
+   end record;
+   pragma Convention (C, pthread_rwlock_t);
+   for pthread_rwlock_t'Alignment use size_t'Alignment;
+
+   type pthread_rwlockattr_t is record
+      Data : char_array (1 .. System.OS_Constants.PTHREAD_RWLOCKATTR_SIZE);
+   end record;
+   pragma Convention (C, pthread_rwlockattr_t);
+   for pthread_rwlockattr_t'Alignment use size_t'Alignment;
+
+end System.OS_Interface;
--- gcc/ada/libgnarl/s-taprop__posix.adb.orig
+++ gcc/ada/libgnarl/s-taprop__posix.adb
@@ -610,6 +610,9 @@ package body System.Task_Primitives.Operations is
         or else Priority_Specific_Policy = 'F'
         or else Time_Slice_Val = 0
       then
+         if STATIC_PRIORITY_FOR_SCHEDULER then
+            Param.sched_priority := DEFAULT_SCHEDULER_PRIORITY;
+         end if;
          Result := pthread_setschedparam
            (T.Common.LL.Thread, SCHED_FIFO, Param'Access);
 
--- gcc/ada/libgnarl/s-osinte__android.ads.orig
+++ gcc/ada/libgnarl/s-osinte__android.ads
@@ -241,6 +241,11 @@ package System.OS_Interface is
    SCHED_FIFO  : constant := 1;
    SCHED_RR    : constant := 2;
 
+   --  pthread_setschedparam is implementation-defined for SCHED_OTHER.
+   --  Android supports the full priority range.
+   STATIC_PRIORITY_FOR_SCHEDULER : constant Boolean := False;
+   DEFAULT_SCHEDULER_PRIORITY    : constant := 0;
+
    function To_Target_Priority
      (Prio : System.Any_Priority)
       return Interfaces.C.int is (Interfaces.C.int (Prio));
--- gcc/ada/libgnarl/s-osinte__dragonfly.ads.orig
+++ gcc/ada/libgnarl/s-osinte__dragonfly.ads
@@ -239,6 +239,11 @@ package System.OS_Interface is
    SCHED_OTHER : constant := 2;
    SCHED_RR    : constant := 3;
 
+   --  pthread_setschedparam is implementation-defined for SCHED_OTHER.
+   --  DragonFly supports the full priority range.
+   STATIC_PRIORITY_FOR_SCHEDULER : constant Boolean := False;
+   DEFAULT_SCHEDULER_PRIORITY    : constant := 0;
+
    function To_Target_Priority
      (Prio : System.Any_Priority) return Interfaces.C.int;
    --  Maps System.Any_Priority to a POSIX priority
--- gcc/ada/libgnarl/s-osinte__freebsd.ads.orig
+++ gcc/ada/libgnarl/s-osinte__freebsd.ads
@@ -239,6 +239,11 @@ package System.OS_Interface is
    SCHED_OTHER : constant := 2;
    SCHED_RR    : constant := 3;
 
+   --  pthread_setschedparam is implementation-defined for SCHED_OTHER.
+   --  FreeBSD supports the full priority range.
+   STATIC_PRIORITY_FOR_SCHEDULER : constant Boolean := False;
+   DEFAULT_SCHEDULER_PRIORITY    : constant := 0;
+
    function To_Target_Priority
      (Prio : System.Any_Priority) return Interfaces.C.int;
    --  Maps System.Any_Priority to a POSIX priority
--- gcc/ada/libgnat/g-socthi.ads.orig
+++ gcc/ada/libgnat/g-socthi.ads
@@ -256,7 +256,7 @@ private
    pragma Inline (C_Getsockname);
    pragma Inline (C_Getsockopt);
    pragma Import (C, C_Listen, "listen");
-   pragma Import (C, C_Select, "select");
+   pragma Import (C, C_Select, "__gnat_select");
    pragma Inline (C_Setsockopt);
    pragma Import (C, C_Shutdown, "shutdown");
    pragma Import (C, C_Socketpair, "socketpair");
--- gcc/ada/libgnat/s-osprim__posix.adb.orig
+++ gcc/ada/libgnat/s-osprim__posix.adb
@@ -49,7 +49,7 @@ package body System.OS_Primitives is
    pragma Convention (C, timespec);
 
    function nanosleep (rqtp, rmtp : not null access timespec) return Integer;
-   pragma Import (C, nanosleep, "nanosleep");
+   pragma Import (C, nanosleep, "__gnat_nanosleep");
 
    -----------
    -- Clock --
@@ -79,7 +79,7 @@ package body System.OS_Primitives is
       function gettimeofday
         (Tv : access timeval;
          Tz : System.Address := System.Null_Address) return Integer;
-      pragma Import (C, gettimeofday, "gettimeofday");
+      pragma Import (C, gettimeofday, "__gnat_gettimeofday");
 
    begin
       --  The return codes for gettimeofday are as follows (from man pages):
--- gcc/ada/s-oscons-tmplt.c.orig
+++ gcc/ada/s-oscons-tmplt.c
@@ -407,7 +407,7 @@ CND(FNDELAY, "Nonblocking")
 
 /* ioctl(2) requests are "int" in UNIX, but "unsigned long" on FreeBSD */
 
-#if defined (__FreeBSD__) || defined (__DragonFly__)
+#if defined (__FreeBSD__) || defined (__DragonFly__) || defined (__NetBSD__)
 # define CNI CNU
 # define IOCTL_Req_T "Interfaces.C.unsigned"
 #else
@@ -1054,7 +1054,7 @@ CNU(RTS_CONTROL_ENABLE, "Enable RTS flow ctrl")
 
 */
 
-#if defined (__FreeBSD__) || defined (__linux__) || defined (__DragonFly__)
+#if defined (__FreeBSD__) || defined (__linux__) || defined (__DragonFly__) || defined (__NetBSD__)
 # define PTY_Library "-lutil"
 #else
 # define PTY_Library ""
@@ -1975,6 +1975,7 @@ CND(CLOCK_THREAD_CPUTIME_ID, "Thread CPU clock")
 
 #if defined(__linux__) || defined(__FreeBSD__) \
  || (defined(_AIX) && defined(_AIXVERSION_530)) \
+ || defined(__NetBSD__) \
  || defined(__DragonFly__) || defined(__QNX__) \
  || defined (__vxworks)
 /** On these platforms use system provided monotonic clock instead of
@@ -1999,6 +2000,7 @@ CNS(CLOCK_RT_Ada, "")
 
 #if defined (__APPLE__) || defined (__ANDROID__) || defined (DUMMY) \
   || defined (__FreeBSD__) || defined (__linux__) \
+  || defined (__DragonFly__) || defined (__NetBSD__) \
   || defined (__QNX__) || defined (__rtems__) || defined (__GNU__)
 
 /*
--- gcc/ada/sysdep.c.orig
+++ gcc/ada/sysdep.c
@@ -338,6 +338,7 @@ __gnat_ttyname (int filedes ATTRIBUTE_UNUSED)
   || (defined (__svr4__) && defined (__i386__)) || defined (__Lynx__) \
   || defined (__CYGWIN__) || defined (__FreeBSD__) || defined (__OpenBSD__) \
   || defined (__GLIBC__) || defined (__APPLE__) || defined (__DragonFly__) \
+  || defined (__NetBSD__) \
   || defined (__QNX__)
 
 # ifdef __MINGW32__
@@ -387,6 +388,7 @@ getc_immediate_common (FILE *stream,
     || defined (_AIX) || (defined (__svr4__) && defined (__i386__)) \
     || defined (__Lynx__) || defined (__FreeBSD__) || defined (__OpenBSD__) \
     || defined (__GLIBC__) || defined (__APPLE__) || defined (__DragonFly__) \
+    || defined (__NetBSD__) \
     || defined (__QNX__)
   char c;
   int nread;
@@ -408,6 +410,7 @@ getc_immediate_common (FILE *stream,
     || defined (_AIX) || (defined (__svr4__) && defined (__i386__)) \
     || defined (__Lynx__) || defined (__FreeBSD__) || defined (__OpenBSD__) \
     || defined (__GLIBC__) || defined (__APPLE__) || defined (__DragonFly__) \
+    || defined (__NetBSD__) \
     || defined (__QNX__)
       eof_ch = termios_rec.c_cc[VEOF];
 
@@ -847,6 +850,7 @@ __gnat_localtime_tzoff (const OS_Time *timer ATTRIBUTE
 
 #elif defined (__APPLE__) || defined (__FreeBSD__) || defined (__linux__) \
   || defined (__GLIBC__) || defined (__DragonFly__) || defined (__OpenBSD__) \
+  || defined (__NetBSD__) \
   || defined (__DJGPP__) || defined (__QNX__)
 {
   localtime_r (&time, &tp);
--- gnattools/configure.orig
+++ gnattools/configure
@@ -2075,6 +2075,9 @@ case "${target}" in
   *-*-freebsd*)
     TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
+  *-*-netbsd*)
+    TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
+    ;;
   *-*-linux*)
     TOOLS_TARGET_PAIRS="indepsw.adb<indepsw-gnu.adb"
     ;;
